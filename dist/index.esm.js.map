{"version":3,"file":"index.esm.js","sources":["../src/Interfaces.ts","../src/utils/implementsAbstractType.ts","../src/wrap/transforms/ExpandAbstractTypes.ts","../src/esUtils/keyValMap.ts","../src/wrap/transforms/FilterToSchema.ts","../src/wrap/transforms/AddReplacementSelectionSets.ts","../src/wrap/transforms/AddReplacementFragments.ts","../src/wrap/transforms/AddMergedTypeSelectionSets.ts","../src/delegate/addTypenameToAbstract.ts","../src/wrap/transforms/AddTypenameToAbstract.ts","../src/stitch/getResponseKeyFromInfo.ts","../src/stitch/symbols.ts","../src/stitch/errors.ts","../src/delegate/results/handleNull.ts","../src/utils/collectFields.ts","../src/stitch/subSchema.ts","../src/stitch/resolveFromParentTypename.ts","../src/esUtils/mergeDeep.ts","../src/stitch/proxiedResult.ts","../src/stitch/mergeFields.ts","../src/delegate/results/handleObject.ts","../src/delegate/results/handleList.ts","../src/delegate/checkResultAndHandleErrors.ts","../src/wrap/transforms/CheckResultAndHandleErrors.ts","../src/utils/transformInputValue.ts","../src/utils/astFromType.ts","../src/utils/updateArgument.ts","../src/esUtils/toObjMap.ts","../src/wrap/transforms/AddArgumentsAsVariables.ts","../src/utils/graphqlVersion.ts","../src/esUtils/hasOwnProperty.ts","../src/polyfills/toConfig.ts","../src/polyfills/isSpecifiedScalarType.ts","../src/utils/map.ts","../src/utils/filterSchema.ts","../src/utils/clone.ts","../src/polyfills/buildSchema.ts","../src/utils/getResolversFromSchema.ts","../src/polyfills/extendSchema.ts","../src/esUtils/updateEachKey.ts","../src/utils/stub.ts","../src/utils/heal.ts","../src/utils/SchemaVisitor.ts","../src/esUtils/keyMap.ts","../src/utils/valueFromASTUntyped.ts","../src/utils/visitSchema.ts","../src/utils/inspect.ts","../src/utils/getArgumentValues.ts","../src/utils/SchemaDirectiveVisitor.ts","../src/utils/forEachField.ts","../src/utils/forEachDefaultValue.ts","../src/wrap/transforms.ts","../src/stitch/linkToFetcher.ts","../src/stitch/observableToAsyncIterable.ts","../src/stitch/mapAsyncIterator.ts","../src/delegate/createRequest.ts","../src/delegate/delegateToSchema.ts","../src/generate/SchemaError.ts","../src/generate/checkForResolveTypeResolver.ts","../src/generate/extendResolversFromInterfaces.ts","../src/generate/addResolversToSchema.ts","../src/generate/addSchemaLevelResolver.ts","../src/generate/assertResolversPresent.ts","../src/generate/attachDirectiveResolvers.ts","../src/generate/attachConnectorsToContext.ts","../src/generate/extensionDefinitions.ts","../src/generate/concatenateTypeDefs.ts","../src/generate/buildSchemaFromTypeDefinitions.ts","../src/generate/chainResolvers.ts","../src/generate/decorateWithLogger.ts","../src/generate/makeExecutableSchema.ts","../src/generate/index.ts","../src/links/AwaitVariablesLink.ts","../src/links/createServerHttpLink.ts","../src/mock/index.ts","../src/scalars/GraphQLUpload.ts","../src/stitch/introspectSchema.ts","../src/stitch/defaultMergedResolver.ts","../src/stitch/makeMergedType.ts","../src/wrap/resolvers.ts","../src/wrap/wrapSchema.ts","../src/stitch/typeFromAST.ts","../src/utils/fragments.ts","../src/utils/selectionSets.ts","../src/stitch/mergeInfo.ts","../src/stitch/mergeSchemas.ts","../src/wrap/transformSchema.ts","../src/wrap/transforms/RenameTypes.ts","../src/wrap/transforms/FilterTypes.ts","../src/wrap/transforms/RenameRootTypes.ts","../src/esUtils/isEmptyObject.ts","../src/wrap/transforms/TransformCompositeFields.ts","../src/wrap/transforms/TransformObjectFields.ts","../src/wrap/transforms/TransformRootFields.ts","../src/wrap/transforms/RenameRootFields.ts","../src/wrap/transforms/FilterRootFields.ts","../src/wrap/transforms/RenameObjectFields.ts","../src/wrap/transforms/FilterObjectFields.ts","../src/wrap/transforms/TransformInterfaceFields.ts","../src/wrap/transforms/RenameInterfaceFields.ts","../src/wrap/transforms/FilterInterfaceFields.ts","../src/wrap/transforms/TransformQuery.ts","../src/wrap/transforms/MapFields.ts","../src/wrap/transforms/ExtendSchema.ts","../src/utils/fieldNodes.ts","../src/utils/fields.ts","../src/stitch/createMergedResolver.ts","../src/wrap/transforms/WrapFields.ts","../src/wrap/transforms/WrapType.ts","../src/wrap/transforms/HoistField.ts","../src/wrap/transforms/ReplaceFieldWithFragment.ts","../src/wrap/transforms/WrapQuery.ts","../src/wrap/transforms/ExtractField.ts","../src/wrap/makeRemoteExecutableSchema.ts"],"sourcesContent":["import {\n  GraphQLSchema,\n  GraphQLField,\n  GraphQLInputType,\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLIsTypeOfFn,\n  GraphQLTypeResolver,\n  GraphQLScalarType,\n  DocumentNode,\n  FieldNode,\n  GraphQLEnumValue,\n  GraphQLEnumType,\n  GraphQLUnionType,\n  GraphQLArgument,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  InlineFragmentNode,\n  GraphQLOutputType,\n  SelectionSetNode,\n  GraphQLDirective,\n  GraphQLFieldConfig,\n  FragmentDefinitionNode,\n  SelectionNode,\n  VariableDefinitionNode,\n  OperationDefinitionNode,\n  GraphQLError,\n  ExecutionResult as GraphQLExecutionResult,\n} from 'graphql';\n\nimport { ApolloLink } from 'apollo-link';\n\nimport { SchemaVisitor } from './utils/SchemaVisitor';\nimport { SchemaDirectiveVisitor } from './utils/SchemaDirectiveVisitor';\n\n// graphql-js < v15 backwards compatible ExecutionResult\n// See: https://github.com/graphql/graphql-js/pull/2490\n\nexport interface ExecutionResult<\n  TData = {\n    [key: string]: any;\n  }\n> extends GraphQLExecutionResult {\n  data?: TData | null;\n  extensions?: Record<string, any>;\n}\n\n// for backwards compatibility\nexport type Result = ExecutionResult;\n\n// graphql-js non-exported typings\n\nexport type TypeMap = Record<string, GraphQLNamedType>;\n\nexport interface GraphQLExecutionContext {\n  schema: GraphQLSchema;\n  fragments: { [key: string]: FragmentDefinitionNode };\n  rootValue: any;\n  contextValue: any;\n  operation: OperationDefinitionNode;\n  variableValues: { [key: string]: any };\n  fieldResolver: GraphQLFieldResolver<any, any>;\n  errors: Array<GraphQLError>;\n}\n\nexport interface GraphQLParseOptions {\n  noLocation?: boolean;\n  allowLegacySDLEmptyFields?: boolean;\n  allowLegacySDLImplementsInterfaces?: boolean;\n  experimentalFragmentVariables?: boolean;\n}\n\n// graphql-tools typings\n\nexport interface IResolverValidationOptions {\n  requireResolversForArgs?: boolean;\n  requireResolversForNonScalar?: boolean;\n  requireResolversForAllFields?: boolean;\n  requireResolversForResolveType?: boolean;\n  allowResolversNotInSchema?: boolean;\n}\n\n// for backwards compatibility\nexport interface IAddResolveFunctionsToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  defaultFieldResolver: IFieldResolver<any, any>;\n  resolverValidationOptions: IResolverValidationOptions;\n  inheritResolversFromInterfaces: boolean;\n}\n\nexport interface IAddResolversToSchemaOptions {\n  schema: GraphQLSchema;\n  resolvers: IResolvers;\n  defaultFieldResolver?: IFieldResolver<any, any>;\n  resolverValidationOptions?: IResolverValidationOptions;\n  inheritResolversFromInterfaces?: boolean;\n}\n\nexport interface IResolverOptions<TSource = any, TContext = any, TArgs = any> {\n  fragment?: string;\n  resolve?: IFieldResolver<TSource, TContext, TArgs>;\n  subscribe?: IFieldResolver<TSource, TContext, TArgs>;\n  extensions?: Record<string, any>;\n  __resolveType?: GraphQLTypeResolver<TSource, TContext>;\n  __isTypeOf?: GraphQLIsTypeOfFn<TSource, TContext>;\n}\n\nexport interface Transform {\n  transformSchema?: (originalSchema: GraphQLSchema) => GraphQLSchema;\n  transformRequest?: (originalRequest: Request) => Request;\n  transformResult?: (originalResult: ExecutionResult) => ExecutionResult;\n}\n\nexport type FieldTransformer = (\n  typeName: string,\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => GraphQLFieldConfig<any, any> | RenamedFieldConfig | null | undefined;\n\nexport type RootFieldTransformer = (\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  fieldName: string,\n  field: GraphQLField<any, any>,\n) => GraphQLFieldConfig<any, any> | RenamedFieldConfig | null | undefined;\n\nexport type FieldNodeTransformer = (\n  typeName: string,\n  fieldName: string,\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionNode | Array<SelectionNode>;\n\nexport type FieldNodeMapper = (\n  fieldNode: FieldNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionNode | Array<SelectionNode>;\n\nexport type FieldNodeMappers = Record<string, Record<string, FieldNodeMapper>>;\n\nexport interface RenamedFieldConfig {\n  name: string;\n  field?: GraphQLFieldConfig<any, any>;\n}\n\nexport type FieldFilter = (\n  typeName?: string,\n  fieldName?: string,\n  field?: GraphQLField<any, any>,\n) => boolean;\n\nexport type RootFieldFilter = (\n  operation?: 'Query' | 'Mutation' | 'Subscription',\n  rootFieldName?: string,\n  field?: GraphQLField<any, any>,\n) => boolean;\n\nexport type RenameTypesOptions = {\n  renameBuiltins: boolean;\n  renameScalars: boolean;\n};\n\nexport interface IGraphQLToolsResolveInfo extends GraphQLResolveInfo {\n  mergeInfo?: MergeInfo;\n}\n\nexport type Fetcher = (\n  operation: IFetcherOperation,\n) => Promise<ExecutionResult>;\n\nexport interface IFetcherOperation {\n  query: DocumentNode;\n  operationName?: string;\n  variables?: { [key: string]: any };\n  context?: { [key: string]: any };\n}\n\nexport type Dispatcher = (context: any) => ApolloLink | Fetcher;\n\nexport interface SubschemaConfig {\n  schema: GraphQLSchema;\n  rootValue?: Record<string, any>;\n  link?: ApolloLink;\n  fetcher?: Fetcher;\n  dispatcher?: Dispatcher;\n  createProxyingResolver?: CreateProxyingResolverFn;\n  transforms?: Array<Transform>;\n  merge?: Record<string, MergedTypeConfig>;\n}\n\nexport interface MergedTypeConfig {\n  selectionSet?: string;\n  fieldName?: string;\n  args?: (originalResult: any) => Record<string, any>;\n  resolve?: MergedTypeResolver;\n}\n\nexport type MergedTypeResolver = (\n  originalResult: any,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  subschema: GraphQLSchema | SubschemaConfig,\n  selectionSet: SelectionSetNode,\n) => any;\n\nexport interface GraphQLSchemaWithTransforms extends GraphQLSchema {\n  transforms?: Array<Transform>;\n}\n\nexport type SchemaLikeObject =\n  | SubschemaConfig\n  | GraphQLSchema\n  | string\n  | DocumentNode\n  | Array<GraphQLNamedType>;\n\nexport function isSubschemaConfig(\n  value: SchemaLikeObject,\n): value is SubschemaConfig {\n  return Boolean((value as SubschemaConfig).schema);\n}\n\nexport interface IDelegateToSchemaOptions<TContext = { [key: string]: any }> {\n  schema: GraphQLSchema | SubschemaConfig;\n  operation?: Operation;\n  fieldName?: string;\n  returnType?: GraphQLOutputType;\n  args?: { [key: string]: any };\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n  context?: TContext;\n  info: IGraphQLToolsResolveInfo;\n  rootValue?: Record<string, any>;\n  transforms?: Array<Transform>;\n  skipValidation?: boolean;\n  skipTypeMerging?: boolean;\n}\n\nexport interface ICreateRequestFromInfo {\n  info: IGraphQLToolsResolveInfo;\n  operation: Operation;\n  fieldName: string;\n  selectionSet?: SelectionSetNode;\n  fieldNodes?: ReadonlyArray<FieldNode>;\n}\n\nexport interface ICreateRequest {\n  sourceSchema: GraphQLSchema;\n  sourceParentType: GraphQLObjectType;\n  sourceFieldName: string;\n  fragments: Record<string, FragmentDefinitionNode>;\n  variableDefinitions: ReadonlyArray<VariableDefinitionNode>;\n  variableValues: Record<string, any>;\n  targetOperation: Operation;\n  targetFieldName: string;\n  selectionSet: SelectionSetNode;\n  fieldNodes: ReadonlyArray<FieldNode>;\n}\n\nexport interface IDelegateRequestOptions extends IDelegateToSchemaOptions {\n  request: Request;\n}\n\nexport interface MergeInfo {\n  delegate: (\n    type: 'query' | 'mutation' | 'subscription',\n    fieldName: string,\n    args: { [key: string]: any },\n    context: { [key: string]: any },\n    info: GraphQLResolveInfo,\n    transforms?: Array<Transform>,\n  ) => any;\n  fragments: Array<{\n    field: string;\n    fragment: string;\n  }>;\n  replacementSelectionSets: ReplacementSelectionSetMapping;\n  replacementFragments: ReplacementFragmentMapping;\n  mergedTypes: Record<string, MergedTypeInfo>;\n  delegateToSchema<TContext>(options: IDelegateToSchemaOptions<TContext>): any;\n}\n\nexport interface ReplacementSelectionSetMapping {\n  [typeName: string]: { [fieldName: string]: SelectionSetNode };\n}\n\nexport interface ReplacementFragmentMapping {\n  [typeName: string]: { [fieldName: string]: InlineFragmentNode };\n}\n\nexport interface MergedTypeInfo {\n  subschemas: Array<SubschemaConfig>;\n  selectionSet?: SelectionSetNode;\n  uniqueFields: Record<string, SubschemaConfig>;\n  nonUniqueFields: Record<string, Array<SubschemaConfig>>;\n  typeMaps: Map<SubschemaConfig, TypeMap>;\n  selectionSets: Map<SubschemaConfig, SelectionSetNode>;\n  containsSelectionSet: Map<SubschemaConfig, Map<SelectionSetNode, boolean>>;\n}\n\nexport type IFieldResolver<TSource, TContext, TArgs = Record<string, any>> = (\n  source: TSource,\n  args: TArgs,\n  context: TContext,\n  info: IGraphQLToolsResolveInfo,\n) => any;\n\nexport type ITypedef = (() => Array<ITypedef>) | string | DocumentNode;\n\nexport type ITypeDefinitions = ITypedef | Array<ITypedef>;\n\nexport interface IResolverObject<TSource = any, TContext = any, TArgs = any> {\n  [key: string]:\n    | IFieldResolver<TSource, TContext, TArgs>\n    | IResolverOptions<TSource, TContext>\n    | IResolverObject<TSource, TContext>;\n}\n\nexport interface IEnumResolver {\n  [key: string]: string | number;\n}\n\nexport interface IResolvers<TSource = any, TContext = any> {\n  [key: string]:\n    | (() => any)\n    | IResolverObject<TSource, TContext>\n    | IResolverOptions<TSource, TContext>\n    | GraphQLScalarType\n    | IEnumResolver;\n}\n\nexport type IResolversParameter =\n  | Array<IResolvers | ((mergeInfo: MergeInfo) => IResolvers)>\n  | IResolvers\n  | ((mergeInfo: MergeInfo) => IResolvers);\n\nexport interface ILogger {\n  log: (error: Error) => void;\n}\n\nexport type IConnectorCls<TContext = any> = new (context?: TContext) => any;\n\nexport type IConnectorFn<TContext = any> = (context?: TContext) => any;\n\nexport type IConnector<TContext = any> =\n  | IConnectorCls<TContext>\n  | IConnectorFn<TContext>;\n\nexport interface IConnectors<TContext = any> {\n  [key: string]: IConnector<TContext>;\n}\n\nexport interface IExecutableSchemaDefinition<TContext = any> {\n  typeDefs: ITypeDefinitions;\n  resolvers?: IResolvers<any, TContext> | Array<IResolvers<any, TContext>>;\n  connectors?: IConnectors<TContext>;\n  logger?: ILogger;\n  allowUndefinedInResolve?: boolean;\n  resolverValidationOptions?: IResolverValidationOptions;\n  directiveResolvers?: IDirectiveResolvers<any, TContext>;\n  schemaDirectives?: { [name: string]: typeof SchemaDirectiveVisitor };\n  parseOptions?: GraphQLParseOptions;\n  inheritResolversFromInterfaces?: boolean;\n}\n\nexport type IFieldIteratorFn = (\n  fieldDef: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) => void;\n\nexport type IDefaultValueIteratorFn = (\n  type: GraphQLInputType,\n  value: any,\n) => void;\n\nexport type NextResolverFn = () => Promise<any>;\n\nexport type DirectiveResolverFn<TSource = any, TContext = any> = (\n  next: NextResolverFn,\n  source: TSource,\n  args: { [argName: string]: any },\n  context: TContext,\n  info: GraphQLResolveInfo,\n) => any;\n\nexport interface IDirectiveResolvers<TSource = any, TContext = any> {\n  [directiveName: string]: DirectiveResolverFn<TSource, TContext>;\n}\n\n/* XXX on mocks, args are optional, Not sure if a bug. */\nexport type IMockFn = GraphQLFieldResolver<any, any>;\n\nexport interface IMocks {\n  [key: string]: IMockFn;\n}\n\nexport type IMockTypeFn = (\n  type: GraphQLType,\n  typeName?: string,\n  fieldName?: string,\n) => GraphQLFieldResolver<any, any>;\n\nexport interface IMockOptions {\n  schema?: GraphQLSchema;\n  mocks?: IMocks;\n  preserveResolvers?: boolean;\n}\n\nexport interface IMockServer {\n  query: (\n    query: string,\n    vars?: { [key: string]: any },\n  ) => Promise<ExecutionResult>;\n}\n\nexport type OnTypeConflict = (\n  left: GraphQLNamedType,\n  right: GraphQLNamedType,\n  info?: {\n    left: {\n      schema?: GraphQLSchema | SubschemaConfig;\n    };\n    right: {\n      schema?: GraphQLSchema | SubschemaConfig;\n    };\n  },\n) => GraphQLNamedType;\n\nexport type Operation = 'query' | 'mutation' | 'subscription';\n\nexport interface Request {\n  document: DocumentNode;\n  variables: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport type IndexedObject<V> = { [key: string]: V } | ReadonlyArray<V>;\n\nexport type VisitableSchemaType =\n  | GraphQLSchema\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLInputObjectType\n  | GraphQLNamedType\n  | GraphQLScalarType\n  | GraphQLField<any, any>\n  | GraphQLInputField\n  | GraphQLArgument\n  | GraphQLUnionType\n  | GraphQLEnumType\n  | GraphQLEnumValue;\n\nexport type VisitorSelector = (\n  type: VisitableSchemaType,\n  methodName: string,\n) => Array<SchemaVisitor | SchemaVisitorMap>;\n\nexport enum VisitSchemaKind {\n  TYPE = 'VisitSchemaKind.TYPE',\n  SCALAR_TYPE = 'VisitSchemaKind.SCALAR_TYPE',\n  ENUM_TYPE = 'VisitSchemaKind.ENUM_TYPE',\n  COMPOSITE_TYPE = 'VisitSchemaKind.COMPOSITE_TYPE',\n  OBJECT_TYPE = 'VisitSchemaKind.OBJECT_TYPE',\n  INPUT_OBJECT_TYPE = 'VisitSchemaKind.INPUT_OBJECT_TYPE',\n  ABSTRACT_TYPE = 'VisitSchemaKind.ABSTRACT_TYPE',\n  UNION_TYPE = 'VisitSchemaKind.UNION_TYPE',\n  INTERFACE_TYPE = 'VisitSchemaKind.INTERFACE_TYPE',\n  ROOT_OBJECT = 'VisitSchemaKind.ROOT_OBJECT',\n  QUERY = 'VisitSchemaKind.QUERY',\n  MUTATION = 'VisitSchemaKind.MUTATION',\n  SUBSCRIPTION = 'VisitSchemaKind.SUBSCRIPTION',\n}\n\nexport interface SchemaVisitorMap {\n  [VisitSchemaKind.TYPE]?: NamedTypeVisitor;\n  [VisitSchemaKind.SCALAR_TYPE]?: ScalarTypeVisitor;\n  [VisitSchemaKind.ENUM_TYPE]?: EnumTypeVisitor;\n  [VisitSchemaKind.COMPOSITE_TYPE]?: CompositeTypeVisitor;\n  [VisitSchemaKind.OBJECT_TYPE]?: ObjectTypeVisitor;\n  [VisitSchemaKind.INPUT_OBJECT_TYPE]?: InputObjectTypeVisitor;\n  [VisitSchemaKind.ABSTRACT_TYPE]?: AbstractTypeVisitor;\n  [VisitSchemaKind.UNION_TYPE]?: UnionTypeVisitor;\n  [VisitSchemaKind.INTERFACE_TYPE]?: InterfaceTypeVisitor;\n  [VisitSchemaKind.ROOT_OBJECT]?: ObjectTypeVisitor;\n  [VisitSchemaKind.QUERY]?: ObjectTypeVisitor;\n  [VisitSchemaKind.MUTATION]?: ObjectTypeVisitor;\n  [VisitSchemaKind.SUBSCRIPTION]?: ObjectTypeVisitor;\n}\n\nexport type NamedTypeVisitor = (\n  type: GraphQLNamedType,\n  schema: GraphQLSchema,\n) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeVisitor = (\n  type: GraphQLScalarType,\n  schema: GraphQLSchema,\n) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeVisitor = (\n  type: GraphQLEnumType,\n  schema: GraphQLSchema,\n) => GraphQLEnumType | null | undefined;\n\nexport type CompositeTypeVisitor = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) =>\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | null\n  | undefined;\n\nexport type ObjectTypeVisitor = (\n  type: GraphQLObjectType,\n  schema: GraphQLSchema,\n) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeVisitor = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema,\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeVisitor = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeVisitor = (\n  type: GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeVisitor = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | null | undefined;\n\nexport enum MapperKind {\n  TYPE = 'MapperKind.TYPE',\n  SCALAR_TYPE = 'MapperKind.SCALAR_TYPE',\n  ENUM_TYPE = 'MapperKind.ENUM_TYPE',\n  COMPOSITE_TYPE = 'MapperKind.COMPOSITE_TYPE',\n  OBJECT_TYPE = 'MapperKind.OBJECT_TYPE',\n  INPUT_OBJECT_TYPE = 'MapperKind.INPUT_OBJECT_TYPE',\n  ABSTRACT_TYPE = 'MapperKind.ABSTRACT_TYPE',\n  UNION_TYPE = 'MapperKind.UNION_TYPE',\n  INTERFACE_TYPE = 'MapperKind.INTERFACE_TYPE',\n  ROOT_OBJECT = 'MapperKind.ROOT_OBJECT',\n  QUERY = 'MapperKind.QUERY',\n  MUTATION = 'MapperKind.MUTATION',\n  SUBSCRIPTION = 'MapperKind.SUBSCRIPTION',\n  DIRECTIVE = 'MapperKind.DIRECTIVE',\n}\n\nexport interface SchemaMapper {\n  [MapperKind.TYPE]?: NamedTypeMapper;\n  [MapperKind.SCALAR_TYPE]?: ScalarTypeMapper;\n  [MapperKind.ENUM_TYPE]?: EnumTypeMapper;\n  [MapperKind.COMPOSITE_TYPE]?: CompositeTypeMapper;\n  [MapperKind.OBJECT_TYPE]?: ObjectTypeMapper;\n  [MapperKind.INPUT_OBJECT_TYPE]?: InputObjectTypeMapper;\n  [MapperKind.ABSTRACT_TYPE]?: AbstractTypeMapper;\n  [MapperKind.UNION_TYPE]?: UnionTypeMapper;\n  [MapperKind.INTERFACE_TYPE]?: InterfaceTypeMapper;\n  [MapperKind.ROOT_OBJECT]?: ObjectTypeMapper;\n  [MapperKind.QUERY]?: ObjectTypeMapper;\n  [MapperKind.MUTATION]?: ObjectTypeMapper;\n  [MapperKind.SUBSCRIPTION]?: ObjectTypeMapper;\n  [MapperKind.DIRECTIVE]?: DirectiveMapper;\n}\n\nexport type NamedTypeMapper = (\n  type: GraphQLNamedType,\n  schema: GraphQLSchema,\n) => GraphQLNamedType | null | undefined;\n\nexport type ScalarTypeMapper = (\n  type: GraphQLScalarType,\n  schema: GraphQLSchema,\n) => GraphQLScalarType | null | undefined;\n\nexport type EnumTypeMapper = (\n  type: GraphQLEnumType,\n  schema: GraphQLSchema,\n) => GraphQLEnumType | null | undefined;\n\nexport type CompositeTypeMapper = (\n  type: GraphQLObjectType | GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) =>\n  | GraphQLObjectType\n  | GraphQLInterfaceType\n  | GraphQLUnionType\n  | null\n  | undefined;\n\nexport type ObjectTypeMapper = (\n  type: GraphQLObjectType,\n  schema: GraphQLSchema,\n) => GraphQLObjectType | null | undefined;\n\nexport type InputObjectTypeMapper = (\n  type: GraphQLInputObjectType,\n  schema: GraphQLSchema,\n) => GraphQLInputObjectType | null | undefined;\n\nexport type AbstractTypeMapper = (\n  type: GraphQLInterfaceType | GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | GraphQLUnionType | null | undefined;\n\nexport type UnionTypeMapper = (\n  type: GraphQLUnionType,\n  schema: GraphQLSchema,\n) => GraphQLUnionType | null | undefined;\n\nexport type InterfaceTypeMapper = (\n  type: GraphQLInterfaceType,\n  schema: GraphQLSchema,\n) => GraphQLInterfaceType | null | undefined;\n\nexport type DirectiveMapper = (\n  directive: GraphQLDirective,\n  schema: GraphQLSchema,\n) => GraphQLDirective | null | undefined;\n\nexport type CreateProxyingResolverFn = (\n  schema: GraphQLSchema | SubschemaConfig,\n  transforms: Array<Transform>,\n  operation: Operation,\n  fieldName: string,\n) => GraphQLFieldResolver<any, any>;\n","import {\n  GraphQLType,\n  GraphQLSchema,\n  doTypesOverlap,\n  isCompositeType,\n} from 'graphql';\n\nexport default function implementsAbstractType(\n  schema: GraphQLSchema,\n  typeA: GraphQLType,\n  typeB: GraphQLType,\n) {\n  if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n","import {\n  DocumentNode,\n  FragmentDefinitionNode,\n  GraphQLNamedType,\n  GraphQLSchema,\n  Kind,\n  OperationDefinitionNode,\n  SelectionNode,\n  SelectionSetNode,\n  TypeInfo,\n  getNamedType,\n  isAbstractType,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport implementsAbstractType from '../../utils/implementsAbstractType';\nimport { Transform, Request } from '../../Interfaces';\n\nexport default class ExpandAbstractTypes implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: Record<string, Array<string>>;\n  private readonly reverseMapping: Record<string, Array<string>>;\n\n  constructor(sourceSchema: GraphQLSchema, targetSchema: GraphQLSchema) {\n    this.targetSchema = targetSchema;\n    this.mapping = extractPossibleTypes(sourceSchema, targetSchema);\n    this.reverseMapping = flipMapping(this.mapping);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = expandAbstractTypes(\n      this.targetSchema,\n      this.mapping,\n      this.reverseMapping,\n      originalRequest.document,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction extractPossibleTypes(\n  sourceSchema: GraphQLSchema,\n  targetSchema: GraphQLSchema,\n) {\n  const typeMap = sourceSchema.getTypeMap();\n  const mapping: Record<string, Array<string>> = Object.create(null);\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n    if (isAbstractType(type)) {\n      const targetType = targetSchema.getType(typeName);\n      if (!isAbstractType(targetType)) {\n        const implementations = sourceSchema.getPossibleTypes(type);\n        mapping[typeName] = implementations\n          .filter((impl) => targetSchema.getType(impl.name))\n          .map((impl) => impl.name);\n      }\n    }\n  });\n  return mapping;\n}\n\nfunction flipMapping(\n  mapping: Record<string, Array<string>>,\n): Record<string, Array<string>> {\n  const result: Record<string, Array<string>> = Object.create(null);\n  Object.keys(mapping).forEach((typeName) => {\n    const toTypeNames = mapping[typeName];\n    toTypeNames.forEach((toTypeName) => {\n      if (!(toTypeName in result)) {\n        result[toTypeName] = [];\n      }\n      result[toTypeName].push(typeName);\n    });\n  });\n  return result;\n}\n\nfunction expandAbstractTypes(\n  targetSchema: GraphQLSchema,\n  mapping: Record<string, Array<string>>,\n  reverseMapping: Record<string, Array<string>>,\n  document: DocumentNode,\n): DocumentNode {\n  const operations: Array<OperationDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.OPERATION_DEFINITION,\n  ) as Array<OperationDefinitionNode>;\n  const fragments: Array<FragmentDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.FRAGMENT_DEFINITION,\n  ) as Array<FragmentDefinitionNode>;\n\n  const existingFragmentNames = fragments.map(\n    (fragment) => fragment.name.value,\n  );\n  let fragmentCounter = 0;\n  const generateFragmentName = (typeName: string) => {\n    let fragmentName;\n    do {\n      fragmentName = `_${typeName}_Fragment${fragmentCounter.toString()}`;\n      fragmentCounter++;\n    } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n    return fragmentName;\n  };\n\n  const newFragments: Array<FragmentDefinitionNode> = [];\n  const fragmentReplacements: Record<\n    string,\n    Array<{ fragmentName: string; typeName: string }>\n  > = Object.create(null);\n\n  fragments.forEach((fragment: FragmentDefinitionNode) => {\n    newFragments.push(fragment);\n    const possibleTypes = mapping[fragment.typeCondition.name.value];\n    if (possibleTypes != null) {\n      fragmentReplacements[fragment.name.value] = [];\n      possibleTypes.forEach((possibleTypeName) => {\n        const name = generateFragmentName(possibleTypeName);\n        existingFragmentNames.push(name);\n        const newFragment: FragmentDefinitionNode = {\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name,\n          },\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: possibleTypeName,\n            },\n          },\n          selectionSet: fragment.selectionSet,\n        };\n        newFragments.push(newFragment);\n\n        fragmentReplacements[fragment.name.value].push({\n          fragmentName: name,\n          typeName: possibleTypeName,\n        });\n      });\n    }\n  });\n\n  const newDocument = {\n    ...document,\n    definitions: [...operations, ...newFragments],\n  };\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    newDocument,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](node: SelectionSetNode) {\n        const newSelections = [...node.selections];\n        const maybeType = typeInfo.getParentType();\n        if (maybeType != null) {\n          const parentType: GraphQLNamedType = getNamedType(maybeType);\n          node.selections.forEach((selection: SelectionNode) => {\n            if (selection.kind === Kind.INLINE_FRAGMENT) {\n              if (selection.typeCondition != null) {\n                const possibleTypes =\n                  mapping[selection.typeCondition.name.value];\n                if (possibleTypes != null) {\n                  possibleTypes.forEach((possibleType) => {\n                    const maybePossibleType = targetSchema.getType(\n                      possibleType,\n                    );\n                    if (\n                      maybePossibleType != null &&\n                      implementsAbstractType(\n                        targetSchema,\n                        parentType,\n                        maybePossibleType,\n                      )\n                    ) {\n                      newSelections.push({\n                        kind: Kind.INLINE_FRAGMENT,\n                        typeCondition: {\n                          kind: Kind.NAMED_TYPE,\n                          name: {\n                            kind: Kind.NAME,\n                            value: possibleType,\n                          },\n                        },\n                        selectionSet: selection.selectionSet,\n                      });\n                    }\n                  });\n                }\n              }\n            } else if (selection.kind === Kind.FRAGMENT_SPREAD) {\n              const fragmentName = selection.name.value;\n              if (fragmentName in fragmentReplacements) {\n                fragmentReplacements[fragmentName].forEach((replacement) => {\n                  const typeName = replacement.typeName;\n                  const maybeReplacementType = targetSchema.getType(typeName);\n                  if (\n                    maybeReplacementType != null &&\n                    implementsAbstractType(targetSchema, parentType, maybeType)\n                  ) {\n                    newSelections.push({\n                      kind: Kind.FRAGMENT_SPREAD,\n                      name: {\n                        kind: Kind.NAME,\n                        value: replacement.fragmentName,\n                      },\n                    });\n                  }\n                });\n              }\n            }\n          });\n\n          if (parentType.name in reverseMapping) {\n            newSelections.push({\n              kind: Kind.FIELD,\n              name: {\n                kind: Kind.NAME,\n                value: '__typename',\n              },\n            });\n          }\n        }\n\n        if (newSelections.length !== node.selections.length) {\n          return {\n            ...node,\n            selections: newSelections,\n          };\n        }\n      },\n    }),\n  );\n}\n","/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * and a function to produce the values from each item in the array.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: '555-1234', Jenny: '867-5309' }\n *     const phonesByName = keyValMap(\n *       phoneBook,\n *       entry => entry.name,\n *       entry => entry.num\n *     )\n *\n */\nexport default function keyValMap<T extends any, V extends any>(\n  list: ReadonlyArray<T>,\n  keyFn: (item: T) => string,\n  valFn: (item: T) => V,\n): Record<string, V> {\n  return list.reduce((map, item) => {\n    map[keyFn(item)] = valFn(item);\n    return map;\n  }, Object.create(null));\n}\n","import {\n  ArgumentNode,\n  DocumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  FragmentSpreadNode,\n  GraphQLSchema,\n  GraphQLType,\n  InlineFragmentNode,\n  Kind,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  TypeNameMetaFieldDef,\n  VariableDefinitionNode,\n  VariableNode,\n  visit,\n  TypeInfo,\n  visitWithTypeInfo,\n  getNamedType,\n  isObjectType,\n  isInterfaceType,\n} from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport implementsAbstractType from '../../utils/implementsAbstractType';\nimport keyValMap from '../../esUtils/keyValMap';\n\nexport default class FilterToSchema implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n\n  constructor(targetSchema: GraphQLSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return {\n      ...originalRequest,\n      ...filterToSchema(\n        this.targetSchema,\n        originalRequest.document,\n        originalRequest.variables,\n      ),\n    };\n  }\n}\n\nfunction filterToSchema(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  variables: Record<string, any>,\n): { document: DocumentNode; variables: Record<string, any> } {\n  const operations: Array<OperationDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.OPERATION_DEFINITION,\n  ) as Array<OperationDefinitionNode>;\n  const fragments: Array<FragmentDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.FRAGMENT_DEFINITION,\n  ) as Array<FragmentDefinitionNode>;\n\n  let usedVariables: Array<string> = [];\n  let usedFragments: Array<string> = [];\n  const newOperations: Array<OperationDefinitionNode> = [];\n  let newFragments: Array<FragmentDefinitionNode> = [];\n\n  const validFragments: Array<FragmentDefinitionNode> = fragments.filter(\n    (fragment: FragmentDefinitionNode) => {\n      const typeName = fragment.typeCondition.name.value;\n      return Boolean(targetSchema.getType(typeName));\n    },\n  );\n\n  const validFragmentsWithType = keyValMap(\n    validFragments,\n    (fragment) => fragment.name.value,\n    (fragment) => targetSchema.getType(fragment.typeCondition.name.value),\n  );\n\n  let fragmentSet = Object.create(null);\n\n  operations.forEach((operation: OperationDefinitionNode) => {\n    let type;\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n\n    const {\n      selectionSet,\n      usedFragments: operationUsedFragments,\n      usedVariables: operationUsedVariables,\n    } = filterSelectionSet(\n      targetSchema,\n      type,\n      validFragmentsWithType,\n      operation.selectionSet,\n    );\n\n    usedFragments = union(usedFragments, operationUsedFragments);\n\n    const {\n      usedVariables: collectedUsedVariables,\n      newFragments: collectedNewFragments,\n      fragmentSet: collectedFragmentSet,\n    } = collectFragmentVariables(\n      targetSchema,\n      fragmentSet,\n      validFragments,\n      validFragmentsWithType,\n      usedFragments,\n    );\n    const operationOrFragmentVariables = union(\n      operationUsedVariables,\n      collectedUsedVariables,\n    );\n    usedVariables = union(usedVariables, operationOrFragmentVariables);\n    newFragments = collectedNewFragments;\n    fragmentSet = collectedFragmentSet;\n\n    const variableDefinitions = operation.variableDefinitions.filter(\n      (variable: VariableDefinitionNode) =>\n        operationOrFragmentVariables.indexOf(variable.variable.name.value) !==\n        -1,\n    );\n\n    newOperations.push({\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation.operation,\n      name: operation.name,\n      directives: operation.directives,\n      variableDefinitions,\n      selectionSet,\n    });\n  });\n\n  const newVariables = usedVariables.reduce((acc, variableName) => {\n    acc[variableName] = variables[variableName];\n    return acc;\n  }, {});\n\n  return {\n    document: {\n      kind: Kind.DOCUMENT,\n      definitions: [...newOperations, ...newFragments],\n    },\n    variables: newVariables,\n  };\n}\n\nfunction collectFragmentVariables(\n  targetSchema: GraphQLSchema,\n  fragmentSet: object,\n  validFragments: Array<FragmentDefinitionNode>,\n  validFragmentsWithType: { [name: string]: GraphQLType },\n  usedFragments: Array<string>,\n) {\n  let remainingFragments = usedFragments.slice();\n\n  let usedVariables: Array<string> = [];\n  const newFragments: Array<FragmentDefinitionNode> = [];\n\n  while (remainingFragments.length !== 0) {\n    const nextFragmentName = remainingFragments.pop();\n    const fragment = validFragments.find(\n      (fr) => fr.name.value === nextFragmentName,\n    );\n    if (fragment != null) {\n      const name = nextFragmentName;\n      const typeName = fragment.typeCondition.name.value;\n      const type = targetSchema.getType(typeName);\n      const {\n        selectionSet,\n        usedFragments: fragmentUsedFragments,\n        usedVariables: fragmentUsedVariables,\n      } = filterSelectionSet(\n        targetSchema,\n        type,\n        validFragmentsWithType,\n        fragment.selectionSet,\n      );\n      remainingFragments = union(remainingFragments, fragmentUsedFragments);\n      usedVariables = union(usedVariables, fragmentUsedVariables);\n\n      if (!(name in fragmentSet)) {\n        fragmentSet[name] = true;\n        newFragments.push({\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name,\n          },\n          typeCondition: fragment.typeCondition,\n          selectionSet,\n        });\n      }\n    }\n  }\n\n  return {\n    usedVariables,\n    newFragments,\n    fragmentSet,\n  };\n}\n\nfunction filterSelectionSet(\n  schema: GraphQLSchema,\n  type: GraphQLType,\n  validFragments: { [name: string]: GraphQLType },\n  selectionSet: SelectionSetNode,\n) {\n  const usedFragments: Array<string> = [];\n  const usedVariables: Array<string> = [];\n\n  const typeInfo = new TypeInfo(schema, undefined, type);\n  const filteredSelectionSet = visit(\n    selectionSet,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.FIELD]: {\n        enter(node: FieldNode): null | undefined | FieldNode {\n          const parentType = typeInfo.getParentType();\n          if (isObjectType(parentType) || isInterfaceType(parentType)) {\n            const fields = parentType.getFields();\n            const field =\n              node.name.value === '__typename'\n                ? TypeNameMetaFieldDef\n                : fields[node.name.value];\n            if (!field) {\n              return null;\n            }\n\n            const argNames = (field.args != null ? field.args : []).map(\n              (arg) => arg.name,\n            );\n            if (node.arguments != null) {\n              const args = node.arguments.filter(\n                (arg: ArgumentNode) => argNames.indexOf(arg.name.value) !== -1,\n              );\n              if (args.length !== node.arguments.length) {\n                return {\n                  ...node,\n                  arguments: args,\n                };\n              }\n            }\n          }\n        },\n        leave(node: FieldNode): null | undefined | FieldNode {\n          const resolvedType = getNamedType(typeInfo.getType());\n          if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\n            const selections =\n              node.selectionSet != null ? node.selectionSet.selections : null;\n            if (selections == null || selections.length === 0) {\n              // need to remove any added variables. Is there a better way to do this?\n              visit(node, {\n                [Kind.VARIABLE](variableNode: VariableNode) {\n                  const index = usedVariables.indexOf(variableNode.name.value);\n                  if (index !== -1) {\n                    usedVariables.splice(index, 1);\n                  }\n                },\n              });\n              return null;\n            }\n          }\n        },\n      },\n      [Kind.FRAGMENT_SPREAD](node: FragmentSpreadNode): null | undefined {\n        if (node.name.value in validFragments) {\n          const parentType = typeInfo.getParentType();\n          const innerType = validFragments[node.name.value];\n          if (!implementsAbstractType(schema, parentType, innerType)) {\n            return null;\n          }\n\n          usedFragments.push(node.name.value);\n          return;\n        }\n\n        return null;\n      },\n      [Kind.INLINE_FRAGMENT]: {\n        enter(node: InlineFragmentNode): null | undefined {\n          if (node.typeCondition != null) {\n            const parentType = typeInfo.getParentType();\n            const innerType = schema.getType(node.typeCondition.name.value);\n            if (!implementsAbstractType(schema, parentType, innerType)) {\n              return null;\n            }\n          }\n        },\n      },\n      [Kind.VARIABLE](node: VariableNode) {\n        usedVariables.push(node.name.value);\n      },\n    }),\n  );\n\n  return {\n    selectionSet: filteredSelectionSet,\n    usedFragments,\n    usedVariables,\n  };\n}\n\nfunction union(...arrays: Array<Array<string>>): Array<string> {\n  const cache: Record<string, boolean> = Object.create(null);\n  const result: Array<string> = [];\n  arrays.forEach((array) => {\n    array.forEach((item) => {\n      if (!(item in cache)) {\n        cache[item] = true;\n        result.push(item);\n      }\n    });\n  });\n  return result;\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  ReplacementSelectionSetMapping,\n} from '../../Interfaces';\n\nexport default class AddReplacementSelectionSets implements Transform {\n  private readonly schema: GraphQLSchema;\n  private readonly mapping: ReplacementSelectionSetMapping;\n\n  constructor(schema: GraphQLSchema, mapping: ReplacementSelectionSetMapping) {\n    this.schema = schema;\n    this.mapping = mapping;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = replaceFieldsWithSelectionSet(\n      this.schema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction replaceFieldsWithSelectionSet(\n  schema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: ReplacementSelectionSetMapping,\n): DocumentNode {\n  const typeInfo = new TypeInfo(schema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType:\n          | GraphQLType\n          | null\n          | undefined = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (parentTypeName in mapping) {\n            node.selections.forEach((selection) => {\n              if (selection.kind === Kind.FIELD) {\n                const name = selection.name.value;\n                const selectionSet = mapping[parentTypeName][name];\n                if (selectionSet != null) {\n                  selections = selections.concat(selectionSet.selections);\n                }\n              }\n            });\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  ReplacementFragmentMapping,\n} from '../../Interfaces';\n\nexport default class AddReplacementFragments implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: ReplacementFragmentMapping;\n\n  constructor(\n    targetSchema: GraphQLSchema,\n    mapping: ReplacementFragmentMapping,\n  ) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = replaceFieldsWithFragments(\n      this.targetSchema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction replaceFieldsWithFragments(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: ReplacementFragmentMapping,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType:\n          | GraphQLType\n          | null\n          | undefined = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (parentTypeName in mapping) {\n            node.selections.forEach((selection) => {\n              if (selection.kind === Kind.FIELD) {\n                const name = selection.name.value;\n                const fragment = mapping[parentTypeName][name];\n                if (fragment != null) {\n                  selections = selections.concat(fragment);\n                }\n              }\n            });\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport { Transform, Request, MergedTypeInfo } from '../../Interfaces';\n\nexport default class AddMergedTypeFragments implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: Record<string, MergedTypeInfo>;\n\n  constructor(\n    targetSchema: GraphQLSchema,\n    mapping: Record<string, MergedTypeInfo>,\n  ) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = addMergedTypeSelectionSets(\n      this.targetSchema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\nfunction addMergedTypeSelectionSets(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: Record<string, MergedTypeInfo>,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType:\n          | GraphQLType\n          | null\n          | undefined = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (parentTypeName in mapping) {\n            const selectionSet = mapping[parentTypeName].selectionSet;\n            if (selectionSet != null) {\n              selections = selections.concat(selectionSet.selections);\n            }\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n","import {\n  GraphQLType,\n  DocumentNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n  SelectionSetNode,\n  Kind,\n  GraphQLSchema,\n  isAbstractType,\n} from 'graphql';\n\nexport function addTypenameToAbstract(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType: GraphQLType = typeInfo.getParentType();\n        let selections = node.selections;\n        if (parentType != null && isAbstractType(parentType)) {\n          selections = selections.concat({\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename',\n            },\n          });\n        }\n\n        if (selections !== node.selections) {\n          return {\n            ...node,\n            selections,\n          };\n        }\n      },\n    }),\n  );\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport { addTypenameToAbstract } from '../../delegate/addTypenameToAbstract';\n\nexport default class AddTypenameToAbstract implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n\n  constructor(targetSchema: GraphQLSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = addTypenameToAbstract(\n      this.targetSchema,\n      originalRequest.document,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n","import { GraphQLResolveInfo } from 'graphql';\n\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nexport function getResponseKeyFromInfo(info: GraphQLResolveInfo) {\n  return info.fieldNodes[0].alias != null\n    ? info.fieldNodes[0].alias.value\n    : info.fieldName;\n}\n","const hasSymbol =\n  (typeof global !== 'undefined' && 'Symbol' in global) ||\n  // eslint-disable-next-line no-undef\n  (typeof window !== 'undefined' && 'Symbol' in window);\n\nexport const OBJECT_SUBSCHEMA_SYMBOL = hasSymbol\n  ? Symbol('initialSubschema')\n  : '@@__initialSubschema';\nexport const FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol\n  ? Symbol('subschemaMap')\n  : '@@__subschemaMap';\nexport const ERROR_SYMBOL = hasSymbol\n  ? Symbol('subschemaErrors')\n  : '@@__subschemaErrors';\n","import { GraphQLError, ASTNode } from 'graphql';\n\nimport { ERROR_SYMBOL } from './symbols';\n\nexport function relocatedError(\n  originalError: Error | GraphQLError,\n  nodes: ReadonlyArray<ASTNode>,\n  path: ReadonlyArray<string | number>,\n): GraphQLError {\n  if (Array.isArray((originalError as GraphQLError).path)) {\n    return new GraphQLError(\n      (originalError as GraphQLError).message,\n      (originalError as GraphQLError).nodes,\n      (originalError as GraphQLError).source,\n      (originalError as GraphQLError).positions,\n      path != null ? path : (originalError as GraphQLError).path,\n      (originalError as GraphQLError).originalError,\n      (originalError as GraphQLError).extensions,\n    );\n  }\n\n  if (originalError == null) {\n    return new GraphQLError(\n      undefined,\n      nodes,\n      undefined,\n      undefined,\n      path,\n      originalError,\n    );\n  }\n\n  return new GraphQLError(\n    originalError.message,\n    (originalError as GraphQLError).nodes != null\n      ? (originalError as GraphQLError).nodes\n      : nodes,\n    (originalError as GraphQLError).source,\n    (originalError as GraphQLError).positions,\n    path,\n    originalError,\n  );\n}\n\nexport function slicedError(originalError: GraphQLError) {\n  return relocatedError(\n    originalError,\n    originalError.nodes,\n    originalError.path != null ? originalError.path.slice(1) : undefined,\n  );\n}\n\nexport function getErrorsByPathSegment(\n  errors: ReadonlyArray<GraphQLError>,\n): Record<string, Array<GraphQLError>> {\n  const record = Object.create(null);\n  errors.forEach((error) => {\n    if (!error.path || error.path.length < 2) {\n      return;\n    }\n\n    const pathSegment = error.path[1];\n\n    const current = pathSegment in record ? record[pathSegment] : [];\n    current.push(slicedError(error));\n    record[pathSegment] = current;\n  });\n\n  return record;\n}\n\nclass CombinedError extends Error {\n  public errors: ReadonlyArray<GraphQLError>;\n  constructor(message: string, errors: ReadonlyArray<GraphQLError>) {\n    super(message);\n    this.errors = errors;\n  }\n}\n\nexport function combineErrors(\n  errors: ReadonlyArray<GraphQLError>,\n): GraphQLError | CombinedError {\n  if (errors.length === 1) {\n    return new GraphQLError(\n      errors[0].message,\n      errors[0].nodes,\n      errors[0].source,\n      errors[0].positions,\n      errors[0].path,\n      errors[0].originalError,\n      errors[0].extensions,\n    );\n  }\n\n  return new CombinedError(\n    errors.map((error) => error.message).join('\\n'),\n    errors,\n  );\n}\n\nexport function setErrors(result: any, errors: Array<GraphQLError>) {\n  result[ERROR_SYMBOL] = errors;\n}\n\nexport function getErrors(\n  result: any,\n  pathSegment: string,\n): Array<GraphQLError> {\n  const errors = result != null ? result[ERROR_SYMBOL] : result;\n\n  if (!Array.isArray(errors)) {\n    return null;\n  }\n\n  const fieldErrors = [];\n\n  for (const error of errors) {\n    if (!error.path || error.path[0] === pathSegment) {\n      fieldErrors.push(error);\n    }\n  }\n\n  return fieldErrors;\n}\n","import { FieldNode, GraphQLError } from 'graphql';\n\nimport {\n  getErrorsByPathSegment,\n  combineErrors,\n  relocatedError,\n} from '../../stitch/errors';\n\nexport function handleNull(\n  fieldNodes: ReadonlyArray<FieldNode>,\n  path: Array<string | number>,\n  errors: ReadonlyArray<GraphQLError>,\n) {\n  if (errors.length) {\n    if (errors.some((error) => !error.path || error.path.length < 2)) {\n      return relocatedError(combineErrors(errors), fieldNodes, path);\n    } else if (errors.some((error) => typeof error.path[1] === 'string')) {\n      const childErrors = getErrorsByPathSegment(errors);\n\n      const result = {};\n      Object.keys(childErrors).forEach((pathSegment) => {\n        result[pathSegment] = handleNull(\n          fieldNodes,\n          [...path, pathSegment],\n          childErrors[pathSegment],\n        );\n      });\n\n      return result;\n    }\n\n    const childErrors = getErrorsByPathSegment(errors);\n\n    const result: Array<any> = [];\n    Object.keys(childErrors).forEach((pathSegment) => {\n      result.push(\n        handleNull(\n          fieldNodes,\n          [...path, parseInt(pathSegment, 10)],\n          childErrors[pathSegment],\n        ),\n      );\n    });\n\n    return result;\n  }\n\n  return null;\n}\n","import {\n  GraphQLObjectType,\n  SelectionSetNode,\n  FieldNode,\n  Kind,\n  FragmentSpreadNode,\n  InlineFragmentNode,\n  getDirectiveValues,\n  GraphQLSkipDirective,\n  GraphQLIncludeDirective,\n  FragmentDefinitionNode,\n  typeFromAST,\n  isAbstractType,\n} from 'graphql';\n\nimport { GraphQLExecutionContext } from '../Interfaces';\n\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n *\n * @internal\n */\nexport function collectFields(\n  exeContext: GraphQLExecutionContext,\n  runtimeType: GraphQLObjectType,\n  selectionSet: SelectionSetNode,\n  fields: Record<string, Array<FieldNode>>,\n  visitedFragmentNames: Record<string, boolean>,\n): Record<string, Array<FieldNode>> {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD: {\n        if (!shouldIncludeNode(exeContext, selection)) {\n          continue;\n        }\n        const name = getFieldEntryKey(selection);\n        if (!(name in fields)) {\n          fields[name] = [];\n        }\n        fields[name].push(selection);\n        break;\n      }\n      case Kind.INLINE_FRAGMENT: {\n        if (\n          !shouldIncludeNode(exeContext, selection) ||\n          !doesFragmentConditionMatch(exeContext, selection, runtimeType)\n        ) {\n          continue;\n        }\n        collectFields(\n          exeContext,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n      case Kind.FRAGMENT_SPREAD: {\n        const fragName = selection.name.value;\n        if (\n          visitedFragmentNames[fragName] ||\n          !shouldIncludeNode(exeContext, selection)\n        ) {\n          continue;\n        }\n        visitedFragmentNames[fragName] = true;\n        const fragment = exeContext.fragments[fragName];\n        if (\n          !fragment ||\n          !doesFragmentConditionMatch(exeContext, fragment, runtimeType)\n        ) {\n          continue;\n        }\n        collectFields(\n          exeContext,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames,\n        );\n        break;\n      }\n    }\n  }\n  return fields;\n}\n\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\nfunction shouldIncludeNode(\n  exeContext: GraphQLExecutionContext,\n  node: FragmentSpreadNode | FieldNode | InlineFragmentNode,\n): boolean {\n  const skip = getDirectiveValues(\n    GraphQLSkipDirective,\n    node,\n    exeContext.variableValues,\n  );\n\n  if (skip?.if === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues(\n    GraphQLIncludeDirective,\n    node,\n    exeContext.variableValues,\n  );\n\n  if (include?.if === false) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(\n  exeContext: GraphQLExecutionContext,\n  fragment: FragmentDefinitionNode | InlineFragmentNode,\n  type: GraphQLObjectType,\n): boolean {\n  const typeConditionNode = fragment.typeCondition;\n  if (!typeConditionNode) {\n    return true;\n  }\n  const conditionalType = typeFromAST(exeContext.schema, typeConditionNode);\n  if (conditionalType === type) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    return exeContext.schema.isPossibleType(conditionalType, type);\n  }\n  return false;\n}\n\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node: FieldNode): string {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return node.alias ? node.alias.value : node.name.value;\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { SubschemaConfig } from '../Interfaces';\n\nimport { FIELD_SUBSCHEMA_MAP_SYMBOL, OBJECT_SUBSCHEMA_SYMBOL } from './symbols';\n\nexport function getSubschema(\n  result: any,\n  responseKey: string,\n): GraphQLSchema | SubschemaConfig {\n  const subschema =\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL] &&\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\n  return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];\n}\n\nexport function setObjectSubschema(\n  result: any,\n  subschema: GraphQLSchema | SubschemaConfig,\n) {\n  result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\n}\n","export default function resolveFromParentTypename(parent: any) {\n  const parentTypename: string = parent['__typename'];\n  if (!parentTypename) {\n    throw new Error(\n      'Did not fetch typename for object, unable to resolve interface.',\n    );\n  }\n\n  return parentTypename;\n}\n","export function mergeDeep(target: any, ...sources: any): any {\n  const output = {\n    ...target,\n  };\n  sources.forEach((source: any) => {\n    if (isObject(target) && isObject(source)) {\n      Object.keys(source).forEach((key) => {\n        if (isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, { [key]: source[key] });\n          } else {\n            output[key] = mergeDeep(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, { [key]: source[key] });\n        }\n      });\n    }\n  });\n  return output;\n}\n\nfunction isObject(item: any): boolean {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n","import { GraphQLError, responsePathAsArray } from 'graphql';\n\nimport { SubschemaConfig, IGraphQLToolsResolveInfo } from '../Interfaces';\nimport { mergeDeep } from '../esUtils/mergeDeep';\nimport { handleNull } from '../delegate/results/handleNull';\n\nimport { relocatedError, setErrors, getErrors } from './errors';\nimport {\n  ERROR_SYMBOL,\n  FIELD_SUBSCHEMA_MAP_SYMBOL,\n  OBJECT_SUBSCHEMA_SYMBOL,\n} from './symbols';\nimport { getSubschema, setObjectSubschema } from './subSchema';\n\nexport function isProxiedResult(result: any) {\n  return result != null ? result[ERROR_SYMBOL] : result;\n}\n\nexport function unwrapResult(\n  parent: any,\n  info: IGraphQLToolsResolveInfo,\n  path: Array<string>,\n): any {\n  let newParent: any = parent;\n  const pathLength = path.length;\n  for (let i = 0; i < pathLength; i++) {\n    const responseKey = path[i];\n    const errors = getErrors(newParent, responseKey);\n    const subschema = getSubschema(newParent, responseKey);\n\n    const object = newParent[responseKey];\n    if (object == null) {\n      return handleNull(\n        info.fieldNodes,\n        responsePathAsArray(info.path),\n        errors,\n      );\n    }\n\n    setErrors(\n      object,\n      errors.map((error) =>\n        relocatedError(\n          error,\n          error.nodes,\n          error.path != null ? error.path.slice(1) : undefined,\n        ),\n      ),\n    );\n    setObjectSubschema(object, subschema);\n\n    newParent = object;\n  }\n\n  return newParent;\n}\n\nexport function dehoistResult(\n  parent: any,\n  delimeter: string = '__gqltf__',\n): any {\n  const result = Object.create(null);\n\n  Object.keys(parent).forEach((alias) => {\n    let obj = result;\n\n    const fieldNames = alias.split(delimeter);\n    const fieldName = fieldNames.pop();\n    fieldNames.forEach((key) => {\n      obj = obj[key] = obj[key] || Object.create(null);\n    });\n    obj[fieldName] = parent[alias];\n  });\n\n  result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map((error: GraphQLError) => {\n    if (error.path != null) {\n      const path = error.path.slice();\n      const pathSegment = path.shift();\n      const expandedPathSegment: Array<\n        string | number\n      > = (pathSegment as string).split(delimeter);\n      return relocatedError(\n        error,\n        error.nodes,\n        expandedPathSegment.concat(path),\n      );\n    }\n\n    return error;\n  });\n\n  result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\n\n  return result;\n}\n\nexport function mergeProxiedResults(target: any, ...sources: any): any {\n  const errors = target[ERROR_SYMBOL].concat(\n    sources.map((source: any) => source[ERROR_SYMBOL]),\n  );\n  const fieldSubschemaMap = sources.reduce(\n    (acc: Record<any, SubschemaConfig>, source: any) => {\n      const subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\n      Object.keys(source).forEach((key) => {\n        acc[key] = subschema;\n      });\n      return acc;\n    },\n    {},\n  );\n  const result = mergeDeep(target, ...sources);\n  result[ERROR_SYMBOL] = errors;\n  result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]\n    ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)\n    : fieldSubschemaMap;\n  return result;\n}\n","import { FieldNode, SelectionNode, Kind } from 'graphql';\n\nimport {\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  MergedTypeInfo,\n} from '../Interfaces';\n\nimport { mergeProxiedResults } from './proxiedResult';\n\nfunction buildDelegationPlan(\n  mergedTypeInfo: MergedTypeInfo,\n  originalSelections: Array<FieldNode>,\n  sourceSubschemas: Array<SubschemaConfig>,\n  targetSubschemas: Array<SubschemaConfig>,\n): {\n  delegationMap: Map<SubschemaConfig, Array<SelectionNode>>;\n  unproxiableSelections: Array<FieldNode>;\n  proxiableSubschemas: Array<SubschemaConfig>;\n  nonProxiableSubschemas: Array<SubschemaConfig>;\n} {\n  // 1.  calculate if possible to delegate to given subschema\n  //    TODO: change logic so that required selection set can be spread across multiple subschemas?\n\n  const proxiableSubschemas: Array<SubschemaConfig> = [];\n  const nonProxiableSubschemas: Array<SubschemaConfig> = [];\n\n  targetSubschemas.forEach((t) => {\n    if (\n      sourceSubschemas.some((s) => {\n        const selectionSet = mergedTypeInfo.selectionSets.get(t);\n        return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);\n      })\n    ) {\n      proxiableSubschemas.push(t);\n    } else {\n      nonProxiableSubschemas.push(t);\n    }\n  });\n\n  const { uniqueFields, nonUniqueFields } = mergedTypeInfo;\n  const unproxiableSelections: Array<FieldNode> = [];\n\n  // 2. for each selection:\n\n  const delegationMap: Map<SubschemaConfig, Array<SelectionNode>> = new Map();\n  originalSelections.forEach((selection) => {\n    // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\n\n    const uniqueSubschema: SubschemaConfig = uniqueFields[selection.name.value];\n    if (uniqueSubschema != null) {\n      if (proxiableSubschemas.includes(uniqueSubschema)) {\n        const existingSubschema = delegationMap.get(uniqueSubschema);\n        if (existingSubschema != null) {\n          existingSubschema.push(selection);\n        } else {\n          delegationMap.set(uniqueSubschema, [selection]);\n        }\n      } else {\n        unproxiableSelections.push(selection);\n      }\n    } else {\n      // 2b. use nonUniqueFields to assign to a possible subschema,\n      //     preferring one of the subschemas already targets of delegation\n\n      let nonUniqueSubschemas: Array<SubschemaConfig> =\n        nonUniqueFields[selection.name.value];\n      nonUniqueSubschemas = nonUniqueSubschemas.filter((s) =>\n        proxiableSubschemas.includes(s),\n      );\n      if (nonUniqueSubschemas != null) {\n        const subschemas: Array<SubschemaConfig> = Array.from(\n          delegationMap.keys(),\n        );\n        const existingSubschema = nonUniqueSubschemas.find((s) =>\n          subschemas.includes(s),\n        );\n        if (existingSubschema != null) {\n          delegationMap.get(existingSubschema).push(selection);\n        } else {\n          delegationMap.set(nonUniqueSubschemas[0], [selection]);\n        }\n      } else {\n        unproxiableSelections.push(selection);\n      }\n    }\n  });\n\n  return {\n    delegationMap,\n    unproxiableSelections,\n    proxiableSubschemas,\n    nonProxiableSubschemas,\n  };\n}\n\nexport function mergeFields(\n  mergedTypeInfo: MergedTypeInfo,\n  typeName: string,\n  object: any,\n  originalSelections: Array<FieldNode>,\n  sourceSubschemas: Array<SubschemaConfig>,\n  targetSubschemas: Array<SubschemaConfig>,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n): any {\n  if (!originalSelections.length) {\n    return object;\n  }\n\n  const {\n    delegationMap,\n    unproxiableSelections,\n    proxiableSubschemas,\n    nonProxiableSubschemas,\n  } = buildDelegationPlan(\n    mergedTypeInfo,\n    originalSelections,\n    sourceSubschemas,\n    targetSubschemas,\n  );\n\n  if (!delegationMap.size) {\n    return object;\n  }\n\n  const maybePromises: Promise<any> | any = [];\n  delegationMap.forEach(\n    (selections: Array<SelectionNode>, s: SubschemaConfig) => {\n      const maybePromise = s.merge[typeName].resolve(object, context, info, s, {\n        kind: Kind.SELECTION_SET,\n        selections,\n      });\n      maybePromises.push(maybePromise);\n    },\n  );\n\n  let containsPromises = false;\n  for (const maybePromise of maybePromises) {\n    if (maybePromise instanceof Promise) {\n      containsPromises = true;\n      break;\n    }\n  }\n\n  return containsPromises\n    ? Promise.all(maybePromises).then((results) =>\n        mergeFields(\n          mergedTypeInfo,\n          typeName,\n          mergeProxiedResults(object, ...results),\n          unproxiableSelections,\n          sourceSubschemas.concat(proxiableSubschemas),\n          nonProxiableSubschemas,\n          context,\n          info,\n        ),\n      )\n    : mergeFields(\n        mergedTypeInfo,\n        typeName,\n        mergeProxiedResults(object, ...maybePromises),\n        unproxiableSelections,\n        sourceSubschemas.concat(proxiableSubschemas),\n        nonProxiableSubschemas,\n        context,\n        info,\n      );\n}\n","import {\n  GraphQLCompositeType,\n  GraphQLError,\n  GraphQLSchema,\n  isAbstractType,\n  FieldNode,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport { collectFields } from '../../utils/collectFields';\n\nimport {\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  MergedTypeInfo,\n  isSubschemaConfig,\n  GraphQLExecutionContext,\n} from '../../Interfaces';\nimport { setErrors, relocatedError } from '../../stitch/errors';\nimport { setObjectSubschema } from '../../stitch/subSchema';\nimport resolveFromParentTypename from '../../stitch/resolveFromParentTypename';\nimport { mergeFields } from '../../stitch/mergeFields';\n\nexport function handleObject(\n  type: GraphQLCompositeType,\n  object: any,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  skipTypeMerging?: boolean,\n) {\n  setErrors(\n    object,\n    errors.map((error) =>\n      relocatedError(\n        error,\n        error.nodes,\n        error.path != null ? error.path.slice(1) : undefined,\n      ),\n    ),\n  );\n\n  setObjectSubschema(object, subschema);\n\n  if (skipTypeMerging || !info.mergeInfo) {\n    return object;\n  }\n\n  const typeName = isAbstractType(type)\n    ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name\n    : type.name;\n  const mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];\n  let targetSubschemas: Array<SubschemaConfig>;\n\n  if (mergedTypeInfo != null) {\n    targetSubschemas = mergedTypeInfo.subschemas;\n  }\n\n  if (!targetSubschemas) {\n    return object;\n  }\n\n  targetSubschemas = targetSubschemas.filter((s) => s !== subschema);\n  if (!targetSubschemas.length) {\n    return object;\n  }\n\n  const subFields = collectSubFields(info, object.__typename);\n\n  const selections = getFieldsNotInSubschema(\n    subFields,\n    subschema,\n    mergedTypeInfo,\n    object.__typename,\n  );\n\n  return mergeFields(\n    mergedTypeInfo,\n    typeName,\n    object,\n    selections,\n    [subschema as SubschemaConfig],\n    targetSubschemas,\n    context,\n    info,\n  );\n}\n\nfunction collectSubFields(info: IGraphQLToolsResolveInfo, typeName: string) {\n  let subFieldNodes: Record<string, Array<FieldNode>> = Object.create(null);\n  const visitedFragmentNames = Object.create(null);\n  info.fieldNodes.forEach((fieldNode) => {\n    subFieldNodes = collectFields(\n      ({\n        schema: info.schema,\n        variableValues: info.variableValues,\n        fragments: info.fragments,\n      } as unknown) as GraphQLExecutionContext,\n      info.schema.getType(typeName) as GraphQLObjectType,\n      fieldNode.selectionSet,\n      subFieldNodes,\n      visitedFragmentNames,\n    );\n  });\n  return subFieldNodes;\n}\n\nfunction getFieldsNotInSubschema(\n  subFieldNodes: Record<string, Array<FieldNode>>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  mergedTypeInfo: MergedTypeInfo,\n  typeName: string,\n): Array<FieldNode> {\n  const typeMap = isSubschemaConfig(subschema)\n    ? mergedTypeInfo.typeMaps.get(subschema)\n    : subschema.getTypeMap();\n  const fields = (typeMap[typeName] as GraphQLObjectType).getFields();\n\n  const fieldsNotInSchema: Array<FieldNode> = [];\n  Object.keys(subFieldNodes).forEach((responseName) => {\n    subFieldNodes[responseName].forEach((subFieldNode) => {\n      if (!(subFieldNode.name.value in fields)) {\n        fieldsNotInSchema.push(subFieldNode);\n      }\n    });\n  });\n\n  return fieldsNotInSchema;\n}\n","import {\n  GraphQLList,\n  GraphQLSchema,\n  GraphQLError,\n  getNullableType,\n  GraphQLType,\n  responsePathAsArray,\n  isLeafType,\n  isCompositeType,\n  isListType,\n} from 'graphql';\n\nimport { SubschemaConfig, IGraphQLToolsResolveInfo } from '../../Interfaces';\nimport { getErrorsByPathSegment } from '../../stitch/errors';\n\nimport { handleNull } from './handleNull';\nimport { handleObject } from './handleObject';\n\nexport function handleList(\n  type: GraphQLList<any>,\n  list: Array<any>,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  skipTypeMerging?: boolean,\n) {\n  const childErrors = getErrorsByPathSegment(errors);\n\n  return list.map((listMember, index) =>\n    handleListMember(\n      getNullableType(type.ofType),\n      listMember,\n      index,\n      index in childErrors ? childErrors[index] : [],\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    ),\n  );\n}\n\nfunction handleListMember(\n  type: GraphQLType,\n  listMember: any,\n  index: number,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  skipTypeMerging?: boolean,\n): any {\n  if (listMember == null) {\n    return handleNull(\n      info.fieldNodes,\n      [...responsePathAsArray(info.path), index],\n      errors,\n    );\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(listMember);\n  } else if (isCompositeType(type)) {\n    return handleObject(\n      type,\n      listMember,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  } else if (isListType(type)) {\n    return handleList(\n      type,\n      listMember,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  }\n}\n","import {\n  GraphQLResolveInfo,\n  responsePathAsArray,\n  getNullableType,\n  isCompositeType,\n  isLeafType,\n  isListType,\n  ExecutionResult,\n  GraphQLError,\n  GraphQLOutputType,\n  GraphQLSchema,\n} from 'graphql';\n\nimport { SubschemaConfig, IGraphQLToolsResolveInfo } from '../Interfaces';\nimport { getResponseKeyFromInfo } from '../stitch/getResponseKeyFromInfo';\n\nimport { handleNull } from './results/handleNull';\nimport { handleObject } from './results/handleObject';\nimport { handleList } from './results/handleList';\n\nexport function checkResultAndHandleErrors(\n  result: ExecutionResult,\n  context: Record<string, any>,\n  info: GraphQLResolveInfo,\n  responseKey: string = getResponseKeyFromInfo(info),\n  subschema?: GraphQLSchema | SubschemaConfig,\n  returnType: GraphQLOutputType = info.returnType,\n  skipTypeMerging?: boolean,\n): any {\n  const errors = result.errors != null ? result.errors : [];\n  const data = result.data != null ? result.data[responseKey] : undefined;\n\n  return handleResult(\n    data,\n    errors,\n    subschema,\n    context,\n    info,\n    returnType,\n    skipTypeMerging,\n  );\n}\n\nexport function handleResult(\n  result: any,\n  errors: ReadonlyArray<GraphQLError>,\n  subschema: GraphQLSchema | SubschemaConfig,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n  returnType = info.returnType,\n  skipTypeMerging?: boolean,\n): any {\n  const type = getNullableType(returnType);\n\n  if (result == null) {\n    return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(result);\n  } else if (isCompositeType(type)) {\n    return handleObject(\n      type,\n      result,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  } else if (isListType(type)) {\n    return handleList(\n      type,\n      result,\n      errors,\n      subschema,\n      context,\n      info,\n      skipTypeMerging,\n    );\n  }\n}\n","import { GraphQLSchema, GraphQLOutputType } from 'graphql';\n\nimport { checkResultAndHandleErrors } from '../../delegate/checkResultAndHandleErrors';\nimport {\n  Transform,\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n} from '../../Interfaces';\n\nexport default class CheckResultAndHandleErrors implements Transform {\n  private readonly context?: Record<string, any>;\n  private readonly info: IGraphQLToolsResolveInfo;\n  private readonly fieldName?: string;\n  private readonly subschema?: GraphQLSchema | SubschemaConfig;\n  private readonly returnType?: GraphQLOutputType;\n  private readonly typeMerge?: boolean;\n\n  constructor(\n    info: IGraphQLToolsResolveInfo,\n    fieldName?: string,\n    subschema?: GraphQLSchema | SubschemaConfig,\n    context?: Record<string, any>,\n    returnType: GraphQLOutputType = info.returnType,\n    typeMerge?: boolean,\n  ) {\n    this.context = context;\n    this.info = info;\n    this.fieldName = fieldName;\n    this.subschema = subschema;\n    this.returnType = returnType;\n    this.typeMerge = typeMerge;\n  }\n\n  public transformResult(result: any): any {\n    return checkResultAndHandleErrors(\n      result,\n      this.context != null ? this.context : {},\n      this.info,\n      this.fieldName,\n      this.subschema,\n      this.returnType,\n      this.typeMerge,\n    );\n  }\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputType,\n  GraphQLScalarType,\n  getNullableType,\n  isLeafType,\n  isListType,\n  isInputObjectType,\n} from 'graphql';\n\nimport keyValMap from '../esUtils/keyValMap';\n\ntype InputValueTransformer = (\n  type: GraphQLEnumType | GraphQLScalarType,\n  originalValue: any,\n) => any;\n\nexport function transformInputValue(\n  type: GraphQLInputType,\n  value: any,\n  transformer: InputValueTransformer,\n): any {\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return transformer(nullableType, value);\n  } else if (isListType(nullableType)) {\n    return value.map((listMember: any) =>\n      transformInputValue(nullableType.ofType, listMember, transformer),\n    );\n  } else if (isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    return keyValMap(\n      Object.keys(value),\n      (key) => key,\n      (key) => transformInputValue(fields[key].type, value[key], transformer),\n    );\n  }\n\n  // unreachable, no other possible return value\n}\n\nexport function serializeInputValue(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\n\nexport function parseInputValue(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\n\nexport function parseInputValueLiteral(type: GraphQLInputType, value: any) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n","import {\n  isNonNullType,\n  Kind,\n  GraphQLType,\n  TypeNode,\n  isListType,\n} from 'graphql';\n\nexport function astFromType(type: GraphQLType): TypeNode {\n  if (isNonNullType(type)) {\n    const innerType = astFromType(type.ofType);\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(\n        `Invalid type node ${JSON.stringify(\n          type,\n        )}. Inner type of non-null type cannot be a non-null type.`,\n      );\n    }\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType,\n    };\n  } else if (isListType(type)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type.ofType),\n    };\n  }\n\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type.name,\n    },\n  };\n}\n","import {\n  GraphQLInputType,\n  ArgumentNode,\n  VariableDefinitionNode,\n  Kind,\n} from 'graphql';\n\nimport { astFromType } from './astFromType';\n\nexport function updateArgument(\n  argName: string,\n  argType: GraphQLInputType,\n  argumentNodes: Record<string, ArgumentNode>,\n  variableDefinitionsMap: Record<string, VariableDefinitionNode>,\n  variableValues: Record<string, any>,\n  newArg: any,\n): void {\n  let varName;\n  let numGeneratedVariables = 0;\n  do {\n    varName = `_v${(numGeneratedVariables++).toString()}_${argName}`;\n  } while (varName in variableDefinitionsMap);\n\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName,\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName,\n      },\n    },\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName,\n      },\n    },\n    type: astFromType(argType),\n  };\n\n  variableValues[varName] = newArg;\n}\n","export default function toObjMap(obj: any): Record<string, any> {\n  if (Object.getPrototypeOf(obj) === null) {\n    return obj;\n  }\n\n  return Object.entries(obj).reduce((map, [key, value]) => {\n    map[key] = value;\n    return map;\n  }, Object.create(null));\n}\n","import {\n  ArgumentNode,\n  DocumentNode,\n  FragmentDefinitionNode,\n  GraphQLArgument,\n  GraphQLField,\n  GraphQLObjectType,\n  GraphQLSchema,\n  Kind,\n  OperationDefinitionNode,\n  SelectionNode,\n  VariableDefinitionNode,\n} from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport { serializeInputValue } from '../../utils/transformInputValue';\nimport { updateArgument } from '../../utils/updateArgument';\nimport toObjMap from '../../esUtils/toObjMap';\nimport keyValMap from '../../esUtils/keyValMap';\n\nexport default class AddArgumentsAsVariables implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly args: Record<string, any>;\n\n  constructor(targetSchema: GraphQLSchema, args: Record<string, any>) {\n    this.targetSchema = targetSchema;\n    this.args = toObjMap(args);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const { document, newVariables } = addVariablesToRootField(\n      this.targetSchema,\n      originalRequest,\n      this.args,\n    );\n\n    return {\n      document,\n      variables: newVariables,\n    };\n  }\n}\n\nfunction addVariablesToRootField(\n  targetSchema: GraphQLSchema,\n  originalRequest: Request,\n  args: { [key: string]: any },\n): {\n  document: DocumentNode;\n  newVariables: { [key: string]: any };\n} {\n  const document = originalRequest.document;\n  const variableValues = originalRequest.variables;\n\n  const operations: Array<OperationDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.OPERATION_DEFINITION,\n  ) as Array<OperationDefinitionNode>;\n  const fragments: Array<FragmentDefinitionNode> = document.definitions.filter(\n    (def) => def.kind === Kind.FRAGMENT_DEFINITION,\n  ) as Array<FragmentDefinitionNode>;\n\n  const newOperations = operations.map((operation: OperationDefinitionNode) => {\n    const variableDefinitionMap = keyValMap(\n      operation.variableDefinitions,\n      (def) => def.variable.name.value,\n      (def) => def,\n    );\n\n    let type: GraphQLObjectType | null | undefined;\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n    const newSelectionSet: Array<SelectionNode> = [];\n\n    operation.selectionSet.selections.forEach((selection: SelectionNode) => {\n      if (selection.kind === Kind.FIELD) {\n        const argumentNodes = selection.arguments;\n        const argumentNodeMap = keyValMap(\n          argumentNodes,\n          (argument) => argument.name.value,\n          (argument) => argument,\n        );\n\n        const targetField = type.getFields()[selection.name.value];\n\n        // excludes __typename\n        if (targetField != null) {\n          updateArguments(\n            targetField,\n            argumentNodeMap,\n            variableDefinitionMap,\n            variableValues,\n            args,\n          );\n        }\n\n        newSelectionSet.push({\n          ...selection,\n          arguments: Object.keys(argumentNodeMap).map(\n            (argName) => argumentNodeMap[argName],\n          ),\n        });\n      } else {\n        newSelectionSet.push(selection);\n      }\n    });\n\n    return {\n      ...operation,\n      variableDefinitions: Object.keys(variableDefinitionMap).map(\n        (varName) => variableDefinitionMap[varName],\n      ),\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: newSelectionSet,\n      },\n    };\n  });\n\n  return {\n    document: {\n      ...document,\n      definitions: [...newOperations, ...fragments],\n    },\n    newVariables: variableValues,\n  };\n}\n\nfunction updateArguments(\n  targetField: GraphQLField<any, any>,\n  argumentNodeMap: Record<string, ArgumentNode>,\n  variableDefinitionMap: Record<string, VariableDefinitionNode>,\n  variableValues: Record<string, any>,\n  newArgs: Record<string, any>,\n): void {\n  targetField.args.forEach((argument: GraphQLArgument) => {\n    const argName = argument.name;\n    const argType = argument.type;\n\n    if (argName in newArgs) {\n      updateArgument(\n        argName,\n        argType,\n        argumentNodeMap,\n        variableDefinitionMap,\n        variableValues,\n        serializeInputValue(argType, newArgs[argName]),\n      );\n    }\n  });\n}\n","import {\n  versionInfo,\n  getOperationRootType,\n  lexicographicSortSchema,\n  printError,\n} from 'graphql';\n\nlet version: number;\n\nif (versionInfo != null && versionInfo.major >= 15) {\n  version = 15;\n} else if (getOperationRootType != null) {\n  version = 14;\n} else if (lexicographicSortSchema != null) {\n  version = 13;\n} else if (printError != null) {\n  version = 12;\n} else {\n  version = 11;\n}\n\nexport function graphqlVersion() {\n  return version;\n}\n","const hasOwn = Object.prototype.hasOwnProperty;\n\nexport function hasOwnProperty(object: any, propertyName: string): boolean {\n  return hasOwn.call(object, propertyName);\n}\n","// graphql <v14.2 does not support toConfig\n\nimport {\n  GraphQLSchema,\n  GraphQLFieldMap,\n  GraphQLArgument,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLObjectType,\n  GraphQLObjectTypeConfig,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLInterfaceType,\n  GraphQLInterfaceTypeConfig,\n  GraphQLUnionType,\n  GraphQLUnionTypeConfig,\n  GraphQLEnumType,\n  GraphQLEnumTypeConfig,\n  GraphQLScalarType,\n  GraphQLScalarTypeConfig,\n  GraphQLInputObjectType,\n  GraphQLInputObjectTypeConfig,\n  GraphQLDirective,\n  GraphQLDirectiveConfig,\n  GraphQLSchemaConfig,\n  GraphQLNamedType,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputFieldConfig,\n  GraphQLInputFieldMap,\n  GraphQLArgumentConfig,\n  GraphQLFieldConfig,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n  isScalarType,\n  isInputObjectType,\n  isSchema,\n  isDirective,\n  isNamedType,\n} from 'graphql';\n\nimport { graphqlVersion } from '../utils/graphqlVersion';\nimport { hasOwnProperty } from '../esUtils/hasOwnProperty';\nimport keyValMap from '../esUtils/keyValMap';\n\nexport function schemaToConfig(schema: GraphQLSchema): GraphQLSchemaConfig {\n  if (schema.toConfig != null) {\n    return schema.toConfig();\n  }\n\n  const newTypes: Array<GraphQLNamedType> = [];\n\n  const types = schema.getTypeMap();\n  Object.keys(types).forEach((typeName) => {\n    newTypes.push(types[typeName]);\n  });\n\n  const schemaConfig = {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType(),\n    types: newTypes,\n    directives: schema.getDirectives().slice(),\n    extensions: schema.extensions,\n    astNode: schema.astNode,\n    extensionASTNodes:\n      schema.extensionASTNodes != null ? schema.extensionASTNodes : [],\n    assumeValid:\n      (schema as { __validationErrors?: boolean }).__validationErrors !==\n      undefined,\n  };\n\n  if (graphqlVersion() >= 15) {\n    (schemaConfig as {\n      description?: string;\n    }).description = (schema as {\n      description?: string;\n    }).description;\n  }\n\n  return schemaConfig;\n}\n\nexport function toConfig(graphqlObject: GraphQLSchema): GraphQLSchemaConfig;\nexport function toConfig(\n  graphqlObject: GraphQLObjectTypeConfig<any, any> & {\n    interfaces: Array<GraphQLInterfaceType>;\n    fields: GraphQLFieldConfigMap<any, any>;\n  },\n): GraphQLObjectTypeConfig<any, any>;\nexport function toConfig(\n  graphqlObject: GraphQLInterfaceType & {\n    interfaces: Array<GraphQLInterfaceType>;\n    fields: GraphQLFieldConfigMap<any, any>;\n  },\n): GraphQLInterfaceTypeConfig<any, any>;\nexport function toConfig(\n  graphqlObject: GraphQLUnionType,\n): GraphQLUnionTypeConfig<any, any> & {\n  types: Array<GraphQLObjectType>;\n};\nexport function toConfig(graphqlObject: GraphQLEnumType): GraphQLEnumTypeConfig;\nexport function toConfig(\n  graphqlObject: GraphQLScalarType,\n): GraphQLScalarTypeConfig<any, any>;\nexport function toConfig(\n  graphqlObject: GraphQLInputObjectType,\n): GraphQLInputObjectTypeConfig & {\n  fields: GraphQLInputFieldConfigMap;\n};\nexport function toConfig(\n  graphqlObject: GraphQLDirective,\n): GraphQLDirectiveConfig;\nexport function toConfig(\n  graphqlObject: GraphQLInputField,\n): GraphQLInputFieldConfig;\nexport function toConfig(\n  graphqlObject: GraphQLField<any, any>,\n): GraphQLFieldConfig<any, any>;\nexport function toConfig(graphqlObject: any): any;\nexport function toConfig(graphqlObject: any) {\n  if (isSchema(graphqlObject)) {\n    return schemaToConfig(graphqlObject);\n  } else if (isDirective(graphqlObject)) {\n    return directiveToConfig(graphqlObject);\n  } else if (isNamedType(graphqlObject)) {\n    return typeToConfig(graphqlObject);\n  }\n\n  // Input and output fields do not have predicates defined, but using duck typing,\n  // type is defined for input and output fields\n  if (graphqlObject.type != null) {\n    if (\n      graphqlObject.args != null ||\n      graphqlObject.resolve != null ||\n      graphqlObject.subscribe != null\n    ) {\n      return fieldToConfig(graphqlObject);\n    } else if (graphqlObject.defaultValue !== undefined) {\n      return inputFieldToConfig(graphqlObject);\n    }\n\n    // Not all input and output fields can be checked by above in older versions\n    // of graphql, but almost all properties on the field and config are identical.\n    // In particular, just name and isDeprecated should be removed.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const { name, isDeprecated, ...rest } = graphqlObject;\n    return {\n      ...rest,\n    };\n  }\n\n  throw new Error(`Unknown graphql object ${graphqlObject as string}`);\n}\n\nexport function typeToConfig(\n  type: GraphQLObjectType,\n): GraphQLObjectTypeConfig<any, any>;\nexport function typeToConfig(\n  type: GraphQLInterfaceType,\n): GraphQLInterfaceTypeConfig<any, any>;\nexport function typeToConfig(\n  type: GraphQLUnionType,\n): GraphQLUnionTypeConfig<any, any>;\nexport function typeToConfig(type: GraphQLEnumType): GraphQLEnumTypeConfig;\nexport function typeToConfig(\n  type: GraphQLScalarType,\n): GraphQLScalarTypeConfig<any, any>;\nexport function typeToConfig(\n  type: GraphQLInputObjectType,\n): GraphQLInputObjectTypeConfig;\nexport function typeToConfig(type: any): any;\nexport function typeToConfig(type: any) {\n  if (isObjectType(type)) {\n    return objectTypeToConfig(type);\n  } else if (isInterfaceType(type)) {\n    return interfaceTypeToConfig(type);\n  } else if (isUnionType(type)) {\n    return unionTypeToConfig(type);\n  } else if (isEnumType(type)) {\n    return enumTypeToConfig(type);\n  } else if (isScalarType(type)) {\n    return scalarTypeToConfig(type);\n  } else if (isInputObjectType(type)) {\n    return inputObjectTypeToConfig(type);\n  }\n\n  throw new Error(`Unknown type ${type as string}`);\n}\n\nexport function objectTypeToConfig(\n  type: GraphQLObjectType,\n): GraphQLObjectTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    interfaces: type.getInterfaces(),\n    fields: fieldMapToConfig(type.getFields()),\n    isTypeOf: type.isTypeOf,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function interfaceTypeToConfig(\n  type: GraphQLInterfaceType,\n): GraphQLInterfaceTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig: GraphQLInterfaceTypeConfig<any, any> = {\n    name: type.name,\n    description: type.description,\n    fields: fieldMapToConfig(type.getFields()),\n    resolveType: type.resolveType,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  if (graphqlVersion() >= 15) {\n    typeConfig.interfaces = type.getInterfaces();\n  }\n\n  return typeConfig;\n}\n\nexport function unionTypeToConfig(\n  type: GraphQLUnionType,\n): GraphQLUnionTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    types: type.getTypes(),\n    resolveType: type.resolveType,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function enumTypeToConfig(type: GraphQLEnumType): GraphQLEnumTypeConfig {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const newValues = keyValMap(\n    type.getValues(),\n    (value) => value.name,\n    (value) => ({\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode,\n    }),\n  );\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    values: newValues,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function scalarTypeToConfig(\n  type: GraphQLScalarType,\n): GraphQLScalarTypeConfig<any, any> {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    serialize:\n      graphqlVersion() >= 14 || hasOwnProperty(type, 'serialize')\n        ? type.serialize\n        : ((type as unknown) as {\n            _scalarConfig: GraphQLScalarTypeConfig<any, any>;\n          })._scalarConfig.serialize,\n    parseValue:\n      graphqlVersion() >= 14 || hasOwnProperty(type, 'parseValue')\n        ? type.parseValue\n        : ((type as unknown) as {\n            _scalarConfig: GraphQLScalarTypeConfig<any, any>;\n          })._scalarConfig.parseValue,\n    parseLiteral:\n      graphqlVersion() >= 14 || hasOwnProperty(type, 'parseLiteral')\n        ? type.parseLiteral\n        : ((type as unknown) as {\n            _scalarConfig: GraphQLScalarTypeConfig<any, any>;\n          })._scalarConfig.parseLiteral,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function inputObjectTypeToConfig(\n  type: GraphQLInputObjectType,\n): GraphQLInputObjectTypeConfig {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  const typeConfig = {\n    name: type.name,\n    description: type.description,\n    fields: inputFieldMapToConfig(type.getFields()),\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes:\n      type.extensionASTNodes != null ? type.extensionASTNodes : [],\n  };\n\n  return typeConfig;\n}\n\nexport function inputFieldMapToConfig(\n  fields: GraphQLInputFieldMap,\n): GraphQLInputFieldConfigMap {\n  return keyValMap(\n    Object.keys(fields),\n    (fieldName) => fieldName,\n    (fieldName) => toConfig(fields[fieldName]),\n  );\n}\n\nexport function inputFieldToConfig(\n  field: GraphQLInputField,\n): GraphQLInputFieldConfig {\n  return {\n    description: field.description,\n    type: field.type,\n    defaultValue: field.defaultValue,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  };\n}\n\nexport function directiveToConfig(\n  directive: GraphQLDirective,\n): GraphQLDirectiveConfig {\n  if (directive.toConfig != null) {\n    return directive.toConfig();\n  }\n\n  const directiveConfig = {\n    name: directive.name,\n    description: directive.description,\n    locations: directive.locations,\n    args: argumentMapToConfig(directive.args),\n    isRepeatable: directive.isRepeatable,\n    extensions: directive.extensions,\n    astNode: directive.astNode,\n  };\n\n  return directiveConfig;\n}\n\nexport function fieldMapToConfig(\n  fields: GraphQLFieldMap<any, any>,\n): GraphQLFieldConfigMap<any, any> {\n  return keyValMap(\n    Object.keys(fields),\n    (fieldName) => fieldName,\n    (fieldName) => toConfig(fields[fieldName]),\n  );\n}\n\nexport function fieldToConfig(\n  field: GraphQLField<any, any>,\n): GraphQLFieldConfig<any, any> {\n  return {\n    description: field.description,\n    type: field.type,\n    args: argumentMapToConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode,\n  };\n}\n\nexport function argumentMapToConfig(\n  args: ReadonlyArray<GraphQLArgument>,\n): GraphQLFieldConfigArgumentMap {\n  const newArguments = {};\n  args.forEach((arg) => {\n    newArguments[arg.name] = argumentToConfig(arg);\n  });\n\n  return newArguments;\n}\n\nexport function argumentToConfig(arg: GraphQLArgument): GraphQLArgumentConfig {\n  return {\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    extensions: arg.extensions,\n    astNode: arg.astNode,\n  };\n}\n","import {\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLScalarType,\n  isNamedType,\n} from 'graphql';\n\n// FIXME: Replace with https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L139\n// Blocked by https://github.com/graphql/graphql-js/issues/2153\n\nexport const specifiedScalarTypes: Array<GraphQLScalarType> = [\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n];\n\nexport function isSpecifiedScalarType(type: any): boolean {\n  return (\n    isNamedType(type) &&\n    // Would prefer to use specifiedScalarTypes.some(), however %checks needs\n    // a simple expression.\n    (type.name === GraphQLString.name ||\n      type.name === GraphQLInt.name ||\n      type.name === GraphQLFloat.name ||\n      type.name === GraphQLBoolean.name ||\n      type.name === GraphQLID.name)\n  );\n}\n","import {\n  GraphQLDirective,\n  GraphQLEnumType,\n  GraphQLFieldConfigArgumentMap,\n  GraphQLFieldConfigMap,\n  GraphQLInputFieldConfigMap,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLType,\n  GraphQLUnionType,\n  isDirective,\n  isInterfaceType,\n  isEnumType,\n  isInputType,\n  isInputObjectType,\n  isListType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from 'graphql';\n\nimport { toConfig } from '../polyfills/toConfig';\nimport { isSpecifiedScalarType } from '../polyfills/isSpecifiedScalarType';\nimport { graphqlVersion } from '../utils/graphqlVersion';\nimport {\n  SchemaMapper,\n  MapperKind,\n  NamedTypeMapper,\n  DirectiveMapper,\n} from '../Interfaces';\n\nexport function mapSchema(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper = {},\n): GraphQLSchema {\n  const originalTypeMap = schema.getTypeMap();\n  const newTypeMap = Object.create(null);\n  Object.keys(originalTypeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      const typeMapper = getMapper(\n        schema,\n        schemaMapper,\n        originalTypeMap[typeName],\n      );\n\n      if (typeMapper != null) {\n        const newType = typeMapper(originalTypeMap[typeName], schema);\n        newTypeMap[typeName] =\n          newType !== undefined ? newType : originalTypeMap[typeName];\n      } else {\n        newTypeMap[typeName] = originalTypeMap[typeName];\n      }\n    }\n  });\n\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n\n  const newQueryTypeName =\n    queryType != null\n      ? newTypeMap[queryType.name] != null\n        ? newTypeMap[queryType.name].name\n        : undefined\n      : undefined;\n  const newMutationTypeName =\n    mutationType != null\n      ? newTypeMap[mutationType.name] != null\n        ? newTypeMap[mutationType.name].name\n        : undefined\n      : undefined;\n  const newSubscriptionTypeName =\n    subscriptionType != null\n      ? newTypeMap[subscriptionType.name] != null\n        ? newTypeMap[subscriptionType.name].name\n        : undefined\n      : undefined;\n\n  const originalDirectives = schema.getDirectives();\n  const newDirectives: Array<GraphQLDirective> = [];\n  originalDirectives.forEach((directive) => {\n    const directiveMapper = getMapper(schema, schemaMapper, directive);\n    if (directiveMapper != null) {\n      const newDirective = directiveMapper(directive, schema);\n      if (newDirective != null) {\n        newDirectives.push(newDirective);\n      }\n    } else {\n      newDirectives.push(directive);\n    }\n  });\n\n  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n\n  return new GraphQLSchema({\n    ...toConfig(schema),\n    query: newQueryTypeName\n      ? (typeMap[newQueryTypeName] as GraphQLObjectType)\n      : undefined,\n    mutation: newMutationTypeName\n      ? (typeMap[newMutationTypeName] as GraphQLObjectType)\n      : undefined,\n    subscription:\n      newSubscriptionTypeName != null\n        ? (typeMap[newSubscriptionTypeName] as GraphQLObjectType)\n        : undefined,\n    types: Object.keys(typeMap).map((typeName) => typeMap[typeName]),\n    directives,\n  });\n}\n\nfunction getTypeSpecifiers(\n  type: GraphQLType,\n  schema: GraphQLSchema,\n): Array<MapperKind> {\n  const specifiers = [MapperKind.TYPE];\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n    if (type === query) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(\n      MapperKind.COMPOSITE_TYPE,\n      MapperKind.ABSTRACT_TYPE,\n      MapperKind.INTERFACE_TYPE,\n    );\n  } else if (isUnionType(type)) {\n    specifiers.push(\n      MapperKind.COMPOSITE_TYPE,\n      MapperKind.ABSTRACT_TYPE,\n      MapperKind.UNION_TYPE,\n    );\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: GraphQLNamedType,\n): NamedTypeMapper | null;\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: GraphQLDirective,\n): DirectiveMapper | null;\nfunction getMapper(\n  schema: GraphQLSchema,\n  schemaMapper: SchemaMapper,\n  typeOrDirective: any,\n): any {\n  if (isNamedType(typeOrDirective)) {\n    const specifiers = getTypeSpecifiers(typeOrDirective, schema);\n    let typeMapper: NamedTypeMapper | undefined;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n      const next = stack.pop();\n      typeMapper = schemaMapper[next] as NamedTypeMapper;\n    }\n\n    return typeMapper != null ? typeMapper : null;\n  } else if (isDirective(typeOrDirective)) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n  }\n}\n\nexport function rewireTypes(\n  originalTypeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n): {\n  typeMap: Record<string, GraphQLNamedType>;\n  directives: Array<GraphQLDirective>;\n} {\n  const newTypeMap: Record<string, GraphQLNamedType> = Object.create(null);\n\n  Object.keys(originalTypeMap).forEach((typeName) => {\n    const namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const newName = namedType.name;\n    if (newName.startsWith('__')) {\n      return;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  });\n\n  Object.keys(newTypeMap).forEach((typeName) => {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  });\n\n  const newDirectives = directives.map((directive) =>\n    rewireDirective(directive),\n  );\n\n  return pruneTypes(newTypeMap, newDirectives);\n\n  function rewireDirective(directive: GraphQLDirective): GraphQLDirective {\n    const directiveConfig = toConfig(directive);\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(\n    args: GraphQLFieldConfigArgumentMap,\n  ): GraphQLFieldConfigArgumentMap {\n    const rewiredArgs = {};\n    Object.keys(args).forEach((argName) => {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    });\n    return rewiredArgs;\n  }\n\n  function rewireNamedType<T extends GraphQLNamedType>(type: T) {\n    if (isObjectType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces),\n      };\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        fields: () => rewireFields(config.fields),\n      };\n      if (graphqlVersion() >= 15) {\n        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n      }\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        types: () => rewireNamedTypes(config.types),\n      };\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type)) {\n      const config = toConfig(type);\n      const newConfig = {\n        ...config,\n        fields: () => rewireInputFields(config.fields),\n      };\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type)) {\n      const enumConfig = toConfig(type);\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n      const scalarConfig = toConfig(type);\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${(type as unknown) as string}`);\n  }\n\n  function rewireFields(\n    fields: GraphQLFieldConfigMap<any, any>,\n  ): GraphQLFieldConfigMap<any, any> {\n    const rewiredFields = {};\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireInputFields(\n    fields: GraphQLInputFieldConfigMap,\n  ): GraphQLInputFieldConfigMap {\n    const rewiredFields = {};\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes<T extends GraphQLNamedType>(\n    namedTypes: Array<T>,\n  ): Array<T> {\n    const rewiredTypes: Array<T> = [];\n    namedTypes.forEach((namedType) => {\n      const rewiredType = rewireType(namedType);\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    });\n    return rewiredTypes;\n  }\n\n  function rewireType<T extends GraphQLType>(type: T): T | null {\n    if (isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? (new GraphQLList(rewiredType) as T) : null;\n    } else if (isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null\n        ? (new GraphQLNonNull(rewiredType) as T)\n        : null;\n    } else if (isNamedType(type)) {\n      const originalType = originalTypeMap[type.name];\n      return originalType != null ? (newTypeMap[originalType.name] as T) : null;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(\n  typeMap: Record<string, GraphQLNamedType>,\n  directives: Array<GraphQLDirective>,\n): {\n  typeMap: Record<string, GraphQLNamedType>;\n  directives: Array<GraphQLDirective>;\n} {\n  const newTypeMap = {};\n\n  const implementedInterfaces = {};\n  Object.keys(typeMap).forEach((typeName) => {\n    const namedType = typeMap[typeName];\n\n    if (\n      isObjectType(namedType) ||\n      (graphqlVersion() >= 15 && isInterfaceType(namedType))\n    ) {\n      namedType.getInterfaces().forEach((iface) => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (Object.keys(type.getFields()).length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (type.getTypes().length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (\n        Object.keys(type.getFields()).length &&\n        implementedInterfaces[type.name]\n      ) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else {\n      newTypeMap[typeName] = type;\n    }\n  }\n\n  // every prune requires another round of healing\n  return prunedTypeMap\n    ? rewireTypes(newTypeMap, directives)\n    : { typeMap, directives };\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  GraphQLType,\n} from 'graphql';\n\nimport {\n  GraphQLSchemaWithTransforms,\n  MapperKind,\n  FieldFilter,\n  RootFieldFilter,\n} from '../Interfaces';\nimport { toConfig } from '../polyfills/toConfig';\n\nimport { mapSchema } from './map';\n\nexport default function filterSchema({\n  schema,\n  rootFieldFilter = () => true,\n  typeFilter = () => true,\n  fieldFilter = () => true,\n}: {\n  schema: GraphQLSchemaWithTransforms;\n  rootFieldFilter?: RootFieldFilter;\n  typeFilter?: (typeName: string, type: GraphQLType) => boolean;\n  fieldFilter?: (typeName: string, fieldName: string) => boolean;\n}): GraphQLSchemaWithTransforms {\n  const filteredSchema: GraphQLSchemaWithTransforms = mapSchema(schema, {\n    [MapperKind.QUERY]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Query', rootFieldFilter),\n    [MapperKind.MUTATION]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Mutation', rootFieldFilter),\n    [MapperKind.SUBSCRIPTION]: (type: GraphQLObjectType) =>\n      filterRootFields(type, 'Subscription', rootFieldFilter),\n    [MapperKind.OBJECT_TYPE]: (type: GraphQLObjectType) =>\n      typeFilter(type.name, type)\n        ? filterObjectFields(type, fieldFilter)\n        : null,\n    [MapperKind.INTERFACE_TYPE]: (type: GraphQLInterfaceType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.UNION_TYPE]: (type: GraphQLUnionType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.INPUT_OBJECT_TYPE]: (type: GraphQLInputObjectType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.ENUM_TYPE]: (type: GraphQLEnumType) =>\n      typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.SCALAR_TYPE]: (type: GraphQLScalarType) =>\n      typeFilter(type.name, type) ? undefined : null,\n  });\n\n  filteredSchema.transforms = schema.transforms;\n\n  return filteredSchema;\n}\n\nfunction filterRootFields(\n  type: GraphQLObjectType,\n  operation: 'Query' | 'Mutation' | 'Subscription',\n  rootFieldFilter: RootFieldFilter,\n): GraphQLObjectType {\n  const config = toConfig(type);\n  Object.keys(config.fields).forEach((fieldName) => {\n    if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction filterObjectFields(\n  type: GraphQLObjectType,\n  fieldFilter: FieldFilter,\n): GraphQLObjectType {\n  const config = toConfig(type);\n  Object.keys(config.fields).forEach((fieldName) => {\n    if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n","import {\n  GraphQLDirective,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  isEnumType,\n  isScalarType,\n} from 'graphql';\n\nimport { isSpecifiedScalarType } from '../polyfills/isSpecifiedScalarType';\nimport { toConfig } from '../polyfills/toConfig';\n\nimport { graphqlVersion } from './graphqlVersion';\nimport { mapSchema } from './map';\n\nexport function cloneDirective(directive: GraphQLDirective): GraphQLDirective {\n  return new GraphQLDirective(toConfig(directive));\n}\n\nexport function cloneType(type: GraphQLNamedType): GraphQLNamedType {\n  if (isObjectType(type)) {\n    const config = toConfig(type);\n    return new GraphQLObjectType({\n      ...config,\n      interfaces:\n        typeof config.interfaces === 'function'\n          ? config.interfaces\n          : config.interfaces.slice(),\n    });\n  } else if (isInterfaceType(type)) {\n    const config = toConfig(type);\n    const newConfig = {\n      ...config,\n      interfaces:\n        graphqlVersion() >= 15\n          ? typeof config.interfaces === 'function'\n            ? config.interfaces\n            : config.interfaces.slice()\n          : undefined,\n    };\n    return new GraphQLInterfaceType(newConfig);\n  } else if (isUnionType(type)) {\n    const config = toConfig(type);\n    return new GraphQLUnionType({\n      ...config,\n      types: config.types.slice(),\n    });\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType(toConfig(type));\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType(toConfig(type));\n  } else if (isScalarType(type)) {\n    return isSpecifiedScalarType(type)\n      ? type\n      : new GraphQLScalarType(toConfig(type));\n  }\n\n  throw new Error(`Invalid type ${type as string}`);\n}\n\nexport function cloneSchema(schema: GraphQLSchema): GraphQLSchema {\n  return mapSchema(schema);\n}\n","import { Source, buildASTSchema, parse, BuildSchemaOptions } from 'graphql';\n\n// polyfill for graphql prior to v13 which do not pass options to buildASTSchema\nexport function buildSchema(\n  ast: string | Source,\n  buildSchemaOptions: BuildSchemaOptions,\n) {\n  return buildASTSchema(parse(ast), buildSchemaOptions);\n}\n","import {\n  GraphQLSchema,\n  isScalarType,\n  isEnumType,\n  isInterfaceType,\n  isUnionType,\n  isObjectType,\n} from 'graphql';\n\nimport { IResolvers } from '../Interfaces';\nimport { isSpecifiedScalarType } from '../polyfills/isSpecifiedScalarType';\n\nimport { cloneType } from './clone';\n\nexport function getResolversFromSchema(schema: GraphQLSchema): IResolvers {\n  const resolvers = Object.create({});\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    if (isScalarType(type)) {\n      if (!isSpecifiedScalarType(type)) {\n        resolvers[typeName] = cloneType(type);\n      }\n    } else if (isEnumType(type)) {\n      resolvers[typeName] = {};\n\n      const values = type.getValues();\n      values.forEach((value) => {\n        resolvers[typeName][value.name] = value.value;\n      });\n    } else if (isInterfaceType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType,\n        };\n      }\n    } else if (isUnionType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType,\n        };\n      }\n    } else if (isObjectType(type)) {\n      resolvers[typeName] = {};\n\n      if (type.isTypeOf != null) {\n        resolvers[typeName].__isTypeOf = type.isTypeOf;\n      }\n\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        const field = fields[fieldName];\n\n        resolvers[typeName][fieldName] = {\n          resolve: field.resolve,\n          subscribe: field.subscribe,\n        };\n      });\n    }\n  });\n\n  return resolvers;\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  extendSchema as graphqlExtendSchema,\n} from 'graphql';\n\nimport { getResolversFromSchema } from '../utils/getResolversFromSchema';\nimport { IResolverOptions } from '../Interfaces';\n\n// polyfill for graphql < v14.2 which does not support subscriptions\nexport function extendSchema(\n  schema: GraphQLSchema,\n  extension: DocumentNode,\n  options: any,\n): GraphQLSchema {\n  const subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType == null) {\n    return graphqlExtendSchema(schema, extension, options);\n  }\n\n  const resolvers = getResolversFromSchema(schema);\n\n  const subscriptionTypeName = subscriptionType.name;\n  const subscriptionResolvers = resolvers[\n    subscriptionTypeName\n  ] as IResolverOptions;\n\n  const extendedSchema = graphqlExtendSchema(schema, extension, options);\n\n  const fields = extendedSchema.getSubscriptionType().getFields();\n  Object.keys(subscriptionResolvers).forEach((fieldName) => {\n    fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;\n  });\n\n  return extendedSchema;\n}\n","import { IndexedObject } from '../Interfaces';\n\n// A generic updater function for arrays or objects.\nexport default function updateEachKey<V>(\n  arrayOrObject: IndexedObject<V>,\n  // The callback can return nothing or undefined to leave the key untouched, null to remove\n  // the key from the array or object, or a non-null V to replace the value.\n  updater: (value: V, key: string) => void | null | V,\n) {\n  let deletedCount = 0;\n\n  Object.keys(arrayOrObject).forEach((key) => {\n    const result = updater(arrayOrObject[key], key);\n\n    if (typeof result === 'undefined') {\n      return;\n    }\n\n    if (result === null) {\n      delete arrayOrObject[key];\n      deletedCount++;\n      return;\n    }\n\n    arrayOrObject[key] = result;\n  });\n\n  if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n    // Remove any holes from the array due to deleted elements.\n    arrayOrObject.splice(0).forEach((elem) => {\n      arrayOrObject.push(elem);\n    });\n  }\n}\n","import {\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLInputObjectType,\n  GraphQLString,\n  GraphQLNamedType,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  isObjectType,\n  isInterfaceType,\n  isInputObjectType,\n  TypeNode,\n  Kind,\n  GraphQLType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLOutputType,\n  GraphQLInputType,\n} from 'graphql';\n\nexport function createNamedStub(\n  name: string,\n  type: 'object',\n): GraphQLObjectType;\nexport function createNamedStub(\n  name: string,\n  type: 'interface',\n): GraphQLInterfaceType;\nexport function createNamedStub(\n  name: string,\n  type: 'input',\n): GraphQLInputObjectType;\nexport function createNamedStub(\n  name: string,\n  type: any,\n): GraphQLObjectType | GraphQLInterfaceType | GraphQLInputObjectType {\n  let constructor: any;\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      __fake: {\n        type: GraphQLString,\n      },\n    },\n  });\n}\n\nexport function createStub(node: TypeNode, type: 'output'): GraphQLOutputType;\nexport function createStub(node: TypeNode, type: 'input'): GraphQLInputType;\nexport function createStub(\n  node: TypeNode,\n  type: 'output' | 'input',\n): GraphQLType;\nexport function createStub(node: TypeNode, type: any): any {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(createStub(node.type, type));\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(createStub(node.type, type));\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nexport function isNamedStub(type: GraphQLNamedType): boolean {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    const fields = type.getFields();\n    const fieldNames = Object.keys(fields);\n    return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n  }\n\n  return false;\n}\n\nexport function getBuiltInForStub(type: GraphQLNamedType): GraphQLNamedType {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n    case GraphQLString.name:\n      return GraphQLString;\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n    case GraphQLID.name:\n      return GraphQLID;\n    default:\n      return type;\n  }\n}\n","import {\n  GraphQLDirective,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLObjectType,\n  GraphQLNamedType,\n  GraphQLNonNull,\n  GraphQLType,\n  GraphQLUnionType,\n  isNamedType,\n  GraphQLSchema,\n  GraphQLInputType,\n  GraphQLOutputType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isInputObjectType,\n  isLeafType,\n  isListType,\n  isNonNullType,\n} from 'graphql';\n\nimport { toConfig } from '../polyfills/index';\nimport updateEachKey from '../esUtils/updateEachKey';\n\nimport { isNamedStub, getBuiltInForStub } from './stub';\nimport { graphqlVersion } from './graphqlVersion';\n\ntype NamedTypeMap = Record<string, GraphQLNamedType>;\n\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\nexport function healSchema(schema: GraphQLSchema): GraphQLSchema {\n  const typeMap = schema.getTypeMap();\n  const directives = schema.getDirectives();\n\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n\n  const newQueryTypeName =\n    queryType != null\n      ? typeMap[queryType.name] != null\n        ? typeMap[queryType.name].name\n        : undefined\n      : undefined;\n  const newMutationTypeName =\n    mutationType != null\n      ? typeMap[mutationType.name] != null\n        ? typeMap[mutationType.name].name\n        : undefined\n      : undefined;\n  const newSubscriptionTypeName =\n    subscriptionType != null\n      ? typeMap[subscriptionType.name] != null\n        ? typeMap[subscriptionType.name].name\n        : undefined\n      : undefined;\n\n  healTypes(typeMap, directives);\n\n  const filteredTypeMap = {};\n\n  Object.keys(typeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      filteredTypeMap[typeName] = typeMap[typeName];\n    }\n  });\n\n  const healedSchema = new GraphQLSchema({\n    ...toConfig(schema),\n    query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined,\n    mutation: newMutationTypeName\n      ? filteredTypeMap[newMutationTypeName]\n      : undefined,\n    subscription: newSubscriptionTypeName\n      ? filteredTypeMap[newSubscriptionTypeName]\n      : undefined,\n    types: Object.keys(filteredTypeMap).map(\n      (typeName) => filteredTypeMap[typeName],\n    ),\n    directives: directives.slice(),\n  });\n\n  // Reconstruct the schema to reinitialize private variables\n  // e.g. the stored implementation map and the proper root types.\n  Object.assign(schema, healedSchema);\n\n  return schema;\n}\n\nexport function healTypes(\n  originalTypeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n  config: {\n    skipPruning: boolean;\n  } = {\n    skipPruning: false,\n  },\n) {\n  const actualNamedTypeMap: NamedTypeMap = Object.create(null);\n\n  // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const actualName = namedType.name;\n    if (actualName.startsWith('__')) {\n      return;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType;\n\n    // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  });\n\n  // Now add back every named type by its actual name.\n  Object.entries(actualNamedTypeMap).forEach(([typeName, namedType]) => {\n    originalTypeMap[typeName] = namedType;\n  });\n\n  // Directive declaration argument types can refer to named types.\n  directives.forEach((decl: GraphQLDirective) => {\n    updateEachKey(decl.args, (arg) => {\n      arg.type = healType(arg.type) as GraphQLInputType;\n      return arg.type === null ? null : arg;\n    });\n  });\n\n  Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n    // Heal all named types, except for dangling references, kept only to redirect.\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  });\n\n  updateEachKey(originalTypeMap, (_namedType, typeName) => {\n    // Dangling references to renamed types should remain in the schema\n    // during healing, but must be removed now, so that the following\n    // invariant holds for all names: schema.getType(name).name === name\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      return null;\n    }\n  });\n\n  if (!config.skipPruning) {\n    pruneTypes(originalTypeMap, directives);\n  }\n\n  function healNamedType(type: GraphQLNamedType) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n      if (graphqlVersion() >= 15) {\n        healInterfaces(type);\n      }\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type as string}`);\n  }\n\n  function healFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    updateEachKey(type.getFields(), (field) => {\n      updateEachKey(field.args, (arg) => {\n        arg.type = healType(arg.type) as GraphQLInputType;\n        return arg.type === null ? null : arg;\n      });\n      field.type = healType(field.type) as GraphQLOutputType;\n      return field.type === null ? null : field;\n    });\n  }\n\n  function healInterfaces(type: GraphQLObjectType | GraphQLInterfaceType) {\n    updateEachKey(type.getInterfaces(), (iface) => {\n      const healedType = healType(iface) as GraphQLInterfaceType;\n      return healedType;\n    });\n  }\n\n  function healInputFields(type: GraphQLInputObjectType) {\n    updateEachKey(type.getFields(), (field) => {\n      field.type = healType(field.type) as GraphQLInputType;\n      return field.type === null ? null : field;\n    });\n  }\n\n  function healUnderlyingTypes(type: GraphQLUnionType) {\n    updateEachKey(type.getTypes(), (t: GraphQLOutputType) => {\n      const healedType = healType(t) as GraphQLOutputType;\n      return healedType;\n    });\n  }\n\n  function healType<T extends GraphQLType>(type: T): GraphQLType | null {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLNonNull(healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      let officialType = originalTypeMap[type.name];\n      if (officialType === undefined) {\n        if (isNamedStub(type)) {\n          officialType = getBuiltInForStub(type);\n        } else {\n          officialType = type;\n        }\n        originalTypeMap[type.name] = officialType;\n      }\n      return officialType;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(\n  typeMap: Record<string, GraphQLNamedType | null>,\n  directives: ReadonlyArray<GraphQLDirective>,\n) {\n  const implementedInterfaces = {};\n  Object.values(typeMap).forEach((namedType) => {\n    if (\n      isObjectType(namedType) ||\n      (graphqlVersion() >= 15 && isInterfaceType(namedType))\n    ) {\n      namedType.getInterfaces().forEach((iface) => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (!Object.keys(type.getFields()).length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (!type.getTypes().length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (\n        !Object.keys(type.getFields()).length ||\n        !(type.name in implementedInterfaces)\n      ) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    }\n  }\n\n  // every prune requires another round of healing\n  if (prunedTypeMap) {\n    healTypes(typeMap, directives);\n  }\n}\n","import {\n  GraphQLArgument,\n  GraphQLEnumType,\n  GraphQLEnumValue,\n  GraphQLField,\n  GraphQLInputField,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLSchema,\n  GraphQLUnionType,\n} from 'graphql';\n\n// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nexport abstract class SchemaVisitor {\n  // All SchemaVisitor instances are created while visiting a specific\n  // GraphQLSchema object, so this property holds a reference to that object,\n  // in case a visitor method needs to refer to this.schema.\n  public schema!: GraphQLSchema;\n\n  // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n  public static implementsVisitorMethod(methodName: string) {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    const method = this.prototype[methodName];\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this === SchemaVisitor) {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    const stub = SchemaVisitor.prototype[methodName];\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  }\n\n  // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitSchema(_schema: GraphQLSchema): void {}\n\n  public visitScalar(\n    _scalar: GraphQLScalarType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLScalarType | void | null {}\n\n  public visitObject(\n    _object: GraphQLObjectType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLObjectType | void | null {}\n\n  public visitFieldDefinition(\n    _field: GraphQLField<any, any>,\n    _details: {\n      objectType: GraphQLObjectType | GraphQLInterfaceType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLField<any, any> | void | null {}\n\n  public visitArgumentDefinition(\n    _argument: GraphQLArgument,\n    _details: {\n      field: GraphQLField<any, any>;\n      objectType: GraphQLObjectType | GraphQLInterfaceType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLArgument | void | null {}\n\n  public visitInterface(\n    _iface: GraphQLInterfaceType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInterfaceType | void | null {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitUnion(_union: GraphQLUnionType): GraphQLUnionType | void | null {}\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  public visitEnum(_type: GraphQLEnumType): GraphQLEnumType | void | null {}\n\n  public visitEnumValue(\n    _value: GraphQLEnumValue,\n    _details: {\n      enumType: GraphQLEnumType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLEnumValue | void | null {}\n\n  public visitInputObject(\n    _object: GraphQLInputObjectType,\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInputObjectType | void | null {}\n\n  public visitInputFieldDefinition(\n    _field: GraphQLInputField,\n    _details: {\n      objectType: GraphQLInputObjectType;\n    },\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ): GraphQLInputField | void | null {}\n}\n","/**\n * Creates a keyed JS object from an array, given a function to produce the keys\n * for each value in the array.\n *\n * This provides a convenient lookup for the array items if the key function\n * produces unique results.\n *\n *     const phoneBook = [\n *       { name: 'Jon', num: '555-1234' },\n *       { name: 'Jenny', num: '867-5309' }\n *     ]\n *\n *     // { Jon: { name: 'Jon', num: '555-1234' },\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\n *     const entriesByName = keyMap(\n *       phoneBook,\n *       entry => entry.name\n *     )\n *\n *     // { name: 'Jenny', num: '857-6309' }\n *     const jennyEntry = entriesByName['Jenny']\n *\n */\nexport function keyMap<T>(\n  list: ReadonlyArray<T>,\n  keyFn: (item: T) => string,\n): Record<string, T> {\n  return list.reduce((map, item) => {\n    map[keyFn(item)] = item;\n    return map;\n  }, Object.create(null));\n}\n","import { ValueNode, Kind } from 'graphql';\n\nimport keyValMap from '../esUtils/keyValMap';\n\n// Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\nexport default function valueFromASTUntyped(valueNode: ValueNode): any {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n    case Kind.LIST:\n      return valueNode.values.map(valueFromASTUntyped);\n    case Kind.OBJECT: {\n      return keyValMap(\n        valueNode.fields,\n        (field) => field.name.value,\n        (field) => valueFromASTUntyped(field.value),\n      );\n    }\n    /* istanbul ignore next */\n    default:\n      throw new Error('Unexpected value kind: ' + valueNode.kind);\n  }\n}\n","import {\n  GraphQLInterfaceType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  isNamedType,\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInputField,\n  isSchema,\n  isObjectType,\n  isInterfaceType,\n  isInputObjectType,\n  isScalarType,\n  isUnionType,\n  isEnumType,\n  isInputType,\n} from 'graphql';\n\nimport {\n  VisitableSchemaType,\n  VisitorSelector,\n  VisitSchemaKind,\n  NamedTypeVisitor,\n  SchemaVisitorMap,\n} from '../Interfaces';\nimport updateEachKey from '../esUtils/updateEachKey';\n\nimport { healSchema } from './heal';\nimport { SchemaVisitor } from './SchemaVisitor';\n\n// Generic function for visiting GraphQLSchema objects.\nexport function visitSchema(\n  schema: GraphQLSchema,\n  // To accommodate as many different visitor patterns as possible, the\n  // visitSchema function does not simply accept a single instance of the\n  // SchemaVisitor class, but instead accepts a function that takes the\n  // current VisitableSchemaType object and the name of a visitor method and\n  // returns an array of SchemaVisitor instances that implement the visitor\n  // method and have an interest in handling the given VisitableSchemaType\n  // object. In the simplest case, this function can always return an array\n  // containing a single visitor object, without even looking at the type or\n  // methodName parameters. In other cases, this function might sometimes\n  // return an empty array to indicate there are no visitors that should be\n  // applied to the given VisitableSchemaType object. For an example of a\n  // visitor pattern that benefits from this abstraction, see the\n  // SchemaDirectiveVisitor class below.\n  visitorOrVisitorSelector:\n    | VisitorSelector\n    | Array<SchemaVisitor | SchemaVisitorMap>\n    | SchemaVisitor\n    | SchemaVisitorMap,\n): GraphQLSchema {\n  const visitorSelector =\n    typeof visitorOrVisitorSelector === 'function'\n      ? visitorOrVisitorSelector\n      : () => visitorOrVisitorSelector;\n\n  // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n  function callMethod<T extends VisitableSchemaType>(\n    methodName: string,\n    type: T,\n    ...args: Array<any>\n  ): T | null {\n    let visitors = visitorSelector(type, methodName);\n    visitors = Array.isArray(visitors) ? visitors : [visitors];\n\n    let finalType: T | null = type;\n    visitors.every((visitorOrVisitorDef) => {\n      let newType;\n      if (visitorOrVisitorDef instanceof SchemaVisitor) {\n        newType = visitorOrVisitorDef[methodName](finalType, ...args);\n      } else if (\n        isNamedType(finalType) &&\n        (methodName === 'visitScalar' ||\n          methodName === 'visitEnum' ||\n          methodName === 'visitObject' ||\n          methodName === 'visitInputObject' ||\n          methodName === 'visitUnion' ||\n          methodName === 'visitInterface')\n      ) {\n        const specifiers = getTypeSpecifiers(finalType, schema);\n        const typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\n        newType =\n          typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\n      }\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || isSchema(finalType)) {\n        throw new Error(\n          `Method ${methodName} cannot replace schema with ${\n            newType as string\n          }`,\n        );\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        finalType = null;\n        return false;\n      }\n\n      // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n      finalType = newType;\n      return true;\n    });\n\n    // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n    return finalType;\n  }\n\n  // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n  function visit<T extends VisitableSchemaType>(type: T): T | null {\n    if (isSchema(type)) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n\n      const typeMap: Record<\n        string,\n        GraphQLNamedType | null\n      > = type.getTypeMap();\n      Object.entries(typeMap).forEach(([typeName, namedType]) => {\n        if (!typeName.startsWith('__') && namedType != null) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map.\n          // We do not use updateEachKey because we want to preserve\n          // deleted types in the typeMap so that other types that reference\n          // the deleted types can be healed.\n          typeMap[typeName] = visit(namedType);\n        }\n      });\n\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      const newObject = callMethod('visitObject', type);\n      if (newObject != null) {\n        visitFields(newObject);\n      }\n      return newObject;\n    }\n\n    if (isInterfaceType(type)) {\n      const newInterface = callMethod('visitInterface', type);\n      if (newInterface != null) {\n        visitFields(newInterface);\n      }\n      return newInterface;\n    }\n\n    if (isInputObjectType(type)) {\n      const newInputObject = callMethod('visitInputObject', type);\n\n      if (newInputObject != null) {\n        const fieldMap = newInputObject.getFields() as Record<\n          string,\n          GraphQLInputField\n        >;\n        updateEachKey(fieldMap, (field) =>\n          callMethod('visitInputFieldDefinition', field, {\n            // Since we call a different method for input object fields, we\n            // can't reuse the visitFields function here.\n            objectType: newInputObject,\n          }),\n        );\n      }\n\n      return newInputObject;\n    }\n\n    if (isScalarType(type)) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (isUnionType(type)) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (isEnumType(type)) {\n      const newEnum = callMethod('visitEnum', type);\n\n      if (newEnum != null) {\n        updateEachKey(newEnum.getValues(), (value) =>\n          callMethod('visitEnumValue', value, {\n            enumType: newEnum,\n          }),\n        );\n      }\n\n      return newEnum;\n    }\n\n    throw new Error(`Unexpected schema type: ${(type as unknown) as string}`);\n  }\n\n  function visitFields(type: GraphQLObjectType | GraphQLInterfaceType) {\n    updateEachKey(type.getFields(), (field) => {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      const newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type,\n      });\n\n      if (newField.args != null) {\n        updateEachKey(newField.args, (arg) =>\n          callMethod('visitArgumentDefinition', arg, {\n            // Like visitFieldDefinition, visitArgumentDefinition takes a\n            // second parameter that provides additional context, namely the\n            // parent .field and grandparent .objectType. Remember that the\n            // current GraphQLSchema is always available via this.schema.\n            field: newField,\n            objectType: type,\n          }),\n        );\n      }\n\n      return newField;\n    });\n  }\n\n  visit(schema);\n\n  // Automatically update any references to named schema types replaced\n  // during the traversal, so implementors don't have to worry about that.\n  healSchema(schema);\n\n  // Return schema for convenience, even though schema parameter has all updated types.\n  return schema;\n}\n\nfunction getTypeSpecifiers(\n  type: GraphQLType,\n  schema: GraphQLSchema,\n): Array<VisitSchemaKind> {\n  const specifiers = [VisitSchemaKind.TYPE];\n  if (isObjectType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.OBJECT_TYPE,\n    );\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n    if (type === query) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(\n        VisitSchemaKind.ROOT_OBJECT,\n        VisitSchemaKind.SUBSCRIPTION,\n      );\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.ABSTRACT_TYPE,\n      VisitSchemaKind.INTERFACE_TYPE,\n    );\n  } else if (isUnionType(type)) {\n    specifiers.push(\n      VisitSchemaKind.COMPOSITE_TYPE,\n      VisitSchemaKind.ABSTRACT_TYPE,\n      VisitSchemaKind.UNION_TYPE,\n    );\n  } else if (isEnumType(type)) {\n    specifiers.push(VisitSchemaKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getVisitor(\n  visitorDef: SchemaVisitorMap,\n  specifiers: Array<VisitSchemaKind>,\n): NamedTypeVisitor | null {\n  let typeVisitor: NamedTypeVisitor | undefined;\n  const stack = [...specifiers];\n  while (!typeVisitor && stack.length > 0) {\n    const next = stack.pop();\n    typeVisitor = visitorDef[next] as NamedTypeVisitor;\n  }\n\n  return typeVisitor != null ? typeVisitor : null;\n}\n","const MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n\n/**\n * Used to print values in error messages.\n */\nexport function inspect(value: any): string {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value: any, seenValues: Array<any>): string {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n    case 'function':\n      return value.name\n        ? `[function ${(value as Function).name}]`\n        : '[function]';\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n      return formatObjectValue(value, seenValues);\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(\n  value: any,\n  previouslySeenValues: Array<any>,\n): string {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  const seenValues = [...previouslySeenValues, value];\n  const customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    const customValue = customInspectFn.call(value);\n\n    // check for infinite recursion\n    if (customValue !== value) {\n      return typeof customValue === 'string'\n        ? customValue\n        : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object: any, seenValues: Array<any>) {\n  const keys = Object.keys(object);\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  const properties = keys.map((key) => {\n    const value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array: Array<any>, seenValues: Array<any>): string {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(`... ${remaining.toString(10)} more items`);\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(obj: any) {\n  if (typeof obj.inspect === 'function') {\n    return obj.inspect;\n  }\n}\n\nfunction getObjectTag(obj: any): string {\n  const tag = Object.prototype.toString\n    .call(obj)\n    .replace(/^\\[object /, '')\n    .replace(/]$/, '');\n\n  if (tag === 'Object' && typeof obj.constructor === 'function') {\n    const name = obj.constructor.name;\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n","import {\n  valueFromAST,\n  GraphQLField,\n  GraphQLDirective,\n  DirectiveNode,\n  FieldNode,\n  isNonNullType,\n  GraphQLError,\n  Kind,\n  print,\n} from 'graphql';\n\nimport { keyMap } from '../esUtils/keyMap';\nimport toObjMap from '../esUtils/toObjMap';\n\nimport { inspect } from './inspect';\n\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(\n  def: GraphQLField<any, any> | GraphQLDirective,\n  node: FieldNode | DirectiveNode,\n  variableValues: Record<string, any> = {},\n): Record<string, any> {\n  const variableMap = toObjMap(variableValues);\n\n  const coercedValues = {};\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  const argumentNodes = node.arguments ?? [];\n  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\n          `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n            'was not provided.',\n          node,\n        );\n      }\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n      if (variableValues == null || !(variableName in variableMap)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\n            `Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n              `was provided the variable \"$${variableName}\" which was not provided a runtime value.`,\n            valueNode,\n          );\n        }\n        continue;\n      }\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\n        `Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` +\n          'must not be null.',\n        valueNode,\n      );\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\n        `Argument \"${name}\" has invalid value ${print(valueNode)}.`,\n        valueNode,\n      );\n    }\n    coercedValues[name] = coercedValue;\n  }\n  return coercedValues;\n}\n","import {\n  GraphQLDirective,\n  GraphQLSchema,\n  DirectiveLocationEnum,\n  TypeSystemExtensionNode,\n} from 'graphql';\n\nimport { VisitableSchemaType } from '../Interfaces';\nimport keyValMap from '../esUtils/keyValMap';\nimport toObjMap from '../esUtils/toObjMap';\nimport { keyMap } from '../esUtils/keyMap';\n\nimport valueFromASTUntyped from './valueFromASTUntyped';\nimport { SchemaVisitor } from './SchemaVisitor';\nimport { visitSchema } from './visitSchema';\nimport { getArgumentValues } from './getArgumentValues';\n\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\nexport class SchemaDirectiveVisitor<\n  TArgs = { [name: string]: any },\n  TContext = { [key: string]: any }\n> extends SchemaVisitor {\n  // The name of the directive this visitor is allowed to visit (that is, the\n  // identifier that appears after the @ character in the schema). Note that\n  // this property is per-instance rather than static because subclasses of\n  // SchemaDirectiveVisitor can be instantiated multiple times to visit\n  // directives of different names. In other words, SchemaDirectiveVisitor\n  // implementations are effectively anonymous, and it's up to the caller of\n  // SchemaDirectiveVisitor.visitSchemaDirectives to assign names to them.\n  public name: string;\n\n  // A map from parameter names to argument values, as obtained from a\n  // specific occurrence of a @directive(arg1: value1, arg2: value2, ...) in\n  // the schema. Visitor methods may refer to this object via this.args.\n  public args: TArgs;\n\n  // A reference to the type object that this visitor was created to visit.\n  public visitedType: VisitableSchemaType;\n\n  // A shared object that will be available to all visitor instances via\n  // this.context. Callers of visitSchemaDirectives can provide their own\n  // object, or just use the default empty object.\n  public context: TContext;\n\n  // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n  public static getDirectiveDeclaration(\n    directiveName: string,\n    schema: GraphQLSchema,\n  ): GraphQLDirective | null | undefined {\n    return schema.getDirective(directiveName);\n  }\n\n  // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n  public static visitSchemaDirectives(\n    schema: GraphQLSchema,\n    // The keys of this object correspond to directive names as they appear\n    // in the schema, and the values should be subclasses (not instances!)\n    // of the SchemaDirectiveVisitor class. This distinction is important\n    // because a new SchemaDirectiveVisitor instance will be created each\n    // time a matching directive is found in the schema AST, with arguments\n    // and other metadata specific to that occurrence. To help prevent the\n    // mistake of passing instances, the SchemaDirectiveVisitor constructor\n    // method is marked as protected.\n    directiveVisitors: Record<string, typeof SchemaDirectiveVisitor>,\n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context: {\n      [key: string]: any;\n    } = Object.create(null),\n    // The visitSchemaDirectives method returns a map from directive names to\n    // lists of SchemaDirectiveVisitors created while visiting the schema.\n  ): Record<string, Array<SchemaDirectiveVisitor>> {\n    // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n    const declaredDirectives = this.getDeclaredDirectives(\n      schema,\n      directiveVisitors,\n    );\n\n    // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n    const createdVisitors = keyValMap(\n      Object.keys(directiveVisitors),\n      (item) => item,\n      (): Array<SchemaDirectiveVisitor> => [],\n    );\n\n    const directiveVisitorMap = toObjMap(directiveVisitors);\n\n    function visitorSelector(\n      type: VisitableSchemaType,\n      methodName: string,\n    ): Array<SchemaDirectiveVisitor> {\n      let directiveNodes = type.astNode != null ? type.astNode.directives : [];\n\n      const extensionASTNodes: ReadonlyArray<TypeSystemExtensionNode> = (type as {\n        extensionASTNodes?: Array<TypeSystemExtensionNode>;\n      }).extensionASTNodes;\n\n      if (extensionASTNodes != null) {\n        extensionASTNodes.forEach((extensionASTNode) => {\n          directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n        });\n      }\n\n      const visitors: Array<SchemaDirectiveVisitor> = [];\n      directiveNodes.forEach((directiveNode) => {\n        const directiveName = directiveNode.name.value;\n        if (!(directiveName in directiveVisitorMap)) {\n          return;\n        }\n\n        const visitorClass = directiveVisitorMap[directiveName];\n\n        // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n        if (!visitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        const decl = declaredDirectives[directiveName];\n        let args: { [key: string]: any };\n\n        if (decl != null) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n          if (directiveNode.arguments != null) {\n            directiveNode.arguments.forEach((arg) => {\n              args[arg.name.value] = valueFromASTUntyped(arg.value);\n            });\n          }\n        }\n\n        // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n        visitors.push(\n          new visitorClass({\n            name: directiveName,\n            args,\n            visitedType: type,\n            schema,\n            context,\n          }),\n        );\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach((visitor) => {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector);\n\n    return createdVisitors;\n  }\n\n  protected static getDeclaredDirectives(\n    schema: GraphQLSchema,\n    directiveVisitors: Record<string, typeof SchemaDirectiveVisitor>,\n  ) {\n    const directiveVisitorMap = toObjMap(directiveVisitors);\n\n    const declaredDirectives = keyMap(schema.getDirectives(), (d) => d.name);\n    // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n    Object.entries(directiveVisitors).forEach(\n      ([directiveName, visitorClass]) => {\n        const decl = visitorClass.getDirectiveDeclaration(\n          directiveName,\n          schema,\n        );\n        if (decl != null) {\n          declaredDirectives[directiveName] = decl;\n        }\n      },\n    );\n\n    Object.entries(declaredDirectives).forEach(([name, decl]) => {\n      if (!(name in directiveVisitorMap)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n      const visitorClass = directiveVisitorMap[name];\n\n      decl.locations.forEach((loc) => {\n        const visitorMethodName = directiveLocationToVisitorMethodName(loc);\n        if (\n          SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n          !visitorClass.implementsVisitorMethod(visitorMethodName)\n        ) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(\n            `SchemaDirectiveVisitor for @${name} must implement ${visitorMethodName} method`,\n          );\n        }\n      });\n    });\n\n    return declaredDirectives;\n  }\n\n  // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n  protected constructor(config: {\n    name: string;\n    args: TArgs;\n    visitedType: VisitableSchemaType;\n    schema: GraphQLSchema;\n    context: TContext;\n  }) {\n    super();\n    this.name = config.name;\n    this.args = config.args;\n    this.visitedType = config.visitedType;\n    this.schema = config.schema;\n    this.context = config.context;\n  }\n}\n\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc: DirectiveLocationEnum) {\n  return (\n    'visit' +\n    loc.replace(\n      /([^_]*)_?/g,\n      (_wholeMatch, part: string) =>\n        part.charAt(0).toUpperCase() + part.slice(1).toLowerCase(),\n    )\n  );\n}\n","import { getNamedType, GraphQLSchema, isObjectType } from 'graphql';\n\nimport { IFieldIteratorFn } from '../Interfaces';\n\nexport function forEachField(\n  schema: GraphQLSchema,\n  fn: IFieldIteratorFn,\n): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    // TODO: maybe have an option to include these?\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n","import {\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInputObjectType,\n} from 'graphql';\n\nimport { IDefaultValueIteratorFn } from '../Interfaces';\n\nexport function forEachDefaultValue(\n  schema: GraphQLSchema,\n  fn: IDefaultValueIteratorFn,\n): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    const type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach((fieldName) => {\n          const field = fields[fieldName];\n\n          field.args.forEach((arg) => {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          });\n        });\n      } else if (isInputObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach((fieldName) => {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        });\n      }\n    }\n  });\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Request, Transform } from '../Interfaces';\nimport { cloneSchema } from '../utils/index';\n\nexport function applySchemaTransforms(\n  originalSchema: GraphQLSchema,\n  transforms: Array<Transform>,\n): GraphQLSchema {\n  return transforms.reduce(\n    (schema: GraphQLSchema, transform: Transform) =>\n      transform.transformSchema != null\n        ? transform.transformSchema(cloneSchema(schema))\n        : schema,\n    originalSchema,\n  );\n}\n\nexport function applyRequestTransforms(\n  originalRequest: Request,\n  transforms: Array<Transform>,\n): Request {\n  return transforms.reduce(\n    (request: Request, transform: Transform) =>\n      transform.transformRequest != null\n        ? transform.transformRequest(request)\n        : request,\n\n    originalRequest,\n  );\n}\n\nexport function applyResultTransforms(\n  originalResult: any,\n  transforms: Array<Transform>,\n): any {\n  return transforms.reduceRight(\n    (result: any, transform: Transform) =>\n      transform.transformResult != null\n        ? transform.transformResult(result)\n        : result,\n    originalResult,\n  );\n}\n","import { ApolloLink, toPromise, execute, ExecutionResult } from 'apollo-link';\n\nimport { Fetcher, IFetcherOperation } from '../Interfaces';\n\nexport { execute } from 'apollo-link';\n\nexport default function linkToFetcher(link: ApolloLink): Fetcher {\n  return (fetcherOperation: IFetcherOperation): Promise<ExecutionResult> =>\n    toPromise(execute(link, fetcherOperation));\n}\n","import { Observable } from 'apollo-link';\nimport { $$asyncIterator } from 'iterall';\n\ntype Callback = (value?: any) => any;\n\nexport function observableToAsyncIterable<T>(\n  observable: Observable<T>,\n): AsyncIterator<T> & {\n  [$$asyncIterator]: () => AsyncIterator<T>;\n} {\n  const pullQueue: Array<Callback> = [];\n  const pushQueue: Array<any> = [];\n\n  let listening = true;\n\n  const pushValue = (value: any) => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value, done: false });\n    } else {\n      pushQueue.push({ value });\n    }\n  };\n\n  const pushError = (error: any) => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({ value: { errors: [error] }, done: false });\n    } else {\n      pushQueue.push({ value: { errors: [error] } });\n    }\n  };\n\n  const pullValue = () =>\n    new Promise((resolve) => {\n      if (pushQueue.length !== 0) {\n        const element = pushQueue.shift();\n        // either {value: {errors: [...]}} or {value: ...}\n        resolve({\n          ...element,\n          done: false,\n        });\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n\n  const subscription = observable.subscribe({\n    next(value: any) {\n      pushValue(value);\n    },\n    error(err: Error) {\n      pushError(err);\n    },\n  });\n\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n      pullQueue.forEach((resolve) => resolve({ value: undefined, done: true }));\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return {\n    next() {\n      return listening ? pullValue() : this.return();\n    },\n    return() {\n      emptyQueue();\n      return Promise.resolve({ value: undefined, done: true });\n    },\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n    [$$asyncIterator]() {\n      return this;\n    },\n  };\n}\n","import { $$asyncIterator } from 'iterall';\n\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport default function mapAsyncIterator<T, U>(\n  iterator: AsyncIterator<T>,\n  callback: (value: T) => Promise<U> | U,\n  rejectCallback?: any,\n): AsyncIterator<U> {\n  let $return: any;\n  let abruptClose: any;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n    abruptClose = (error: any) => {\n      const rethrow = () => Promise.reject(error);\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result: any) {\n    return result.done\n      ? result\n      : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  let mapReject: any;\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    const reject = rejectCallback;\n    mapReject = (error: any) =>\n      asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n  }\n\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    return() {\n      return $return\n        ? $return.call(iterator).then(mapResult, mapReject)\n        : Promise.resolve({ value: undefined, done: true });\n    },\n    throw(error: any) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n      return Promise.reject(error).catch(abruptClose);\n    },\n    [$$asyncIterator]() {\n      return this;\n    },\n  } as any;\n}\n\nfunction asyncMapValue<T, U>(\n  value: T,\n  callback: (value: T) => Promise<U> | U,\n): Promise<U> {\n  return new Promise((resolve) => resolve(callback(value)));\n}\n\nfunction iteratorResult<T>(value: T): IteratorResult<T> {\n  return { value, done: false };\n}\n","import {\n  ArgumentNode,\n  FieldNode,\n  FragmentDefinitionNode,\n  Kind,\n  OperationDefinitionNode,\n  SelectionNode,\n  GraphQLSchema,\n  GraphQLObjectType,\n  OperationTypeNode,\n  typeFromAST,\n  NamedTypeNode,\n  GraphQLInputType,\n  GraphQLArgument,\n  VariableDefinitionNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { ICreateRequestFromInfo, Request, ICreateRequest } from '../Interfaces';\nimport { serializeInputValue } from '../utils/transformInputValue';\nimport { updateArgument } from '../utils/updateArgument';\nimport { keyMap } from '../esUtils/keyMap';\n\nexport function getDelegatingOperation(\n  parentType: GraphQLObjectType,\n  schema: GraphQLSchema,\n): OperationTypeNode {\n  if (parentType === schema.getMutationType()) {\n    return 'mutation';\n  } else if (parentType === schema.getSubscriptionType()) {\n    return 'subscription';\n  }\n\n  return 'query';\n}\n\nexport function createRequestFromInfo({\n  info,\n  operation = getDelegatingOperation(info.parentType, info.schema),\n  fieldName = info.fieldName,\n  selectionSet,\n  fieldNodes,\n}: ICreateRequestFromInfo): Request {\n  return createRequest({\n    sourceSchema: info.schema,\n    sourceParentType: info.parentType,\n    sourceFieldName: info.fieldName,\n    fragments: info.fragments,\n    variableDefinitions: info.operation.variableDefinitions,\n    variableValues: info.variableValues,\n    targetOperation: operation,\n    targetFieldName: fieldName,\n    selectionSet,\n    fieldNodes:\n      selectionSet != null\n        ? undefined\n        : fieldNodes != null\n        ? fieldNodes\n        : info.fieldNodes,\n  });\n}\n\nexport function createRequest({\n  sourceSchema,\n  sourceParentType,\n  sourceFieldName,\n  fragments,\n  variableDefinitions,\n  variableValues,\n  targetOperation,\n  targetFieldName,\n  selectionSet,\n  fieldNodes,\n}: ICreateRequest): Request {\n  let argumentNodes: ReadonlyArray<ArgumentNode>;\n  let newSelectionSet: SelectionSetNode = selectionSet;\n  if (!selectionSet && fieldNodes != null) {\n    const selections: Array<SelectionNode> = fieldNodes.reduce(\n      (acc, fieldNode) =>\n        fieldNode.selectionSet != null\n          ? acc.concat(fieldNode.selectionSet.selections)\n          : acc,\n      [],\n    );\n\n    newSelectionSet = selections.length\n      ? {\n          kind: Kind.SELECTION_SET,\n          selections,\n        }\n      : undefined;\n\n    argumentNodes = fieldNodes[0].arguments;\n  } else {\n    argumentNodes = [];\n  }\n\n  const newVariables = Object.create(null);\n  const variableDefinitionMap = Object.create(null);\n  variableDefinitions.forEach((def) => {\n    const varName = def.variable.name.value;\n    variableDefinitionMap[varName] = def;\n    const varType = typeFromAST(\n      sourceSchema,\n      def.type as NamedTypeNode,\n    ) as GraphQLInputType;\n    newVariables[varName] = serializeInputValue(\n      varType,\n      variableValues[varName],\n    );\n  });\n\n  const argumentNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);\n\n  updateArgumentsWithDefaults(\n    sourceParentType,\n    sourceFieldName,\n    argumentNodeMap,\n    variableDefinitionMap,\n    newVariables,\n  );\n\n  const rootfieldNode: FieldNode = {\n    kind: Kind.FIELD,\n    alias: null,\n    arguments: Object.keys(argumentNodeMap).map(\n      (argName) => argumentNodeMap[argName],\n    ),\n    selectionSet: newSelectionSet,\n    name: {\n      kind: Kind.NAME,\n      value: targetFieldName || fieldNodes[0].name.value,\n    },\n  };\n\n  const operationDefinition: OperationDefinitionNode = {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: targetOperation,\n    variableDefinitions: Object.keys(variableDefinitionMap).map(\n      (varName) => variableDefinitionMap[varName],\n    ),\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [rootfieldNode],\n    },\n  };\n\n  const fragmentDefinitions: Array<FragmentDefinitionNode> = Object.keys(\n    fragments,\n  ).map((fragmentName) => fragments[fragmentName]);\n\n  const document = {\n    kind: Kind.DOCUMENT,\n    definitions: [operationDefinition, ...fragmentDefinitions],\n  };\n\n  return {\n    document,\n    variables: newVariables,\n  };\n}\n\nfunction updateArgumentsWithDefaults(\n  sourceParentType: GraphQLObjectType,\n  sourceFieldName: string,\n  argumentNodeMap: Record<string, ArgumentNode>,\n  variableDefinitionMap: Record<string, VariableDefinitionNode>,\n  variableValues: Record<string, any>,\n): void {\n  const sourceField = sourceParentType.getFields()[sourceFieldName];\n  sourceField.args.forEach((argument: GraphQLArgument) => {\n    const argName = argument.name;\n    const sourceArgType = argument.type;\n\n    if (argumentNodeMap[argName] === undefined) {\n      const defaultValue = argument.defaultValue;\n\n      if (defaultValue !== undefined) {\n        updateArgument(\n          argName,\n          sourceArgType,\n          argumentNodeMap,\n          variableDefinitionMap,\n          variableValues,\n          serializeInputValue(sourceArgType, defaultValue),\n        );\n      }\n    }\n  });\n}\n","import { isAsyncIterable } from 'iterall';\nimport { ApolloLink, execute as executeLink } from 'apollo-link';\nimport {\n  subscribe,\n  execute,\n  validate,\n  GraphQLSchema,\n  ExecutionResult,\n  GraphQLOutputType,\n  isSchema,\n  DocumentNode,\n} from 'graphql';\n\nimport {\n  IDelegateToSchemaOptions,\n  IDelegateRequestOptions,\n  Fetcher,\n  SubschemaConfig,\n  isSubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  Transform,\n} from '../Interfaces';\nimport ExpandAbstractTypes from '../wrap/transforms/ExpandAbstractTypes';\nimport FilterToSchema from '../wrap/transforms/FilterToSchema';\nimport AddReplacementSelectionSets from '../wrap/transforms/AddReplacementSelectionSets';\nimport AddReplacementFragments from '../wrap/transforms/AddReplacementFragments';\nimport AddMergedTypeSelectionSets from '../wrap/transforms/AddMergedTypeSelectionSets';\nimport AddTypenameToAbstract from '../wrap/transforms/AddTypenameToAbstract';\nimport CheckResultAndHandleErrors from '../wrap/transforms/CheckResultAndHandleErrors';\nimport AddArgumentsAsVariables from '../wrap/transforms/AddArgumentsAsVariables';\nimport {\n  applyRequestTransforms,\n  applyResultTransforms,\n} from '../wrap/transforms';\n\nimport linkToFetcher from '../stitch/linkToFetcher';\nimport { observableToAsyncIterable } from '../stitch/observableToAsyncIterable';\nimport mapAsyncIterator from '../stitch/mapAsyncIterator';\nimport { combineErrors } from '../stitch/errors';\n\nimport { createRequestFromInfo, getDelegatingOperation } from './createRequest';\n\nexport default function delegateToSchema(\n  options: IDelegateToSchemaOptions | GraphQLSchema,\n): any {\n  if (isSchema(options)) {\n    throw new Error(\n      'Passing positional arguments to delegateToSchema is deprecated. ' +\n        'Please pass named parameters instead.',\n    );\n  }\n\n  const {\n    info,\n    operation = getDelegatingOperation(info.parentType, info.schema),\n    fieldName = info.fieldName,\n    returnType = info.returnType,\n    selectionSet,\n    fieldNodes,\n  } = options;\n\n  const request = createRequestFromInfo({\n    info,\n    operation,\n    fieldName,\n    selectionSet,\n    fieldNodes,\n  });\n\n  return delegateRequest({\n    ...options,\n    request,\n    operation,\n    fieldName,\n    returnType,\n  });\n}\n\nfunction buildDelegationTransforms(\n  subschemaOrSubschemaConfig: GraphQLSchema | SubschemaConfig,\n  info: IGraphQLToolsResolveInfo,\n  context: Record<string, any>,\n  targetSchema: GraphQLSchema,\n  fieldName: string,\n  args: Record<string, any>,\n  returnType: GraphQLOutputType,\n  transforms: Array<Transform>,\n  skipTypeMerging: boolean,\n): Array<Transform> {\n  let delegationTransforms: Array<Transform> = [\n    new CheckResultAndHandleErrors(\n      info,\n      fieldName,\n      subschemaOrSubschemaConfig,\n      context,\n      returnType,\n      skipTypeMerging,\n    ),\n  ];\n\n  if (info.mergeInfo != null) {\n    delegationTransforms.push(\n      new AddReplacementSelectionSets(\n        info.schema,\n        info.mergeInfo.replacementSelectionSets,\n      ),\n      new AddMergedTypeSelectionSets(info.schema, info.mergeInfo.mergedTypes),\n    );\n  }\n\n  delegationTransforms = delegationTransforms.concat(transforms);\n\n  delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));\n\n  if (info.mergeInfo != null) {\n    delegationTransforms.push(\n      new AddReplacementFragments(\n        targetSchema,\n        info.mergeInfo.replacementFragments,\n      ),\n    );\n  }\n\n  if (args != null) {\n    delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\n  }\n\n  delegationTransforms.push(\n    new FilterToSchema(targetSchema),\n    new AddTypenameToAbstract(targetSchema),\n  );\n\n  return delegationTransforms;\n}\n\nexport function delegateRequest({\n  request,\n  schema: subschemaOrSubschemaConfig,\n  rootValue,\n  info,\n  operation = getDelegatingOperation(info.parentType, info.schema),\n  fieldName = info.fieldName,\n  args,\n  returnType = info.returnType,\n  context,\n  transforms = [],\n  skipValidation,\n  skipTypeMerging,\n}: IDelegateRequestOptions): any {\n  let targetSchema: GraphQLSchema;\n  let targetRootValue: Record<string, any>;\n  let requestTransforms: Array<Transform> = transforms.slice();\n  let subschemaConfig: SubschemaConfig;\n\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    subschemaConfig = subschemaOrSubschemaConfig;\n    targetSchema = subschemaConfig.schema;\n    targetRootValue =\n      rootValue != null\n        ? rootValue\n        : subschemaConfig.rootValue != null\n        ? subschemaConfig.rootValue\n        : info.rootValue;\n    if (subschemaConfig.transforms != null) {\n      requestTransforms = requestTransforms.concat(subschemaConfig.transforms);\n    }\n  } else {\n    targetSchema = subschemaOrSubschemaConfig;\n    targetRootValue = rootValue != null ? rootValue : info.rootValue;\n  }\n\n  const delegationTransforms = buildDelegationTransforms(\n    subschemaOrSubschemaConfig,\n    info,\n    context,\n    targetSchema,\n    fieldName,\n    args,\n    returnType,\n    requestTransforms.reverse(),\n    skipTypeMerging,\n  );\n\n  const processedRequest = applyRequestTransforms(\n    request,\n    delegationTransforms,\n  );\n\n  if (!skipValidation) {\n    const errors = validate(targetSchema, processedRequest.document);\n    if (errors.length > 0) {\n      const combinedError: Error = combineErrors(errors);\n      throw combinedError;\n    }\n  }\n\n  if (operation === 'query' || operation === 'mutation') {\n    const executor = createExecutor(\n      targetSchema,\n      targetRootValue,\n      context,\n      subschemaConfig,\n    );\n\n    const executionResult = executor({\n      document: processedRequest.document,\n      context,\n      variables: processedRequest.variables,\n    });\n\n    if (executionResult instanceof Promise) {\n      return executionResult.then((originalResult: any) =>\n        applyResultTransforms(originalResult, delegationTransforms),\n      );\n    }\n    return applyResultTransforms(executionResult, delegationTransforms);\n  }\n\n  const subscriber = createSubscriber(\n    targetSchema,\n    targetRootValue,\n    context,\n    subschemaConfig,\n  );\n\n  return subscriber({\n    document: processedRequest.document,\n    context,\n    variables: processedRequest.variables,\n  }).then(\n    (\n      subscriptionResult:\n        | AsyncIterableIterator<ExecutionResult>\n        | ExecutionResult,\n    ) => {\n      if (isAsyncIterable(subscriptionResult)) {\n        // \"subscribe\" to the subscription result and map the result through the transforms\n        return mapAsyncIterator<ExecutionResult, any>(\n          subscriptionResult,\n          (result) => {\n            const transformedResult = applyResultTransforms(\n              result,\n              delegationTransforms,\n            );\n            // wrap with fieldName to return for an additional round of resolutioon\n            // with payload as rootValue\n            return {\n              [info.fieldName]: transformedResult,\n            };\n          },\n        );\n      }\n\n      return applyResultTransforms(subscriptionResult, delegationTransforms);\n    },\n  );\n}\n\nfunction createExecutor(\n  schema: GraphQLSchema,\n  rootValue: Record<string, any>,\n  context: Record<string, any>,\n  subschemaConfig?: SubschemaConfig,\n): ({\n  document,\n  context,\n  variables,\n}: {\n  document: DocumentNode;\n  context?: Record<string, any>;\n  variables?: Record<string, any>;\n}) => Promise<ExecutionResult> | ExecutionResult {\n  let fetcher: Fetcher;\n  let targetRootValue: Record<string, any> = rootValue;\n  if (subschemaConfig != null) {\n    if (subschemaConfig.dispatcher != null) {\n      const dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);\n      fetcher =\n        typeof dynamicLinkOrFetcher === 'function'\n          ? dynamicLinkOrFetcher\n          : linkToFetcher(dynamicLinkOrFetcher);\n    } else if (subschemaConfig.link != null) {\n      fetcher = linkToFetcher(subschemaConfig.link);\n    } else if (subschemaConfig.fetcher != null) {\n      fetcher = subschemaConfig.fetcher;\n    }\n\n    if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {\n      targetRootValue = subschemaConfig.rootValue;\n    }\n  }\n\n  if (fetcher != null) {\n    return ({ document, context: graphqlContext, variables }) =>\n      fetcher({\n        query: document,\n        variables,\n        context: { graphqlContext },\n      });\n  }\n\n  return ({ document, context: graphqlContext, variables }) =>\n    execute({\n      schema,\n      document,\n      rootValue: targetRootValue,\n      contextValue: graphqlContext,\n      variableValues: variables,\n    });\n}\n\nfunction createSubscriber(\n  schema: GraphQLSchema,\n  rootValue: Record<string, any>,\n  context: Record<string, any>,\n  subschemaConfig?: SubschemaConfig,\n): ({\n  document,\n  context,\n  variables,\n}: {\n  document: DocumentNode;\n  context?: Record<string, any>;\n  variables?: Record<string, any>;\n}) => Promise<AsyncIterator<ExecutionResult> | ExecutionResult> {\n  let link: ApolloLink;\n  let targetRootValue: Record<string, any> = rootValue;\n\n  if (subschemaConfig != null) {\n    if (subschemaConfig.dispatcher != null) {\n      link = subschemaConfig.dispatcher(context) as ApolloLink;\n    } else if (subschemaConfig.link != null) {\n      link = subschemaConfig.link;\n    }\n\n    if (!link && !rootValue && subschemaConfig.rootValue != null) {\n      targetRootValue = subschemaConfig.rootValue;\n    }\n  }\n\n  if (link != null) {\n    return ({ document, context: graphqlContext, variables }) => {\n      const operation = {\n        query: document,\n        variables,\n        context: { graphqlContext },\n      };\n      const observable = executeLink(link, operation);\n      return Promise.resolve(observableToAsyncIterable(observable));\n    };\n  }\n\n  return ({ document, context: graphqlContext, variables }) =>\n    subscribe({\n      schema,\n      document,\n      rootValue: targetRootValue,\n      contextValue: graphqlContext,\n      variableValues: variables,\n    });\n}\n","// @schemaDefinition: A GraphQL type schema in shorthand\n// @resolvers: Definitions for resolvers to be merged with schema\nexport default class SchemaError extends Error {\n  public message: string;\n\n  constructor(message: string) {\n    super(message);\n    this.message = message;\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n","import {\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLSchema,\n  isAbstractType,\n} from 'graphql';\n\nimport SchemaError from './SchemaError';\n\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\nfunction checkForResolveTypeResolver(\n  schema: GraphQLSchema,\n  requireResolversForResolveType?: boolean,\n) {\n  Object.keys(schema.getTypeMap())\n    .map((typeName) => schema.getType(typeName))\n    .forEach((type: GraphQLUnionType | GraphQLInterfaceType) => {\n      if (!isAbstractType(type)) {\n        return;\n      }\n      if (!type.resolveType) {\n        if (!requireResolversForResolveType) {\n          return;\n        }\n        throw new SchemaError(\n          `Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass false into ` +\n            '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.',\n        );\n      }\n    });\n}\nexport default checkForResolveTypeResolver;\n","import { GraphQLSchema, isObjectType, isInterfaceType } from 'graphql';\n\nimport { IResolvers } from '../Interfaces';\nimport { graphqlVersion } from '../utils/index';\n\nfunction extendResolversFromInterfaces(\n  schema: GraphQLSchema,\n  resolvers: IResolvers,\n) {\n  const typeNames = Object.keys({\n    ...schema.getTypeMap(),\n    ...resolvers,\n  });\n\n  const extendedResolvers: IResolvers = {};\n  typeNames.forEach((typeName) => {\n    const typeResolvers = resolvers[typeName];\n    const type = schema.getType(typeName);\n    if (\n      isObjectType(type) ||\n      (graphqlVersion() >= 15 && isInterfaceType(type))\n    ) {\n      const interfaceResolvers = type\n        .getInterfaces()\n        .map((iFace) => resolvers[iFace.name]);\n      extendedResolvers[typeName] = Object.assign(\n        {},\n        ...interfaceResolvers,\n        typeResolvers,\n      );\n    } else if (typeResolvers != null) {\n      extendedResolvers[typeName] = typeResolvers;\n    }\n  });\n\n  return extendedResolvers;\n}\n\nexport default extendResolversFromInterfaces;\n","import {\n  GraphQLField,\n  GraphQLEnumType,\n  GraphQLSchema,\n  isSchema,\n  isScalarType,\n  isEnumType,\n  isUnionType,\n  isInterfaceType,\n  isObjectType,\n} from 'graphql';\n\nimport {\n  IResolvers,\n  IResolverValidationOptions,\n  IAddResolversToSchemaOptions,\n} from '../Interfaces';\nimport { healSchema, forEachField, forEachDefaultValue } from '../utils/index';\nimport {\n  parseInputValue,\n  serializeInputValue,\n} from '../utils/transformInputValue';\nimport { toConfig } from '../polyfills/index';\nimport keyValMap from '../esUtils/keyValMap';\n\nimport SchemaError from './SchemaError';\nimport checkForResolveTypeResolver from './checkForResolveTypeResolver';\nimport extendResolversFromInterfaces from './extendResolversFromInterfaces';\n\nfunction addResolversToSchema(\n  schemaOrOptions: GraphQLSchema | IAddResolversToSchemaOptions,\n  legacyInputResolvers?: IResolvers,\n  legacyInputValidationOptions?: IResolverValidationOptions,\n): GraphQLSchema {\n  const options: IAddResolversToSchemaOptions = isSchema(schemaOrOptions)\n    ? {\n        schema: schemaOrOptions,\n        resolvers: legacyInputResolvers,\n        resolverValidationOptions: legacyInputValidationOptions,\n      }\n    : schemaOrOptions;\n\n  const {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n  } = options;\n\n  const {\n    allowResolversNotInSchema = false,\n    requireResolversForResolveType,\n  } = resolverValidationOptions;\n\n  const resolvers = inheritResolversFromInterfaces\n    ? extendResolversFromInterfaces(schema, inputResolvers)\n    : inputResolvers;\n\n  const typeMap = schema.getTypeMap();\n\n  Object.keys(resolvers).forEach((typeName) => {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new SchemaError(\n        `\"${typeName}\" defined in resolvers, but has invalid value \"${\n          resolverValue as string\n        }\". A resolver's value must be of type object or function.`,\n      );\n    }\n\n    const type = schema.getType(typeName);\n\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n\n      throw new SchemaError(\n        `\"${typeName}\" defined in resolvers, but not in schema`,\n      );\n    }\n\n    if (isScalarType(type)) {\n      // Support -- without recommending -- overriding default scalar types\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      });\n    } else if (isEnumType(type)) {\n      // We've encountered an enum resolver that is being used to provide an\n      // internal enum value.\n      // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n          throw new SchemaError(\n            `${typeName}.${fieldName} was defined in resolvers, but enum is not in schema`,\n          );\n        }\n      });\n\n      const config = toConfig(type);\n\n      const values = type.getValues();\n      const newValues = keyValMap(\n        values,\n        (value) => value.name,\n        (value) => {\n          const newValue = Object.keys(resolverValue).includes(value.name)\n            ? resolverValue[value.name]\n            : value.name;\n          return {\n            value: newValue,\n            deprecationReason: value.deprecationReason,\n            description: value.description,\n            astNode: value.astNode,\n          };\n        },\n      );\n\n      // healSchema called later to update all fields to new type\n      typeMap[typeName] = new GraphQLEnumType({\n        ...config,\n        values: newValues,\n      });\n    } else if (isUnionType(type)) {\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new SchemaError(\n          `${typeName} was defined in resolvers, but it's not an object`,\n        );\n      });\n    } else if (isObjectType(type) || isInterfaceType(type)) {\n      Object.keys(resolverValue).forEach((fieldName) => {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n\n        const fields = type.getFields();\n        const field = fields[fieldName];\n\n        if (field == null) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new SchemaError(\n            `${typeName}.${fieldName} defined in resolvers, but not in schema`,\n          );\n        }\n\n        const fieldResolve = resolverValue[fieldName];\n        if (typeof fieldResolve === 'function') {\n          // for convenience. Allows shorter syntax in resolver definition file\n          field.resolve = fieldResolve;\n        } else {\n          if (typeof fieldResolve !== 'object') {\n            throw new SchemaError(\n              `Resolver ${typeName}.${fieldName} must be object or function`,\n            );\n          }\n          setFieldProperties(field, fieldResolve);\n        }\n      });\n    }\n  });\n\n  checkForResolveTypeResolver(schema, requireResolversForResolveType);\n\n  // serialize all default values prior to healing fields with new scalar/enum types.\n  forEachDefaultValue(schema, serializeInputValue);\n  // schema may have new scalar/enum types that require healing\n  healSchema(schema);\n  // reparse all default values with new parsing functions.\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, (field) => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(\n  field: GraphQLField<any, any>,\n  propertiesObj: Record<string, any>,\n) {\n  Object.keys(propertiesObj).forEach((propertyName) => {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n\nexport default addResolversToSchema;\n","import {\n  defaultFieldResolver,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\n\n// wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\nfunction addSchemaLevelResolver(\n  schema: GraphQLSchema,\n  fn: GraphQLFieldResolver<any, any>,\n): void {\n  // TODO test that schema is a schema, fn is a function\n  const rootTypes = [\n    schema.getQueryType(),\n    schema.getMutationType(),\n    schema.getSubscriptionType(),\n  ].filter((x) => Boolean(x));\n  rootTypes.forEach((type) => {\n    if (type != null) {\n      // XXX this should run at most once per request to simulate a true root resolver\n      // for graphql-js this is an approximation that works with queries but not mutations\n      const rootResolveFn = runAtMostOncePerRequest(fn);\n      const fields = type.getFields();\n      Object.keys(fields).forEach((fieldName) => {\n        // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n        // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n        if (type === schema.getSubscriptionType()) {\n          fields[fieldName].resolve = wrapResolver(\n            fields[fieldName].resolve,\n            fn,\n          );\n        } else {\n          fields[fieldName].resolve = wrapResolver(\n            fields[fieldName].resolve,\n            rootResolveFn,\n          );\n        }\n      });\n    }\n  });\n}\n\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(\n  innerResolver: GraphQLFieldResolver<any, any> | undefined,\n  outerResolver: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  return (obj, args, ctx, info) =>\n    Promise.resolve(outerResolver(obj, args, ctx, info)).then((root) => {\n      if (innerResolver != null) {\n        return innerResolver(root, args, ctx, info);\n      }\n      return defaultFieldResolver(root, args, ctx, info);\n    });\n}\n\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(\n  fn: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  let value: any;\n  const randomNumber = Math.random();\n  return (root, args, ctx, info) => {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n    return value;\n  };\n}\n\nexport default addSchemaLevelResolver;\n","import {\n  GraphQLSchema,\n  GraphQLField,\n  getNamedType,\n  isScalarType,\n} from 'graphql';\n\nimport { IResolverValidationOptions } from '../Interfaces';\nimport { forEachField } from '../utils/index';\n\nimport SchemaError from './SchemaError';\n\nfunction assertResolversPresent(\n  schema: GraphQLSchema,\n  resolverValidationOptions: IResolverValidationOptions = {},\n): void {\n  const {\n    requireResolversForArgs = false,\n    requireResolversForNonScalar = false,\n    requireResolversForAllFields = false,\n  } = resolverValidationOptions;\n\n  if (\n    requireResolversForAllFields &&\n    (requireResolversForArgs || requireResolversForNonScalar)\n  ) {\n    throw new TypeError(\n      'requireResolversForAllFields takes precedence over the more specific assertions. ' +\n        'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n        'requireResolversForNonScalar, but not a combination of them.',\n    );\n  }\n\n  forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver(field, typeName, fieldName);\n    }\n\n    // requires a resolver on every field that has arguments\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver(field, typeName, fieldName);\n    }\n\n    // requires a resolver on every field that returns a non-scalar type\n    if (\n      requireResolversForNonScalar &&\n      !isScalarType(getNamedType(field.type))\n    ) {\n      expectResolver(field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(\n  field: GraphQLField<any, any>,\n  typeName: string,\n  fieldName: string,\n) {\n  if (!field.resolve) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `Resolver missing for \"${typeName}.${fieldName}\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131`,\n    );\n    return;\n  }\n  if (typeof field.resolve !== 'function') {\n    throw new SchemaError(\n      `Resolver \"${typeName}.${fieldName}\" must be a function`,\n    );\n  }\n}\n\nexport default assertResolversPresent;\n","import { GraphQLSchema, GraphQLField, defaultFieldResolver } from 'graphql';\n\nimport { IDirectiveResolvers } from '../Interfaces';\nimport { SchemaDirectiveVisitor } from '../utils/SchemaDirectiveVisitor';\n\nfunction attachDirectiveResolvers(\n  schema: GraphQLSchema,\n  directiveResolvers: IDirectiveResolvers,\n) {\n  if (typeof directiveResolvers !== 'object') {\n    throw new Error(\n      `Expected directiveResolvers to be of type object, got ${typeof directiveResolvers}`,\n    );\n  }\n\n  if (Array.isArray(directiveResolvers)) {\n    throw new Error(\n      'Expected directiveResolvers to be of type object, got Array',\n    );\n  }\n\n  const schemaDirectives = Object.create(null);\n\n  Object.keys(directiveResolvers).forEach((directiveName) => {\n    schemaDirectives[directiveName] = class extends SchemaDirectiveVisitor {\n      public visitFieldDefinition(field: GraphQLField<any, any>) {\n        const resolver = directiveResolvers[directiveName];\n        const originalResolver =\n          field.resolve != null ? field.resolve : defaultFieldResolver;\n        const directiveArgs = this.args;\n        field.resolve = (...args) => {\n          const [source /* original args */, , context, info] = args;\n          return resolver(\n            () =>\n              new Promise((resolve, reject) => {\n                const result = originalResolver.apply(field, args);\n                if (result instanceof Error) {\n                  reject(result);\n                }\n                resolve(result);\n              }),\n            source,\n            directiveArgs,\n            context,\n            info,\n          );\n        };\n      }\n    };\n  });\n\n  SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n}\n\nexport default attachDirectiveResolvers;\n","import { deprecated } from 'deprecated-decorator';\nimport { GraphQLSchema, GraphQLFieldResolver, isSchema } from 'graphql';\n\nimport { IConnectors, IConnector, IConnectorCls } from '../Interfaces';\n\nimport addSchemaLevelResolver from './addSchemaLevelResolver';\n\n// takes a GraphQL-JS schema and an object of connectors, then attaches\n// the connectors to the context by wrapping each query or mutation resolve\n// function with a function that attaches connectors if they don't exist.\n// attaches connectors only once to make sure they are singletons\nconst attachConnectorsToContext = deprecated<Function>(\n  {\n    version: '0.7.0',\n    url: 'https://github.com/apollostack/graphql-tools/issues/140',\n  },\n  (schema: GraphQLSchema, connectors: IConnectors): void => {\n    if (!schema || !isSchema(schema)) {\n      throw new Error(\n        'schema must be an instance of GraphQLSchema. ' +\n          'This error could be caused by installing more than one version of GraphQL-JS',\n      );\n    }\n\n    if (typeof connectors !== 'object') {\n      const connectorType = typeof connectors;\n      throw new Error(\n        `Expected connectors to be of type object, got ${connectorType}`,\n      );\n    }\n    if (Object.keys(connectors).length === 0) {\n      throw new Error('Expected connectors to not be an empty object');\n    }\n    if (Array.isArray(connectors)) {\n      throw new Error('Expected connectors to be of type object, got Array');\n    }\n    if (schema['_apolloConnectorsAttached']) {\n      throw new Error(\n        'Connectors already attached to context, cannot attach more than once',\n      );\n    }\n    schema['_apolloConnectorsAttached'] = true;\n    const attachconnectorFn: GraphQLFieldResolver<any, any> = (\n      root,\n      _args,\n      ctx,\n    ) => {\n      if (typeof ctx !== 'object') {\n        // if in any way possible, we should throw an error when the attachconnectors\n        // function is called, not when a query is executed.\n        const contextType = typeof ctx;\n        throw new Error(\n          `Cannot attach connector because context is not an object: ${contextType}`,\n        );\n      }\n      if (typeof ctx.connectors === 'undefined') {\n        ctx.connectors = {};\n      }\n      Object.keys(connectors).forEach((connectorName) => {\n        const connector: IConnector = connectors[connectorName];\n        if (connector.prototype != null) {\n          ctx.connectors[connectorName] = new (connector as IConnectorCls)(ctx);\n        } else {\n          throw new Error('Connector must be a function or an class');\n        }\n      });\n      return root;\n    };\n    addSchemaLevelResolver(schema, attachconnectorFn);\n  },\n);\n\nexport default attachConnectorsToContext;\n","import { DocumentNode, DefinitionNode, Kind } from 'graphql';\n\nimport { graphqlVersion } from '../utils/index';\n\nexport function extractExtensionDefinitions(ast: DocumentNode) {\n  const extensionDefs = ast.definitions.filter(\n    (def: DefinitionNode) =>\n      def.kind === Kind.OBJECT_TYPE_EXTENSION ||\n      (graphqlVersion() >= 13 && def.kind === Kind.INTERFACE_TYPE_EXTENSION) ||\n      def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\n      def.kind === Kind.UNION_TYPE_EXTENSION ||\n      def.kind === Kind.ENUM_TYPE_EXTENSION ||\n      def.kind === Kind.SCALAR_TYPE_EXTENSION ||\n      def.kind === Kind.SCHEMA_EXTENSION,\n  );\n\n  return {\n    ...ast,\n    definitions: extensionDefs,\n  };\n}\n\nexport function filterExtensionDefinitions(ast: DocumentNode) {\n  const extensionDefs = ast.definitions.filter(\n    (def: DefinitionNode) =>\n      def.kind !== Kind.OBJECT_TYPE_EXTENSION &&\n      def.kind !== Kind.INTERFACE_TYPE_EXTENSION &&\n      def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION &&\n      def.kind !== Kind.UNION_TYPE_EXTENSION &&\n      def.kind !== Kind.ENUM_TYPE_EXTENSION &&\n      def.kind !== Kind.SCALAR_TYPE_EXTENSION &&\n      def.kind !== Kind.SCHEMA_EXTENSION,\n  );\n\n  return {\n    ...ast,\n    definitions: extensionDefs,\n  };\n}\n","import { print, ASTNode } from 'graphql';\n\nimport { ITypedef } from '../Interfaces';\n\nimport SchemaError from './SchemaError';\n\nfunction concatenateTypeDefs(\n  typeDefinitionsAry: Array<ITypedef>,\n  calledFunctionRefs = [] as any,\n): string {\n  let resolvedTypeDefinitions: Array<string> = [];\n  typeDefinitionsAry.forEach((typeDef: ITypedef) => {\n    if (typeof typeDef === 'function') {\n      if (calledFunctionRefs.indexOf(typeDef) === -1) {\n        calledFunctionRefs.push(typeDef);\n        resolvedTypeDefinitions = resolvedTypeDefinitions.concat(\n          concatenateTypeDefs(typeDef(), calledFunctionRefs),\n        );\n      }\n    } else if (typeof typeDef === 'string') {\n      resolvedTypeDefinitions.push(typeDef.trim());\n    } else if ((typeDef as ASTNode).kind !== undefined) {\n      resolvedTypeDefinitions.push(print(typeDef).trim());\n    } else {\n      const type = typeof typeDef;\n      throw new SchemaError(\n        `typeDef array must contain only strings and functions, got ${type}`,\n      );\n    }\n  });\n  return uniq(resolvedTypeDefinitions.map((x) => x.trim())).join('\\n');\n}\n\nfunction uniq(array: Array<any>): Array<any> {\n  return array.reduce(\n    (accumulator, currentValue) =>\n      accumulator.indexOf(currentValue) === -1\n        ? [...accumulator, currentValue]\n        : accumulator,\n    [],\n  );\n}\n\nexport default concatenateTypeDefs;\n","import {\n  parse,\n  extendSchema,\n  buildASTSchema,\n  GraphQLSchema,\n  DocumentNode,\n  ASTNode,\n} from 'graphql';\n\nimport { ITypeDefinitions, GraphQLParseOptions } from '../Interfaces';\n\nimport {\n  extractExtensionDefinitions,\n  filterExtensionDefinitions,\n} from './extensionDefinitions';\nimport concatenateTypeDefs from './concatenateTypeDefs';\nimport SchemaError from './SchemaError';\n\nfunction buildSchemaFromTypeDefinitions(\n  typeDefinitions: ITypeDefinitions,\n  parseOptions?: GraphQLParseOptions,\n): GraphQLSchema {\n  // TODO: accept only array here, otherwise interfaces get confusing.\n  let myDefinitions = typeDefinitions;\n  let astDocument: DocumentNode;\n\n  if (isDocumentNode(typeDefinitions)) {\n    astDocument = typeDefinitions;\n  } else if (typeof myDefinitions !== 'string') {\n    if (!Array.isArray(myDefinitions)) {\n      const type = typeof myDefinitions;\n      throw new SchemaError(\n        `typeDefs must be a string, array or schema AST, got ${type}`,\n      );\n    }\n    myDefinitions = concatenateTypeDefs(myDefinitions);\n  }\n\n  if (typeof myDefinitions === 'string') {\n    astDocument = parse(myDefinitions, parseOptions);\n  }\n\n  const typesAst = filterExtensionDefinitions(astDocument);\n\n  const backcompatOptions = { commentDescriptions: true };\n  let schema: GraphQLSchema = buildASTSchema(typesAst, backcompatOptions);\n\n  const extensionsAst = extractExtensionDefinitions(astDocument);\n  if (extensionsAst.definitions.length > 0) {\n    schema = extendSchema(schema, extensionsAst, backcompatOptions);\n  }\n\n  return schema;\n}\n\nfunction isDocumentNode(\n  typeDefinitions: ITypeDefinitions,\n): typeDefinitions is DocumentNode {\n  return (typeDefinitions as ASTNode).kind !== undefined;\n}\n\nexport default buildSchemaFromTypeDefinitions;\n","import {\n  defaultFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLFieldResolver,\n} from 'graphql';\n\nexport function chainResolvers(\n  resolvers: Array<GraphQLFieldResolver<any, any>>,\n) {\n  return (\n    root: any,\n    args: { [argName: string]: any },\n    ctx: any,\n    info: GraphQLResolveInfo,\n  ) =>\n    resolvers.reduce((prev, curResolver) => {\n      if (curResolver != null) {\n        return curResolver(prev, args, ctx, info);\n      }\n\n      return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n","import { defaultFieldResolver, GraphQLFieldResolver } from 'graphql';\n\nimport { ILogger } from '../Interfaces';\n\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nfunction decorateWithLogger(\n  fn: GraphQLFieldResolver<any, any>,\n  logger: ILogger,\n  hint: string,\n): GraphQLFieldResolver<any, any> {\n  const resolver = fn != null ? fn : defaultFieldResolver;\n\n  const logError = (e: Error) => {\n    // TODO: clone the error properly\n    const newE = new Error();\n    newE.stack = e.stack;\n    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n    if (hint) {\n      newE['originalMessage'] = e.message;\n      newE['message'] = `Error in resolver ${hint}\\n${e.message}`;\n    }\n    logger.log(newE);\n  };\n\n  return (root, args, ctx, info) => {\n    try {\n      const result = resolver(root, args, ctx, info);\n      // If the resolver returns a Promise log any Promise rejects.\n      if (\n        result &&\n        typeof result.then === 'function' &&\n        typeof result.catch === 'function'\n      ) {\n        result.catch((reason: Error | string) => {\n          // make sure that it's an error we're logging.\n          const error = reason instanceof Error ? reason : new Error(reason);\n          logError(error);\n\n          // We don't want to leave an unhandled exception so pass on error.\n          return reason;\n        });\n      }\n      return result;\n    } catch (e) {\n      logError(e);\n      // we want to pass on the error, just in case.\n      throw e;\n    }\n  };\n}\n\nexport default decorateWithLogger;\n","import {\n  defaultFieldResolver,\n  GraphQLSchema,\n  GraphQLFieldResolver,\n} from 'graphql';\n\nimport { IExecutableSchemaDefinition, ILogger } from '../Interfaces';\nimport { SchemaDirectiveVisitor, forEachField } from '../utils/index';\nimport { mergeDeep } from '../esUtils/mergeDeep';\n\nimport attachDirectiveResolvers from './attachDirectiveResolvers';\nimport assertResolversPresent from './assertResolversPresent';\nimport addResolversToSchema from './addResolversToSchema';\nimport attachConnectorsToContext from './attachConnectorsToContext';\nimport addSchemaLevelResolver from './addSchemaLevelResolver';\nimport buildSchemaFromTypeDefinitions from './buildSchemaFromTypeDefinitions';\nimport decorateWithLogger from './decorateWithLogger';\nimport SchemaError from './SchemaError';\n\nexport function makeExecutableSchema<TContext = any>({\n  typeDefs,\n  resolvers = {},\n  connectors,\n  logger,\n  allowUndefinedInResolve = true,\n  resolverValidationOptions = {},\n  directiveResolvers,\n  schemaDirectives,\n  parseOptions = {},\n  inheritResolversFromInterfaces = false,\n}: IExecutableSchemaDefinition<TContext>) {\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new SchemaError(\n      'Expected `resolverValidationOptions` to be an object',\n    );\n  }\n\n  if (!typeDefs) {\n    throw new SchemaError('Must provide typeDefs');\n  }\n\n  // We allow passing in an array of resolver maps, in which case we merge them\n  const resolverMap = Array.isArray(resolvers)\n    ? resolvers\n        .filter((resolverObj) => typeof resolverObj === 'object')\n        .reduce(mergeDeep, {})\n    : resolvers;\n\n  // Arguments are now validated and cleaned up\n\n  const schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n\n  addResolversToSchema({\n    schema,\n    resolvers: resolverMap,\n    resolverValidationOptions,\n    inheritResolversFromInterfaces,\n  });\n\n  assertResolversPresent(schema, resolverValidationOptions);\n\n  if (!allowUndefinedInResolve) {\n    addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger != null) {\n    addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    addSchemaLevelResolver(\n      schema,\n      resolvers['__schema'] as GraphQLFieldResolver<any, any>,\n    );\n  }\n\n  if (connectors != null) {\n    // connectors are optional, at least for now. That means you can just import them in the resolve\n    // function if you want.\n    attachConnectorsToContext(schema, connectors);\n  }\n\n  if (directiveResolvers != null) {\n    attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return schema;\n}\n\nfunction decorateToCatchUndefined(\n  fn: GraphQLFieldResolver<any, any>,\n  hint: string,\n): GraphQLFieldResolver<any, any> {\n  const resolve = fn == null ? defaultFieldResolver : fn;\n  return (root, args, ctx, info) => {\n    const result = resolve(root, args, ctx, info);\n    if (typeof result === 'undefined') {\n      throw new Error(`Resolver for \"${hint}\" returned undefined`);\n    }\n    return result;\n  };\n}\n\nexport function addCatchUndefinedToSchema(schema: GraphQLSchema): void {\n  forEachField(schema, (field, typeName, fieldName) => {\n    const errorHint = `${typeName}.${fieldName}`;\n    field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n  });\n}\n\nexport function addErrorLoggingToSchema(\n  schema: GraphQLSchema,\n  logger?: ILogger,\n): void {\n  if (!logger) {\n    throw new Error('Must provide a logger');\n  }\n  if (typeof logger.log !== 'function') {\n    throw new Error('Logger.log must be a function');\n  }\n  forEachField(schema, (field, typeName, fieldName) => {\n    const errorHint = `${typeName}.${fieldName}`;\n    field.resolve = decorateWithLogger(field.resolve, logger, errorHint);\n  });\n}\n","import { GraphQLSchema, GraphQLFieldResolver } from 'graphql';\n\nimport {\n  IAddResolversToSchemaOptions,\n  IResolvers,\n  IResolverValidationOptions,\n} from '../Interfaces';\n\nimport addResolversToSchema from './addResolversToSchema';\nimport addSchemaLevelResolver from './addSchemaLevelResolver';\nimport assertResolversPresent from './assertResolversPresent';\n\nexport { addResolversToSchema, addSchemaLevelResolver, assertResolversPresent };\nexport { default as attachDirectiveResolvers } from './attachDirectiveResolvers';\nexport { default as attachConnectorsToContext } from './attachConnectorsToContext';\nexport { default as buildSchemaFromTypeDefinitions } from './buildSchemaFromTypeDefinitions';\nexport { chainResolvers } from './chainResolvers';\nexport { default as checkForResolveTypeResolver } from './checkForResolveTypeResolver';\nexport { default as concatenateTypeDefs } from './concatenateTypeDefs';\nexport { default as decorateWithLogger } from './decorateWithLogger';\nexport { default as extendResolversFromInterfaces } from './extendResolversFromInterfaces';\nexport {\n  extractExtensionDefinitions,\n  filterExtensionDefinitions,\n} from './extensionDefinitions';\nexport { default as SchemaError } from './SchemaError';\nexport * from './makeExecutableSchema';\n\n// These functions are preserved for backwards compatibility.\n// They are not simply rexported with new (old) names so as to allow\n// typedoc to annotate them.\nexport function addResolveFunctionsToSchema(\n  schemaOrOptions: GraphQLSchema | IAddResolversToSchemaOptions,\n  legacyInputResolvers?: IResolvers,\n  legacyInputValidationOptions?: IResolverValidationOptions,\n): GraphQLSchema {\n  return addResolversToSchema(\n    schemaOrOptions,\n    legacyInputResolvers,\n    legacyInputValidationOptions,\n  );\n}\n\nexport function addSchemaLevelResolveFunction(\n  schema: GraphQLSchema,\n  fn: GraphQLFieldResolver<any, any>,\n): void {\n  addSchemaLevelResolver(schema, fn);\n}\n\nexport function assertResolveFunctionsPresent(\n  schema: GraphQLSchema,\n  resolverValidationOptions: IResolverValidationOptions = {},\n): void {\n  assertResolversPresent(schema, resolverValidationOptions);\n}\n","import {\n  ApolloLink,\n  Operation,\n  NextLink,\n  Observable,\n  FetchResult,\n} from 'apollo-link';\n\nfunction getFinalPromise(object: any): Promise<any> {\n  return Promise.resolve(object).then((resolvedObject) => {\n    if (resolvedObject == null) {\n      return resolvedObject;\n    }\n\n    if (Array.isArray(resolvedObject)) {\n      return Promise.all(resolvedObject.map((o) => getFinalPromise(o)));\n    } else if (typeof resolvedObject === 'object') {\n      const keys = Object.keys(resolvedObject);\n      return Promise.all(\n        keys.map((key) => getFinalPromise(resolvedObject[key])),\n      ).then((awaitedValues) => {\n        for (let i = 0; i < keys.length; i++) {\n          resolvedObject[keys[i]] = awaitedValues[i];\n        }\n        return resolvedObject;\n      });\n    }\n\n    return resolvedObject;\n  });\n}\n\nclass AwaitVariablesLink extends ApolloLink {\n  request(operation: Operation, forward: NextLink): Observable<FetchResult> {\n    return new Observable((observer) => {\n      let subscription: any;\n      getFinalPromise(operation.variables)\n        .then((resolvedVariables) => {\n          operation.variables = resolvedVariables;\n          subscription = forward(operation).subscribe({\n            next: observer.next.bind(observer),\n            error: observer.error.bind(observer),\n            complete: observer.complete.bind(observer),\n          });\n        })\n        .catch(observer.error.bind(observer));\n\n      return () => {\n        if (subscription != null) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  }\n}\n\nexport { AwaitVariablesLink };\n","/* eslint-disable import/no-nodejs-modules */\n\nimport { concat } from 'apollo-link';\nimport {\n  createUploadLink,\n  formDataAppendFile,\n  isExtractableFile,\n} from 'apollo-upload-client';\nimport FormData, { AppendOptions } from 'form-data';\nimport fetch from 'node-fetch';\n\nimport { hasOwnProperty } from '../esUtils/hasOwnProperty';\n\nimport { AwaitVariablesLink } from './AwaitVariablesLink';\n\nclass FormDataWithStreamSupport extends FormData {\n  private hasUnknowableLength: boolean;\n\n  constructor(options?: any) {\n    super(options);\n    this.hasUnknowableLength = false;\n  }\n\n  public append(\n    key: string,\n    value: any,\n    optionsOrFilename: AppendOptions | string = {},\n  ): void {\n    // allow filename as single option\n    const options: AppendOptions =\n      typeof optionsOrFilename === 'string'\n        ? { filename: optionsOrFilename }\n        : optionsOrFilename;\n\n    // empty or either doesn't have path or not an http response\n    if (\n      !options.knownLength &&\n      !Buffer.isBuffer(value) &&\n      typeof value !== 'string' &&\n      !value.path &&\n      !(value.readable && hasOwnProperty(value, 'httpVersion'))\n    ) {\n      this.hasUnknowableLength = true;\n    }\n\n    super.append(key, value, options);\n  }\n\n  public getLength(\n    callback: (err: Error | null, length: number) => void,\n  ): void {\n    if (this.hasUnknowableLength) {\n      return null;\n    }\n\n    return super.getLength(callback);\n  }\n\n  public getLengthSync(): number {\n    if (this.hasUnknowableLength) {\n      return null;\n    }\n\n    // eslint-disable-next-line no-sync\n    return super.getLengthSync();\n  }\n}\n\nexport const createServerHttpLink = (options: any) =>\n  concat(\n    new AwaitVariablesLink(),\n    createUploadLink({\n      ...options,\n      fetch,\n      FormData: FormDataWithStreamSupport,\n      isExtractableFile: (value: any) =>\n        isExtractableFile(value) || value?.createReadStream,\n      formDataAppendFile: (form: FormData, index: string, file: any) => {\n        if (file.createReadStream != null) {\n          form.append(index, file.createReadStream(), {\n            filename: file.filename,\n            contentType: file.mimetype,\n          });\n        } else {\n          formDataAppendFile(form, index, file);\n        }\n      },\n    }),\n  );\n","import {\n  graphql,\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLList,\n  GraphQLType,\n  GraphQLField,\n  GraphQLResolveInfo,\n  getNullableType,\n  getNamedType,\n  GraphQLNamedType,\n  GraphQLFieldResolver,\n  GraphQLNullableType,\n  isSchema,\n  isObjectType,\n  isUnionType,\n  isInterfaceType,\n  isListType,\n  isEnumType,\n  isAbstractType,\n} from 'graphql';\nimport { v4 as uuid } from 'uuid';\n\nimport { buildSchemaFromTypeDefinitions } from '../generate/index';\nimport { forEachField } from '../utils/index';\n\nimport {\n  IMocks,\n  IMockServer,\n  IMockOptions,\n  IMockFn,\n  IMockTypeFn,\n  ITypeDefinitions,\n} from '../Interfaces';\n\n/**\n * This function wraps addMocksToSchema for more convenience\n */\nfunction mockServer(\n  schema: GraphQLSchema | ITypeDefinitions,\n  mocks: IMocks,\n  preserveResolvers: boolean = false,\n): IMockServer {\n  let mySchema: GraphQLSchema;\n  if (!isSchema(schema)) {\n    // TODO: provide useful error messages here if this fails\n    mySchema = buildSchemaFromTypeDefinitions(schema);\n  } else {\n    mySchema = schema;\n  }\n\n  addMocksToSchema({ schema: mySchema, mocks, preserveResolvers });\n\n  return { query: (query, vars) => graphql(mySchema, query, {}, {}, vars) };\n}\n\nconst defaultMockMap: Map<string, IMockFn> = new Map();\ndefaultMockMap.set('Int', () => Math.round(Math.random() * 200) - 100);\ndefaultMockMap.set('Float', () => Math.random() * 200 - 100);\ndefaultMockMap.set('String', () => 'Hello World');\ndefaultMockMap.set('Boolean', () => Math.random() > 0.5);\ndefaultMockMap.set('ID', () => uuid());\n\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nfunction addMocksToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false,\n}: IMockOptions): void {\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n  if (!isSchema(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n  if (!isObject(mocks)) {\n    throw new Error('mocks must be of type Object');\n  }\n\n  // use Map internally, because that API is nicer.\n  const mockFunctionMap: Map<string, IMockFn> = new Map();\n  Object.keys(mocks).forEach((typeName) => {\n    mockFunctionMap.set(typeName, mocks[typeName]);\n  });\n\n  mockFunctionMap.forEach((mockFunction, mockTypeName) => {\n    if (typeof mockFunction !== 'function') {\n      throw new Error(`mockFunctionMap[${mockTypeName}] must be a function`);\n    }\n  });\n\n  const mockType = function (\n    type: GraphQLType,\n    _typeName?: string,\n    fieldName?: string,\n  ): GraphQLFieldResolver<any, any> {\n    // order of precendence for mocking:\n    // 1. if the object passed in already has fieldName, just use that\n    // --> if it's a function, that becomes your resolver\n    // --> if it's a value, the mock resolver will return that\n    // 2. if the nullableType is a list, recurse\n    // 2. if there's a mock defined for this typeName, that will be used\n    // 3. if there's no mock defined, use the default mocks for this type\n    return (\n      root: any,\n      args: { [key: string]: any },\n      context: any,\n      info: GraphQLResolveInfo,\n    ): any => {\n      // nullability doesn't matter for the purpose of mocking.\n      const fieldType = getNullableType(type) as GraphQLNullableType;\n      const namedFieldType = getNamedType(fieldType);\n\n      if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n        let result: any;\n\n        // if we're here, the field is already defined\n        if (typeof root[fieldName] === 'function') {\n          result = root[fieldName](root, args, context, info);\n          if (result instanceof MockList) {\n            result = result.mock(\n              root,\n              args,\n              context,\n              info,\n              fieldType as GraphQLList<any>,\n              mockType,\n            );\n          }\n        } else {\n          result = root[fieldName];\n        }\n\n        // Now we merge the result with the default mock for this type.\n        // This allows overriding defaults while writing very little code.\n        if (mockFunctionMap.has(namedFieldType.name)) {\n          const mock = mockFunctionMap.get(namedFieldType.name);\n\n          result = mergeMocks(\n            mock.bind(null, root, args, context, info),\n            result,\n          );\n        }\n        return result;\n      }\n\n      if (isListType(fieldType)) {\n        return [\n          mockType(fieldType.ofType)(root, args, context, info),\n          mockType(fieldType.ofType)(root, args, context, info),\n        ];\n      }\n      if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n        // the object passed doesn't have this field, so we apply the default mock\n        const mock = mockFunctionMap.get(fieldType.name);\n        return mock(root, args, context, info);\n      }\n      if (isObjectType(fieldType)) {\n        // objects don't return actual data, we only need to mock scalars!\n        return {};\n      }\n      // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n      // otherwise randomly pick a type from all implementation types\n      if (isAbstractType(fieldType)) {\n        let implementationType;\n        if (mockFunctionMap.has(fieldType.name)) {\n          const mock = mockFunctionMap.get(fieldType.name);\n          const interfaceMockObj = mock(root, args, context, info);\n          if (!interfaceMockObj || !interfaceMockObj.__typename) {\n            return Error(`Please return a __typename in \"${fieldType.name}\"`);\n          }\n          implementationType = schema.getType(interfaceMockObj.__typename);\n        } else {\n          const possibleTypes = schema.getPossibleTypes(fieldType);\n          implementationType = getRandomElement(possibleTypes);\n        }\n        return {\n          __typename: implementationType,\n          ...mockType(implementationType)(root, args, context, info),\n        };\n      }\n\n      if (isEnumType(fieldType)) {\n        return getRandomElement(fieldType.getValues()).value;\n      }\n\n      if (defaultMockMap.has(fieldType.name)) {\n        const defaultMock = defaultMockMap.get(fieldType.name);\n        return defaultMock(root, args, context, info);\n      }\n\n      // if we get to here, we don't have a value, and we don't have a mock for this type,\n      // we could return undefined, but that would be hard to debug, so we throw instead.\n      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n      return Error(`No mock defined for type \"${fieldType.name}\"`);\n    };\n  };\n\n  forEachField(\n    schema,\n    (field: GraphQLField<any, any>, typeName: string, fieldName: string) => {\n      assignResolveType(field.type, preserveResolvers);\n      let mockResolver: GraphQLFieldResolver<any, any> = mockType(\n        field.type,\n        typeName,\n        fieldName,\n      );\n\n      // we have to handle the root mutation and root query types differently,\n      // because no resolver is called at the root.\n      const queryType = schema.getQueryType();\n      const isOnQueryType = queryType != null && queryType.name === typeName;\n\n      const mutationType = schema.getMutationType();\n      const isOnMutationType =\n        mutationType != null && mutationType.name === typeName;\n\n      if (isOnQueryType || isOnMutationType) {\n        if (mockFunctionMap.has(typeName)) {\n          const rootMock = mockFunctionMap.get(typeName);\n          // XXX: BUG in here, need to provide proper signature for rootMock.\n          if (\n            typeof rootMock(undefined, {}, {}, {} as any)[fieldName] ===\n            'function'\n          ) {\n            mockResolver = (\n              root: any,\n              args: { [key: string]: any },\n              context: any,\n              info: GraphQLResolveInfo,\n            ) => {\n              const updatedRoot = root ?? {}; // TODO: should we clone instead?\n              updatedRoot[fieldName] = rootMock(root, args, context, info)[\n                fieldName\n              ];\n              // XXX this is a bit of a hack to still use mockType, which\n              // lets you mock lists etc. as well\n              // otherwise we could just set field.resolve to rootMock()[fieldName]\n              // it's like pretending there was a resolver that ran before\n              // the root resolver.\n              return mockType(field.type, typeName, fieldName)(\n                updatedRoot,\n                args,\n                context,\n                info,\n              );\n            };\n          }\n        }\n      }\n      if (!preserveResolvers || !field.resolve) {\n        field.resolve = mockResolver;\n      } else {\n        const oldResolver = field.resolve;\n        field.resolve = (\n          rootObject: any,\n          args: { [key: string]: any },\n          context: any,\n          info: GraphQLResolveInfo,\n        ) =>\n          Promise.all([\n            mockResolver(rootObject, args, context, info),\n            oldResolver(rootObject, args, context, info),\n          ]).then((values) => {\n            const [mockedValue, resolvedValue] = values;\n\n            // In case we couldn't mock\n            if (mockedValue instanceof Error) {\n              // only if value was not resolved, populate the error.\n              if (undefined === resolvedValue) {\n                throw mockedValue;\n              }\n              return resolvedValue;\n            }\n\n            if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n              return undefined !== resolvedValue ? resolvedValue : mockedValue;\n            }\n\n            if (isObject(mockedValue) && isObject(resolvedValue)) {\n              // Object.assign() won't do here, as we need to all properties, including\n              // the non-enumerable ones and defined using Object.defineProperty\n              const emptyObject = Object.create(\n                Object.getPrototypeOf(resolvedValue),\n              );\n              return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n            }\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          });\n      }\n    },\n  );\n}\n\nfunction isObject(thing: any) {\n  return thing === Object(thing) && !Array.isArray(thing);\n}\n\n// returns a random element from that ary\nfunction getRandomElement(ary: ReadonlyArray<any>) {\n  const sample = Math.floor(Math.random() * ary.length);\n  return ary[sample];\n}\n\nfunction mergeObjects(a: Record<string, any>, b: Record<string, any>) {\n  return Object.assign(a, b);\n}\n\nfunction copyOwnPropsIfNotPresent(\n  target: Record<string, any>,\n  source: Record<string, any>,\n) {\n  Object.getOwnPropertyNames(source).forEach((prop) => {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n      Object.defineProperty(\n        target,\n        prop,\n        propertyDescriptor == null ? {} : propertyDescriptor,\n      );\n    }\n  });\n}\n\nfunction copyOwnProps(\n  target: Record<string, any>,\n  ...sources: Array<Record<string, any>>\n) {\n  sources.forEach((source) => {\n    let chain = source;\n    while (chain != null) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  });\n  return target;\n}\n\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction: () => any, customMock: any): any {\n  if (Array.isArray(customMock)) {\n    return customMock.map((el: any) => mergeMocks(genericMockFunction, el));\n  }\n  if (isObject(customMock)) {\n    return mergeObjects(genericMockFunction(), customMock);\n  }\n  return customMock;\n}\n\nfunction getResolveType(namedFieldType: GraphQLNamedType) {\n  if (isAbstractType(namedFieldType)) {\n    return namedFieldType.resolveType;\n  }\n}\n\nfunction assignResolveType(type: GraphQLType, preserveResolvers: boolean) {\n  const fieldType = getNullableType(type) as GraphQLNullableType;\n  const namedFieldType = getNamedType(fieldType);\n\n  const oldResolveType = getResolveType(namedFieldType);\n  if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n    return;\n  }\n\n  if (isInterfaceType(namedFieldType) || isUnionType(namedFieldType)) {\n    // the default `resolveType` always returns null. We add a fallback\n    // resolution that works with how unions and interface are mocked\n    namedFieldType.resolveType = (\n      data: any,\n      _context: any,\n      info: GraphQLResolveInfo,\n    ) => info.schema.getType(data.__typename) as GraphQLObjectType;\n  }\n}\n\nclass MockList {\n  private readonly len: number | Array<number>;\n  private readonly wrappedFunction: GraphQLFieldResolver<any, any> | undefined;\n\n  // wrappedFunction can return another MockList or a value\n  constructor(\n    len: number | Array<number>,\n    wrappedFunction?: GraphQLFieldResolver<any, any>,\n  ) {\n    this.len = len;\n    if (typeof wrappedFunction !== 'undefined') {\n      if (typeof wrappedFunction !== 'function') {\n        throw new Error(\n          'Second argument to MockList must be a function or undefined',\n        );\n      }\n      this.wrappedFunction = wrappedFunction;\n    }\n  }\n\n  public mock(\n    root: any,\n    args: { [key: string]: any },\n    context: any,\n    info: GraphQLResolveInfo,\n    fieldType: GraphQLList<any>,\n    mockTypeFunc: IMockTypeFn,\n  ) {\n    let arr: Array<any>;\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        const res = this.wrappedFunction(root, args, context, info);\n        if (res instanceof MockList) {\n          const nullableType = getNullableType(fieldType.ofType) as GraphQLList<\n            any\n          >;\n          arr[i] = res.mock(\n            root,\n            args,\n            context,\n            info,\n            nullableType,\n            mockTypeFunc,\n          );\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n      }\n    }\n    return arr;\n  }\n\n  private randint(low: number, high: number): number {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  }\n}\n\n// retain addMockFunctionsToSchema for backwards compatibility\n\nfunction addMockFunctionsToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false,\n}: IMockOptions): void {\n  addMocksToSchema({ schema, mocks, preserveResolvers });\n}\n\nexport { addMocksToSchema, addMockFunctionsToSchema, MockList, mockServer };\n","import { GraphQLScalarType, GraphQLError } from 'graphql';\n\nconst GraphQLUpload = new GraphQLScalarType({\n  name: 'Upload',\n  description: 'The `Upload` scalar type represents a file upload.',\n  parseValue: (value) => {\n    if (value != null && value.promise instanceof Promise) {\n      // graphql-upload v10\n      return value.promise;\n    } else if (value instanceof Promise) {\n      // graphql-upload v9\n      return value;\n    }\n    throw new GraphQLError('Upload value invalid.');\n  },\n  // serialization requires to support schema stitching\n  serialize: (value) => value,\n  parseLiteral: (ast) => {\n    throw new GraphQLError('Upload literal unsupported.', ast);\n  },\n});\n\nexport { GraphQLUpload };\n","import { ApolloLink } from 'apollo-link';\nimport {\n  GraphQLSchema,\n  DocumentNode,\n  getIntrospectionQuery,\n  buildClientSchema,\n  parse,\n} from 'graphql';\n\nimport { Fetcher } from '../Interfaces';\n\nimport { combineErrors } from './errors';\nimport linkToFetcher from './linkToFetcher';\n\nconst parsedIntrospectionQuery: DocumentNode = parse(getIntrospectionQuery());\n\nexport default function introspectSchema(\n  linkOrFetcher: ApolloLink | Fetcher,\n  linkContext?: { [key: string]: any },\n): Promise<GraphQLSchema> {\n  const fetcher =\n    typeof linkOrFetcher === 'function'\n      ? linkOrFetcher\n      : linkToFetcher(linkOrFetcher);\n\n  return fetcher({\n    query: parsedIntrospectionQuery,\n    context: linkContext,\n  }).then((introspectionResult) => {\n    if (\n      (Array.isArray(introspectionResult.errors) &&\n        introspectionResult.errors.length) ||\n      !introspectionResult.data.__schema\n    ) {\n      if (Array.isArray(introspectionResult.errors)) {\n        const combinedError: Error = combineErrors(introspectionResult.errors);\n        throw combinedError;\n      } else {\n        throw new Error(\n          'Could not obtain introspection result, received: ' +\n            JSON.stringify(introspectionResult),\n        );\n      }\n    } else {\n      const schema = buildClientSchema(\n        introspectionResult.data as {\n          __schema: any;\n        },\n      );\n      return schema;\n    }\n  });\n}\n","import { defaultFieldResolver } from 'graphql';\n\nimport { IGraphQLToolsResolveInfo } from '../Interfaces';\nimport { handleResult } from '../delegate/checkResultAndHandleErrors';\n\nimport { getSubschema } from './subSchema';\nimport { getResponseKeyFromInfo } from './getResponseKeyFromInfo';\nimport { getErrors } from './errors';\n\n/**\n * Resolver that knows how to:\n * a) handle aliases for proxied schemas\n * b) handle errors from proxied schemas\n * c) handle external to internal enum coversion\n */\nexport default function defaultMergedResolver(\n  parent: Record<string, any>,\n  args: Record<string, any>,\n  context: Record<string, any>,\n  info: IGraphQLToolsResolveInfo,\n) {\n  if (!parent) {\n    return null;\n  }\n\n  const responseKey = getResponseKeyFromInfo(info);\n  const errors = getErrors(parent, responseKey);\n\n  // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\n  // See https://github.com/apollographql/graphql-tools/issues/967\n  if (!errors) {\n    return defaultFieldResolver(parent, args, context, info);\n  }\n\n  const result = parent[responseKey];\n  const subschema = getSubschema(parent, responseKey);\n\n  return handleResult(result, errors, subschema, context, info);\n}\n","import { GraphQLType, isAbstractType, isObjectType } from 'graphql';\n\nimport defaultMergedResolver from './defaultMergedResolver';\nimport resolveFromParentTypename from './resolveFromParentTypename';\n\nexport function makeMergedType(type: GraphQLType): void {\n  if (isObjectType(type)) {\n    type.isTypeOf = undefined;\n\n    const fieldMap = type.getFields();\n    Object.keys(fieldMap).forEach((fieldName) => {\n      fieldMap[fieldName].resolve = defaultMergedResolver;\n      fieldMap[fieldName].subscribe = null;\n    });\n  } else if (isAbstractType(type)) {\n    type.resolveType = (parent) => resolveFromParentTypename(parent);\n  }\n}\n","import {\n  GraphQLSchema,\n  GraphQLFieldResolver,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport {\n  Transform,\n  IResolvers,\n  Operation,\n  SubschemaConfig,\n} from '../Interfaces';\nimport delegateToSchema from '../delegate/delegateToSchema';\nimport { handleResult } from '../delegate/checkResultAndHandleErrors';\n\nimport { makeMergedType } from '../stitch/makeMergedType';\nimport { getResponseKeyFromInfo } from '../stitch/getResponseKeyFromInfo';\nimport { getSubschema } from '../stitch/subSchema';\nimport { getErrors } from '../stitch/errors';\n\nexport function generateProxyingResolvers({\n  subschemaConfig,\n  transforms,\n}: {\n  subschemaConfig: SubschemaConfig;\n  transforms?: Array<Transform>;\n}): IResolvers {\n  const targetSchema = subschemaConfig.schema;\n\n  const operationTypes: Record<Operation, GraphQLObjectType> = {\n    query: targetSchema.getQueryType(),\n    mutation: targetSchema.getMutationType(),\n    subscription: targetSchema.getSubscriptionType(),\n  };\n\n  const createProxyingResolver =\n    subschemaConfig.createProxyingResolver != null\n      ? subschemaConfig.createProxyingResolver\n      : defaultCreateProxyingResolver;\n\n  const resolvers = {};\n  Object.keys(operationTypes).forEach((operation: Operation) => {\n    const resolveField = operation === 'subscription' ? 'subscribe' : 'resolve';\n\n    const rootType = operationTypes[operation];\n    if (rootType != null) {\n      const typeName = rootType.name;\n      const fields = rootType.getFields();\n\n      resolvers[typeName] = {};\n      Object.keys(fields).forEach((fieldName) => {\n        const proxyingResolver = createProxyingResolver(\n          subschemaConfig,\n          transforms,\n          operation,\n          fieldName,\n        );\n\n        const finalResolver = createPossiblyNestedProxyingResolver(\n          subschemaConfig,\n          proxyingResolver,\n        );\n\n        resolvers[typeName][fieldName] = {\n          [resolveField]: finalResolver,\n        };\n      });\n    }\n  });\n\n  return resolvers;\n}\n\nfunction createPossiblyNestedProxyingResolver(\n  subschemaConfig: SubschemaConfig,\n  proxyingResolver: GraphQLFieldResolver<any, any>,\n): GraphQLFieldResolver<any, any> {\n  return (parent, args, context, info) => {\n    if (parent != null) {\n      const responseKey = getResponseKeyFromInfo(info);\n      const errors = getErrors(parent, responseKey);\n\n      // Check to see if the parent contains a proxied result\n      if (errors != null) {\n        const subschema = getSubschema(parent, responseKey);\n\n        // If there is a proxied result from this subschema, return it\n        // This can happen even for a root field when the root type ia\n        // also nested as a field within a different type.\n        if (subschemaConfig === subschema) {\n          return handleResult(\n            parent[responseKey],\n            errors,\n            subschema,\n            context,\n            info,\n          );\n        }\n      }\n    }\n\n    return proxyingResolver(parent, args, context, info);\n  };\n}\n\nexport function defaultCreateProxyingResolver(\n  schema: GraphQLSchema | SubschemaConfig,\n  transforms: Array<Transform>,\n): GraphQLFieldResolver<any, any> {\n  return (_parent, _args, context, info) =>\n    delegateToSchema({\n      schema,\n      context,\n      info,\n      transforms,\n    });\n}\n\nexport function stripResolvers(schema: GraphQLSchema): void {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach((typeName) => {\n    if (!typeName.startsWith('__')) {\n      makeMergedType(typeMap[typeName]);\n    }\n  });\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport addResolversToSchema from '../generate/addResolversToSchema';\nimport { Transform, SubschemaConfig, isSubschemaConfig } from '../Interfaces';\nimport { cloneSchema } from '../utils/clone';\n\nimport { generateProxyingResolvers, stripResolvers } from './resolvers';\nimport { applySchemaTransforms } from './transforms';\n\nexport function wrapSchema(\n  subschemaOrSubschemaConfig: GraphQLSchema | SubschemaConfig,\n  transforms?: Array<Transform>,\n): GraphQLSchema {\n  const subschemaConfig: SubschemaConfig = isSubschemaConfig(\n    subschemaOrSubschemaConfig,\n  )\n    ? subschemaOrSubschemaConfig\n    : { schema: subschemaOrSubschemaConfig };\n\n  const schema = cloneSchema(subschemaConfig.schema);\n\n  stripResolvers(schema);\n\n  const resolvers = generateProxyingResolvers({\n    subschemaConfig,\n    transforms,\n  });\n\n  addResolversToSchema({ schema, resolvers });\n\n  let schemaTransforms: Array<Transform> = [];\n  if (subschemaConfig.transforms != null) {\n    schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);\n  }\n  if (transforms != null) {\n    schemaTransforms = schemaTransforms.concat(transforms);\n  }\n\n  return applySchemaTransforms(schema, schemaTransforms);\n}\n","import {\n  DefinitionNode,\n  EnumTypeDefinitionNode,\n  FieldDefinitionNode,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  InputObjectTypeDefinitionNode,\n  InputValueDefinitionNode,\n  InterfaceTypeDefinitionNode,\n  Kind,\n  ObjectTypeDefinitionNode,\n  ScalarTypeDefinitionNode,\n  UnionTypeDefinitionNode,\n  GraphQLDirective,\n  DirectiveDefinitionNode,\n  DirectiveLocationEnum,\n  DirectiveLocation,\n  GraphQLFieldConfig,\n  StringValueNode,\n  Location,\n  TokenKind,\n} from 'graphql';\n\nimport { graphqlVersion } from '../utils/index';\nimport { createStub, createNamedStub } from '../utils/stub';\nimport keyValMap from '../esUtils/keyValMap';\n\nimport resolveFromParentTypename from './resolveFromParentTypename';\n\nconst backcompatOptions = { commentDescriptions: true };\n\nexport type GetType = (\n  name: string,\n  // this is a hack\n  type: 'object' | 'interface' | 'input',\n) => GraphQLObjectType | GraphQLInputObjectType | GraphQLInterfaceType;\n\nexport default function typeFromAST(\n  node: DefinitionNode,\n): GraphQLNamedType | GraphQLDirective | null {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_DEFINITION:\n      return makeObjectType(node);\n    case Kind.INTERFACE_TYPE_DEFINITION:\n      return makeInterfaceType(node);\n    case Kind.ENUM_TYPE_DEFINITION:\n      return makeEnumType(node);\n    case Kind.UNION_TYPE_DEFINITION:\n      return makeUnionType(node);\n    case Kind.SCALAR_TYPE_DEFINITION:\n      return makeScalarType(node);\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return makeInputObjectType(node);\n    case Kind.DIRECTIVE_DEFINITION:\n      return makeDirective(node);\n    default:\n      return null;\n  }\n}\n\nfunction makeObjectType(node: ObjectTypeDefinitionNode): GraphQLObjectType {\n  const config = {\n    name: node.name.value,\n    fields: () => makeFields(node.fields),\n    interfaces: () =>\n      node.interfaces.map((iface) =>\n        createNamedStub(iface.name.value, 'interface'),\n      ),\n    description: getDescription(node, backcompatOptions),\n  };\n  return new GraphQLObjectType(config);\n}\n\nfunction makeInterfaceType(\n  node: InterfaceTypeDefinitionNode,\n): GraphQLInterfaceType {\n  const config = {\n    name: node.name.value,\n    fields: () => makeFields(node.fields),\n    interfaces:\n      graphqlVersion() >= 15\n        ? () =>\n            node.interfaces.map((iface) =>\n              createNamedStub(iface.name.value, 'interface'),\n            )\n        : undefined,\n    description: getDescription(node, backcompatOptions),\n    resolveType: (parent: any) => resolveFromParentTypename(parent),\n  };\n  return new GraphQLInterfaceType(config);\n}\n\nfunction makeEnumType(node: EnumTypeDefinitionNode): GraphQLEnumType {\n  const values = keyValMap(\n    node.values,\n    (value) => value.name.value,\n    (value) => ({\n      description: getDescription(value, backcompatOptions),\n    }),\n  );\n\n  return new GraphQLEnumType({\n    name: node.name.value,\n    values,\n    description: getDescription(node, backcompatOptions),\n  });\n}\n\nfunction makeUnionType(node: UnionTypeDefinitionNode): GraphQLUnionType {\n  return new GraphQLUnionType({\n    name: node.name.value,\n    types: () =>\n      node.types.map((type) => createNamedStub(type.name.value, 'object')),\n    description: getDescription(node, backcompatOptions),\n    resolveType: (parent) => resolveFromParentTypename(parent),\n  });\n}\n\nfunction makeScalarType(node: ScalarTypeDefinitionNode): GraphQLScalarType {\n  return new GraphQLScalarType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    serialize: () => null,\n    // Note: validation calls the parse functions to determine if a\n    // literal value is correct. Returning null would cause use of custom\n    // scalars to always fail validation. Returning false causes them to\n    // always pass validation.\n    parseValue: () => false,\n    parseLiteral: () => false,\n  });\n}\n\nfunction makeInputObjectType(\n  node: InputObjectTypeDefinitionNode,\n): GraphQLInputObjectType {\n  return new GraphQLInputObjectType({\n    name: node.name.value,\n    fields: () => makeValues(node.fields),\n    description: getDescription(node, backcompatOptions),\n  });\n}\n\nfunction makeFields(\n  nodes: ReadonlyArray<FieldDefinitionNode>,\n): Record<string, GraphQLFieldConfig<any, any>> {\n  return keyValMap(\n    nodes,\n    (node) => node.name.value,\n    (node) => {\n      const deprecatedDirective = node.directives.find(\n        (directive) => directive.name.value === 'deprecated',\n      );\n\n      let deprecationReason;\n\n      if (deprecatedDirective != null) {\n        const deprecatedArgument = deprecatedDirective.arguments.find(\n          (arg) => arg.name.value === 'reason',\n        );\n        deprecationReason = (deprecatedArgument.value as StringValueNode).value;\n      }\n\n      return {\n        type: createStub(node.type, 'output'),\n        args: makeValues(node.arguments),\n        description: getDescription(node, backcompatOptions),\n        deprecationReason,\n      };\n    },\n  );\n}\n\nfunction makeValues(nodes: ReadonlyArray<InputValueDefinitionNode>) {\n  return keyValMap(\n    nodes,\n    (node) => node.name.value,\n    (node) => {\n      const type = createStub(node.type, 'input');\n      return {\n        type,\n        defaultValue: node.defaultValue,\n        description: getDescription(node, backcompatOptions),\n      };\n    },\n  );\n}\n\nfunction makeDirective(node: DirectiveDefinitionNode): GraphQLDirective {\n  const locations: Array<DirectiveLocationEnum> = [];\n  node.locations.forEach((location) => {\n    if (location.value in DirectiveLocation) {\n      locations.push(location.value as DirectiveLocationEnum);\n    }\n  });\n  return new GraphQLDirective({\n    name: node.name.value,\n    description: node.description != null ? node.description.value : null,\n    args: makeValues(node.arguments),\n    locations,\n  });\n}\n\n// graphql < v13 does not export getDescription\n\nfunction getDescription(\n  node: { description?: StringValueNode; loc?: Location },\n  options?: { commentDescriptions?: boolean },\n): string {\n  if (node.description != null) {\n    return node.description.value;\n  }\n  if (options.commentDescriptions) {\n    const rawValue = getLeadingCommentBlock(node);\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue(`\\n${rawValue as string}`);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node: {\n  description?: StringValueNode;\n  loc?: Location;\n}): void | string {\n  const loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  const comments = [];\n  let token = loc.startToken.prev;\n  while (\n    token != null &&\n    token.kind === TokenKind.COMMENT &&\n    token.next != null &&\n    token.prev != null &&\n    token.line + 1 === token.next.line &&\n    token.line !== token.prev.line\n  ) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString: string): string {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n\n  // Remove common indentation from all lines but first.\n  const commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  }\n\n  // Remove leading and trailing blank lines.\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n\n  // Return a string of the lines joined with U+000A.\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\nexport function getBlockStringIndentation(\n  lines: ReadonlyArray<string>,\n): number {\n  let commonIndent = null;\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str: string) {\n  let i = 0;\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n  return i;\n}\n\nfunction isBlank(str: string) {\n  return leadingWhitespace(str) === str.length;\n}\n","import {\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  parse,\n  OperationDefinitionNode,\n} from 'graphql';\n\nexport function concatInlineFragments(\n  type: string,\n  fragments: Array<InlineFragmentNode>,\n): InlineFragmentNode {\n  const fragmentSelections: Array<SelectionNode> = fragments.reduce(\n    (selections, fragment) =>\n      selections.concat(fragment.selectionSet.selections),\n    [],\n  );\n\n  const deduplicatedFragmentSelection: Array<SelectionNode> = deduplicateSelection(\n    fragmentSelections,\n  );\n\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type,\n      },\n    },\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: deduplicatedFragmentSelection,\n    },\n  };\n}\n\nfunction deduplicateSelection(\n  nodes: Array<SelectionNode>,\n): Array<SelectionNode> {\n  const selectionMap = nodes.reduce<{ [key: string]: SelectionNode }>(\n    (map, node) => {\n      switch (node.kind) {\n        case 'Field': {\n          if (node.alias != null) {\n            if (node.alias.value in map) {\n              return map;\n            }\n\n            return {\n              ...map,\n              [node.alias.value]: node,\n            };\n          }\n\n          if (node.name.value in map) {\n            return map;\n          }\n\n          return {\n            ...map,\n            [node.name.value]: node,\n          };\n        }\n        case 'FragmentSpread': {\n          if (node.name.value in map) {\n            return map;\n          }\n\n          return {\n            ...map,\n            [node.name.value]: node,\n          };\n        }\n        case 'InlineFragment': {\n          if (map.__fragment != null) {\n            const fragment = map.__fragment as InlineFragmentNode;\n\n            return {\n              ...map,\n              __fragment: concatInlineFragments(\n                fragment.typeCondition.name.value,\n                [fragment, node],\n              ),\n            };\n          }\n\n          return {\n            ...map,\n            __fragment: node,\n          };\n        }\n        default: {\n          return map;\n        }\n      }\n    },\n    Object.create(null),\n  );\n\n  const selection = Object.keys(selectionMap).reduce(\n    (selectionList, node) => selectionList.concat(selectionMap[node]),\n    [],\n  );\n\n  return selection;\n}\n\nexport function parseFragmentToInlineFragment(\n  definitions: string,\n): InlineFragmentNode {\n  if (definitions.trim().startsWith('fragment')) {\n    const document = parse(definitions);\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet,\n        };\n      }\n    }\n  }\n\n  const query = parse(`{${definitions}}`)\n    .definitions[0] as OperationDefinitionNode;\n  for (const selection of query.selectionSet.selections) {\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n","import {\n  OperationDefinitionNode,\n  SelectionSetNode,\n  parse,\n  Kind,\n  GraphQLObjectType,\n  getNamedType,\n} from 'graphql';\n\nexport function parseSelectionSet(selectionSet: string): SelectionSetNode {\n  const query = parse(selectionSet).definitions[0] as OperationDefinitionNode;\n  return query.selectionSet;\n}\n\nexport function typeContainsSelectionSet(\n  type: GraphQLObjectType,\n  selectionSet: SelectionSetNode,\n): boolean {\n  const fields = type.getFields();\n\n  for (const selection of selectionSet.selections) {\n    if (selection.kind === Kind.FIELD) {\n      const field = fields[selection.name.value];\n\n      if (field == null) {\n        return false;\n      }\n\n      if (selection.selectionSet != null) {\n        return typeContainsSelectionSet(\n          getNamedType(field.type) as GraphQLObjectType,\n          selection.selectionSet,\n        );\n      }\n    } else if (selection.kind === Kind.INLINE_FRAGMENT) {\n      const containsSelectionSet = typeContainsSelectionSet(\n        type,\n        selection.selectionSet,\n      );\n      if (!containsSelectionSet) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n","import {\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  Kind,\n  SelectionNode,\n  SelectionSetNode,\n  isObjectType,\n  isScalarType,\n} from 'graphql';\n\nimport {\n  IDelegateToSchemaOptions,\n  MergeInfo,\n  IResolversParameter,\n  isSubschemaConfig,\n  SubschemaConfig,\n  IGraphQLToolsResolveInfo,\n  MergedTypeInfo,\n  Transform,\n  TypeMap,\n} from '../Interfaces';\nimport ExpandAbstractTypes from '../wrap/transforms/ExpandAbstractTypes';\nimport AddReplacementFragments from '../wrap/transforms/AddReplacementFragments';\nimport {\n  parseFragmentToInlineFragment,\n  concatInlineFragments,\n} from '../utils/fragments';\nimport {\n  typeContainsSelectionSet,\n  parseSelectionSet,\n} from '../utils/selectionSets';\n\nimport delegateToSchema from '../delegate/delegateToSchema';\nimport { hasOwnProperty } from '../esUtils/hasOwnProperty';\n\ntype MergeTypeCandidate = {\n  type: GraphQLNamedType;\n  schema?: GraphQLSchema;\n  subschema?: GraphQLSchema | SubschemaConfig;\n  transformedSubschema?: GraphQLSchema;\n};\n\nexport function createMergeInfo(\n  allSchemas: Array<GraphQLSchema>,\n  typeCandidates: { [name: string]: Array<MergeTypeCandidate> },\n  mergeTypes?:\n    | boolean\n    | Array<string>\n    | ((\n        typeName: string,\n        mergeTypeCandidates: Array<MergeTypeCandidate>,\n      ) => boolean),\n): MergeInfo {\n  return {\n    delegate(\n      operation: 'query' | 'mutation' | 'subscription',\n      fieldName: string,\n      args: { [key: string]: any },\n      context: { [key: string]: any },\n      info: IGraphQLToolsResolveInfo,\n      transforms: Array<Transform> = [],\n    ) {\n      const schema = guessSchemaByRootField(allSchemas, operation, fieldName);\n      const expandTransforms = new ExpandAbstractTypes(info.schema, schema);\n      const fragmentTransform = new AddReplacementFragments(\n        schema,\n        info.mergeInfo.replacementFragments,\n      );\n      return delegateToSchema({\n        schema,\n        operation,\n        fieldName,\n        args,\n        context,\n        info,\n        transforms: [...transforms, expandTransforms, fragmentTransform],\n      });\n    },\n\n    delegateToSchema(options: IDelegateToSchemaOptions) {\n      return delegateToSchema({\n        ...options,\n        transforms: options.transforms,\n      });\n    },\n    fragments: [],\n    replacementSelectionSets: undefined,\n    replacementFragments: undefined,\n    mergedTypes: createMergedTypes(typeCandidates, mergeTypes),\n  };\n}\n\nfunction createMergedTypes(\n  typeCandidates: { [name: string]: Array<MergeTypeCandidate> },\n  mergeTypes?:\n    | boolean\n    | Array<string>\n    | ((\n        typeName: string,\n        mergeTypeCandidates: Array<MergeTypeCandidate>,\n      ) => boolean),\n): Record<string, MergedTypeInfo> {\n  const mergedTypes: Record<string, MergedTypeInfo> = Object.create(null);\n\n  Object.keys(typeCandidates).forEach((typeName) => {\n    if (isObjectType(typeCandidates[typeName][0].type)) {\n      const mergedTypeCandidates = typeCandidates[typeName].filter(\n        (typeCandidate) =>\n          typeCandidate.subschema != null &&\n          isSubschemaConfig(typeCandidate.subschema) &&\n          typeCandidate.subschema.merge != null &&\n          hasOwnProperty(typeCandidate.subschema.merge, typeName),\n      );\n\n      if (\n        mergeTypes === true ||\n        (typeof mergeTypes === 'function' &&\n          mergeTypes(typeName, typeCandidates[typeName])) ||\n        (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\n        mergedTypeCandidates.length\n      ) {\n        const subschemas: Array<SubschemaConfig> = [];\n\n        let requiredSelections: Array<SelectionNode> = [\n          parseSelectionSet('{ __typename }').selections[0],\n        ];\n        const fields = Object.create({});\n        const typeMaps: Map<SubschemaConfig, TypeMap> = new Map();\n        const selectionSets: Map<SubschemaConfig, SelectionSetNode> = new Map();\n\n        mergedTypeCandidates.forEach((typeCandidate) => {\n          const subschemaConfig = typeCandidate.subschema as SubschemaConfig;\n          const transformedSubschema = typeCandidate.transformedSubschema;\n          typeMaps.set(subschemaConfig, transformedSubschema.getTypeMap());\n          const type = transformedSubschema.getType(\n            typeName,\n          ) as GraphQLObjectType;\n          const fieldMap = type.getFields();\n          Object.keys(fieldMap).forEach((fieldName) => {\n            if (!(fieldName in fields)) {\n              fields[fieldName] = [];\n            }\n            fields[fieldName].push(subschemaConfig);\n          });\n\n          const mergedTypeConfig = subschemaConfig.merge[typeName];\n\n          if (mergedTypeConfig.selectionSet) {\n            const selectionSet = parseSelectionSet(\n              mergedTypeConfig.selectionSet,\n            );\n            requiredSelections = requiredSelections.concat(\n              selectionSet.selections,\n            );\n            selectionSets.set(subschemaConfig, selectionSet);\n          }\n\n          if (!mergedTypeConfig.resolve) {\n            mergedTypeConfig.resolve = (\n              originalResult,\n              context,\n              info,\n              subschema,\n              selectionSet,\n            ) =>\n              delegateToSchema({\n                schema: subschema,\n                operation: 'query',\n                fieldName: mergedTypeConfig.fieldName,\n                args: mergedTypeConfig.args(originalResult),\n                selectionSet,\n                context,\n                info,\n                skipTypeMerging: true,\n              });\n          }\n\n          subschemas.push(subschemaConfig);\n        });\n\n        mergedTypes[typeName] = {\n          subschemas,\n          typeMaps,\n          selectionSets,\n          containsSelectionSet: new Map(),\n          uniqueFields: Object.create({}),\n          nonUniqueFields: Object.create({}),\n        };\n\n        subschemas.forEach((subschema) => {\n          const type = typeMaps.get(subschema)[typeName] as GraphQLObjectType;\n          const subschemaMap = new Map();\n          subschemas\n            .filter((s) => s !== subschema)\n            .forEach((s) => {\n              const selectionSet = selectionSets.get(s);\n              if (\n                selectionSet != null &&\n                typeContainsSelectionSet(type, selectionSet)\n              ) {\n                subschemaMap.set(selectionSet, true);\n              }\n            });\n          mergedTypes[typeName].containsSelectionSet.set(\n            subschema,\n            subschemaMap,\n          );\n        });\n\n        Object.keys(fields).forEach((fieldName) => {\n          const supportedBySubschemas = fields[fieldName];\n          if (supportedBySubschemas.length === 1) {\n            mergedTypes[typeName].uniqueFields[fieldName] =\n              supportedBySubschemas[0];\n          } else {\n            mergedTypes[typeName].nonUniqueFields[\n              fieldName\n            ] = supportedBySubschemas;\n          }\n        });\n\n        mergedTypes[typeName].selectionSet = {\n          kind: Kind.SELECTION_SET,\n          selections: requiredSelections,\n        };\n      }\n    }\n  });\n\n  return mergedTypes;\n}\n\nexport function completeMergeInfo(\n  mergeInfo: MergeInfo,\n  resolvers: IResolversParameter,\n): MergeInfo {\n  const replacementSelectionSets = Object.create(null);\n\n  Object.keys(resolvers).forEach((typeName) => {\n    const type = resolvers[typeName];\n    if (isScalarType(type)) {\n      return;\n    }\n    Object.keys(type).forEach((fieldName) => {\n      const field = type[fieldName];\n      if (field.selectionSet) {\n        const selectionSet = parseSelectionSet(field.selectionSet);\n        if (!(typeName in replacementSelectionSets)) {\n          replacementSelectionSets[typeName] = Object.create(null);\n        }\n\n        const typeReplacementSelectionSets = replacementSelectionSets[typeName];\n        if (!(fieldName in typeReplacementSelectionSets)) {\n          typeReplacementSelectionSets[fieldName] = {\n            kind: Kind.SELECTION_SET,\n            selections: [],\n          };\n        }\n        typeReplacementSelectionSets[\n          fieldName\n        ].selections = typeReplacementSelectionSets[\n          fieldName\n        ].selections.concat(selectionSet.selections);\n      }\n      if (field.fragment) {\n        mergeInfo.fragments.push({\n          field: fieldName,\n          fragment: field.fragment,\n        });\n      }\n    });\n  });\n\n  const mapping = Object.create(null);\n  mergeInfo.fragments.forEach(({ field, fragment }) => {\n    const parsedFragment = parseFragmentToInlineFragment(fragment);\n    const actualTypeName = parsedFragment.typeCondition.name.value;\n    if (!(actualTypeName in mapping)) {\n      mapping[actualTypeName] = Object.create(null);\n    }\n\n    const typeMapping = mapping[actualTypeName];\n    if (!(field in typeMapping)) {\n      typeMapping[field] = [];\n    }\n    typeMapping[field].push(parsedFragment);\n  });\n\n  const replacementFragments = Object.create(null);\n  Object.keys(mapping).forEach((typeName) => {\n    Object.keys(mapping[typeName]).forEach((field) => {\n      if (!(typeName in replacementFragments)) {\n        replacementFragments[typeName] = Object.create(null);\n      }\n\n      const typeReplacementFragments = replacementFragments[typeName];\n      typeReplacementFragments[field] = concatInlineFragments(\n        typeName,\n        mapping[typeName][field],\n      );\n    });\n  });\n\n  mergeInfo.replacementSelectionSets = replacementSelectionSets;\n  mergeInfo.replacementFragments = replacementFragments;\n\n  return mergeInfo;\n}\n\nfunction operationToRootType(\n  operation: 'query' | 'mutation' | 'subscription',\n  schema: GraphQLSchema,\n): GraphQLObjectType {\n  if (operation === 'subscription') {\n    return schema.getSubscriptionType();\n  } else if (operation === 'mutation') {\n    return schema.getMutationType();\n  }\n\n  return schema.getQueryType();\n}\n\nfunction guessSchemaByRootField(\n  schemas: Array<GraphQLSchema>,\n  operation: 'query' | 'mutation' | 'subscription',\n  fieldName: string,\n): GraphQLSchema {\n  for (const schema of schemas) {\n    const rootObject = operationToRootType(operation, schema);\n    if (rootObject != null) {\n      const fields = rootObject.getFields();\n      if (fieldName in fields) {\n        return schema;\n      }\n    }\n  }\n  throw new Error(\n    `Could not find subschema with field \\`${operation}.${fieldName}\\``,\n  );\n}\n","import {\n  DocumentNode,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  getNamedType,\n  isNamedType,\n  parse,\n  Kind,\n  GraphQLDirective,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLEnumType,\n  ASTNode,\n  isSchema,\n  isDirective,\n  isScalarType,\n  isObjectType,\n  isInterfaceType,\n  isUnionType,\n  isEnumType,\n} from 'graphql';\n\nimport {\n  OnTypeConflict,\n  IResolversParameter,\n  isSubschemaConfig,\n  SchemaLikeObject,\n  IResolvers,\n  SubschemaConfig,\n} from '../Interfaces';\nimport {\n  extractExtensionDefinitions,\n  addResolversToSchema,\n} from '../generate/index';\nimport { wrapSchema } from '../wrap/wrapSchema';\nimport {\n  SchemaDirectiveVisitor,\n  cloneDirective,\n  healTypes,\n  forEachField,\n  graphqlVersion,\n} from '../utils/index';\nimport { mergeDeep } from '../esUtils/mergeDeep';\nimport { toConfig, extendSchema } from '../polyfills/index';\n\nimport typeFromAST from './typeFromAST';\nimport { createMergeInfo, completeMergeInfo } from './mergeInfo';\n\ntype MergeTypeCandidate = {\n  type: GraphQLNamedType;\n  schema?: GraphQLSchema;\n  subschema?: GraphQLSchema | SubschemaConfig;\n  transformedSubschema?: GraphQLSchema;\n};\n\ntype CandidateSelector = (\n  candidates: Array<MergeTypeCandidate>,\n) => MergeTypeCandidate;\n\nexport default function mergeSchemas({\n  subschemas = [],\n  types = [],\n  typeDefs,\n  schemas: schemaLikeObjects = [],\n  onTypeConflict,\n  resolvers = {},\n  schemaDirectives,\n  inheritResolversFromInterfaces,\n  mergeTypes = false,\n  mergeDirectives,\n  queryTypeName = 'Query',\n  mutationTypeName = 'Mutation',\n  subscriptionTypeName = 'Subscription',\n}: {\n  subschemas?: Array<GraphQLSchema | SubschemaConfig>;\n  types?: Array<GraphQLNamedType>;\n  typeDefs?: string | DocumentNode;\n  schemas?: Array<SchemaLikeObject>;\n  onTypeConflict?: OnTypeConflict;\n  resolvers?: IResolversParameter;\n  schemaDirectives?: { [name: string]: typeof SchemaDirectiveVisitor };\n  inheritResolversFromInterfaces?: boolean;\n  mergeTypes?:\n    | boolean\n    | Array<string>\n    | ((\n        typeName: string,\n        mergeTypeCandidates: Array<MergeTypeCandidate>,\n      ) => boolean);\n  mergeDirectives?: boolean;\n  queryTypeName?: string;\n  mutationTypeName?: string;\n  subscriptionTypeName?: string;\n}): GraphQLSchema {\n  const allSchemas: Array<GraphQLSchema> = [];\n  const typeCandidates: Record<\n    string,\n    Array<MergeTypeCandidate>\n  > = Object.create(null);\n  const typeMap: Record<string, GraphQLNamedType> = Object.create(null);\n  const extensions: Array<DocumentNode> = [];\n  const directives: Array<GraphQLDirective> = [];\n\n  let schemas: Array<SchemaLikeObject> = [...subschemas];\n  if (typeDefs) {\n    schemas.push(typeDefs);\n  }\n  if (types != null) {\n    schemas.push(types);\n  }\n  schemas = [...schemas, ...schemaLikeObjects];\n\n  schemas.forEach((schemaLikeObject) => {\n    if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n      const schema = wrapSchema(schemaLikeObject);\n\n      allSchemas.push(schema);\n\n      const operationTypes = {\n        [queryTypeName]: schema.getQueryType(),\n        [mutationTypeName]: schema.getMutationType(),\n        [subscriptionTypeName]: schema.getSubscriptionType(),\n      };\n\n      Object.keys(operationTypes).forEach((typeName) => {\n        if (operationTypes[typeName] != null) {\n          addTypeCandidate(typeCandidates, typeName, {\n            schema,\n            type: operationTypes[typeName],\n            subschema: schemaLikeObject,\n            transformedSubschema: schema,\n          });\n        }\n      });\n\n      if (mergeDirectives) {\n        const directiveInstances = schema.getDirectives();\n        directiveInstances.forEach((directive) => {\n          directives.push(directive);\n        });\n      }\n\n      const originalTypeMap = schema.getTypeMap();\n      Object.keys(originalTypeMap).forEach((typeName) => {\n        const type: GraphQLNamedType = originalTypeMap[typeName];\n        if (\n          isNamedType(type) &&\n          getNamedType(type).name.slice(0, 2) !== '__' &&\n          type !== operationTypes.Query &&\n          type !== operationTypes.Mutation &&\n          type !== operationTypes.Subscription\n        ) {\n          addTypeCandidate(typeCandidates, type.name, {\n            schema,\n            type,\n            subschema: schemaLikeObject,\n            transformedSubschema: schema,\n          });\n        }\n      });\n    } else if (\n      typeof schemaLikeObject === 'string' ||\n      (schemaLikeObject != null &&\n        (schemaLikeObject as ASTNode).kind === Kind.DOCUMENT)\n    ) {\n      const parsedSchemaDocument =\n        typeof schemaLikeObject === 'string'\n          ? parse(schemaLikeObject)\n          : (schemaLikeObject as DocumentNode);\n\n      parsedSchemaDocument.definitions.forEach((def) => {\n        const type = typeFromAST(def);\n        if (isDirective(type) && mergeDirectives) {\n          directives.push(type);\n        } else if (type != null && !isDirective(type)) {\n          addTypeCandidate(typeCandidates, type.name, {\n            type,\n          });\n        }\n      });\n\n      const extensionsDocument = extractExtensionDefinitions(\n        parsedSchemaDocument,\n      );\n      if (extensionsDocument.definitions.length > 0) {\n        extensions.push(extensionsDocument);\n      }\n    } else if (Array.isArray(schemaLikeObject)) {\n      schemaLikeObject.forEach((type) => {\n        addTypeCandidate(typeCandidates, type.name, {\n          type,\n        });\n      });\n    } else {\n      throw new Error('Invalid schema passed');\n    }\n  });\n\n  let mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);\n\n  let finalResolvers: IResolvers;\n  if (typeof resolvers === 'function') {\n    finalResolvers = resolvers(mergeInfo);\n  } else if (Array.isArray(resolvers)) {\n    finalResolvers = resolvers.reduce(\n      (left, right) =>\n        mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right),\n      {},\n    );\n    if (Array.isArray(resolvers)) {\n      finalResolvers = resolvers.reduce(mergeDeep, {});\n    }\n  } else {\n    finalResolvers = resolvers;\n  }\n\n  if (finalResolvers == null) {\n    finalResolvers = {};\n  }\n\n  mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);\n\n  Object.keys(typeCandidates).forEach((typeName) => {\n    if (\n      typeName === queryTypeName ||\n      typeName === mutationTypeName ||\n      typeName === subscriptionTypeName ||\n      (mergeTypes === true &&\n        !isScalarType(typeCandidates[typeName][0].type)) ||\n      (typeof mergeTypes === 'function' &&\n        mergeTypes(typeName, typeCandidates[typeName])) ||\n      (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\n      typeName in mergeInfo.mergedTypes\n    ) {\n      typeMap[typeName] = merge(typeName, typeCandidates[typeName]);\n    } else {\n      const candidateSelector =\n        onTypeConflict != null\n          ? onTypeConflictToCandidateSelector(onTypeConflict)\n          : (cands: Array<MergeTypeCandidate>) => cands[cands.length - 1];\n      typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\n    }\n  });\n\n  healTypes(typeMap, directives, { skipPruning: true });\n\n  let mergedSchema = new GraphQLSchema({\n    query: typeMap[queryTypeName] as GraphQLObjectType,\n    mutation: typeMap[mutationTypeName] as GraphQLObjectType,\n    subscription: typeMap[subscriptionTypeName] as GraphQLObjectType,\n    types: Object.keys(typeMap).map((key) => typeMap[key]),\n    directives: directives.length\n      ? directives.map((directive) => cloneDirective(directive))\n      : undefined,\n  });\n\n  extensions.forEach((extension) => {\n    mergedSchema = extendSchema(mergedSchema, extension, {\n      commentDescriptions: true,\n    });\n  });\n\n  addResolversToSchema({\n    schema: mergedSchema,\n    resolvers: finalResolvers,\n    inheritResolversFromInterfaces,\n  });\n\n  forEachField(mergedSchema, (field) => {\n    if (field.resolve != null) {\n      const fieldResolver = field.resolve;\n      field.resolve = (parent, args, context, info) => {\n        const newInfo = { ...info, mergeInfo };\n        return fieldResolver(parent, args, context, newInfo);\n      };\n    }\n    if (field.subscribe != null) {\n      const fieldResolver = field.subscribe;\n      field.subscribe = (parent, args, context, info) => {\n        const newInfo = { ...info, mergeInfo };\n        return fieldResolver(parent, args, context, newInfo);\n      };\n    }\n  });\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(\n      mergedSchema,\n      schemaDirectives,\n    );\n  }\n\n  return mergedSchema;\n}\n\nfunction addTypeCandidate(\n  typeCandidates: Record<string, Array<MergeTypeCandidate>>,\n  name: string,\n  typeCandidate: MergeTypeCandidate,\n) {\n  if (!(name in typeCandidates)) {\n    typeCandidates[name] = [];\n  }\n  typeCandidates[name].push(typeCandidate);\n}\n\nfunction onTypeConflictToCandidateSelector(\n  onTypeConflict: OnTypeConflict,\n): CandidateSelector {\n  return (cands) =>\n    cands.reduce((prev, next) => {\n      const type = onTypeConflict(prev.type, next.type, {\n        left: {\n          schema: prev.schema,\n        },\n        right: {\n          schema: next.schema,\n        },\n      });\n      if (prev.type === type) {\n        return prev;\n      } else if (next.type === type) {\n        return next;\n      }\n      return {\n        schemaName: 'unknown',\n        type,\n      };\n    });\n}\n\nfunction merge(\n  typeName: string,\n  candidates: Array<MergeTypeCandidate>,\n): GraphQLNamedType {\n  const initialCandidateType = candidates[0].type;\n  if (\n    candidates.some(\n      (candidate) =>\n        candidate.type.constructor !== initialCandidateType.constructor,\n    )\n  ) {\n    throw new Error(\n      `Cannot merge different type categories into common type ${typeName}.`,\n    );\n  }\n  if (isObjectType(initialCandidateType)) {\n    return new GraphQLObjectType({\n      name: typeName,\n      fields: candidates.reduce(\n        (acc, candidate) => ({\n          ...acc,\n          ...toConfig(candidate.type).fields,\n        }),\n        {},\n      ),\n      interfaces: candidates.reduce((acc, candidate) => {\n        const interfaces = toConfig(candidate.type).interfaces;\n        return interfaces != null ? acc.concat(interfaces) : acc;\n      }, []),\n    });\n  } else if (isInterfaceType(initialCandidateType)) {\n    const config = {\n      name: typeName,\n      fields: candidates.reduce(\n        (acc, candidate) => ({\n          ...acc,\n          ...toConfig(candidate.type).fields,\n        }),\n        {},\n      ),\n      interfaces:\n        graphqlVersion() >= 15\n          ? candidates.reduce((acc, candidate) => {\n              const interfaces = toConfig(candidate.type).interfaces;\n              return interfaces != null ? acc.concat(interfaces) : acc;\n            }, [])\n          : undefined,\n    };\n    return new GraphQLInterfaceType(config);\n  } else if (isUnionType(initialCandidateType)) {\n    return new GraphQLUnionType({\n      name: typeName,\n      types: candidates.reduce(\n        (acc, candidate) => acc.concat(toConfig(candidate.type).types),\n        [],\n      ),\n    });\n  } else if (isEnumType(initialCandidateType)) {\n    return new GraphQLEnumType({\n      name: typeName,\n      values: candidates.reduce(\n        (acc, candidate) => ({\n          ...acc,\n          ...toConfig(candidate.type).values,\n        }),\n        {},\n      ),\n    });\n  } else if (isScalarType(initialCandidateType)) {\n    throw new Error(\n      `Cannot merge type ${typeName}. Merging not supported for GraphQLScalarType.`,\n    );\n  } else {\n    // not reachable.\n    throw new Error(`Type ${typeName} has unknown GraphQL type.`);\n  }\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport {\n  Transform,\n  SubschemaConfig,\n  GraphQLSchemaWithTransforms,\n} from '../Interfaces';\n\nimport { wrapSchema } from './wrapSchema';\n\n// This function is deprecated in favor of wrapSchema as the name is misleading.\n// transformSchema does not just \"transform\" a schema, it wraps a schema with transforms\n// using a round of delegation.\n// The applySchemaTransforms function actually \"transforms\" the schema and is used during wrapping.\nexport function transformSchema(\n  subschemaOrSubschemaConfig: GraphQLSchema | SubschemaConfig,\n  transforms: Array<Transform>,\n): GraphQLSchemaWithTransforms {\n  const schema: GraphQLSchemaWithTransforms = wrapSchema(\n    subschemaOrSubschemaConfig,\n    transforms,\n  );\n\n  schema.transforms = transforms.slice().reverse();\n  return schema;\n}\n","import {\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLNamedType,\n  GraphQLObjectType,\n  GraphQLSchema,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  Kind,\n  NamedTypeNode,\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n  visit,\n} from 'graphql';\n\nimport { isSpecifiedScalarType, toConfig } from '../../polyfills/index';\nimport {\n  Transform,\n  Request,\n  ExecutionResult,\n  MapperKind,\n  RenameTypesOptions,\n} from '../../Interfaces';\nimport { mapSchema } from '../../utils/index';\n\nexport default class RenameTypes implements Transform {\n  private readonly renamer: (name: string) => string | undefined;\n  private map: Record<string, string>;\n  private reverseMap: Record<string, string>;\n  private readonly renameBuiltins: boolean;\n  private readonly renameScalars: boolean;\n\n  constructor(\n    renamer: (name: string) => string | undefined,\n    options?: RenameTypesOptions,\n  ) {\n    this.renamer = renamer;\n    this.map = Object.create(null);\n    this.reverseMap = Object.create(null);\n    const { renameBuiltins = false, renameScalars = true } =\n      options != null ? options : {};\n    this.renameBuiltins = renameBuiltins;\n    this.renameScalars = renameScalars;\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return mapSchema(originalSchema, {\n      [MapperKind.TYPE]: (type: GraphQLNamedType) => {\n        if (isSpecifiedScalarType(type) && !this.renameBuiltins) {\n          return undefined;\n        }\n        if (isScalarType(type) && !this.renameScalars) {\n          return undefined;\n        }\n        const oldName = type.name;\n        const newName = this.renamer(oldName);\n        if (newName !== undefined && newName !== oldName) {\n          this.map[oldName] = newName;\n          this.reverseMap[newName] = oldName;\n\n          const newConfig = {\n            ...toConfig(type),\n            name: newName,\n          };\n\n          if (isObjectType(type)) {\n            return new GraphQLObjectType(newConfig);\n          } else if (isInterfaceType(type)) {\n            return new GraphQLInterfaceType(newConfig);\n          } else if (isUnionType(type)) {\n            return new GraphQLUnionType(newConfig);\n          } else if (isInputObjectType(type)) {\n            return new GraphQLInputObjectType(newConfig);\n          } else if (isEnumType(type)) {\n            return new GraphQLEnumType(newConfig);\n          } else if (isScalarType(type)) {\n            return new GraphQLScalarType(newConfig);\n          }\n\n          throw new Error(`Unknown type ${type as string}.`);\n        }\n      },\n\n      [MapperKind.ROOT_OBJECT]() {\n        return undefined;\n      },\n    });\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const newDocument = visit(originalRequest.document, {\n      [Kind.NAMED_TYPE]: (node: NamedTypeNode) => {\n        const name = node.name.value;\n        if (name in this.reverseMap) {\n          return {\n            ...node,\n            name: {\n              kind: Kind.NAME,\n              value: this.reverseMap[name],\n            },\n          };\n        }\n      },\n    });\n    return {\n      document: newDocument,\n      variables: originalRequest.variables,\n    };\n  }\n\n  public transformResult(result: ExecutionResult): ExecutionResult {\n    return {\n      ...result,\n      data: this.transformData(result.data),\n    };\n  }\n\n  private transformData(data: any): any {\n    if (data == null) {\n      return data;\n    } else if (Array.isArray(data)) {\n      return data.map((value) => this.transformData(value));\n    } else if (typeof data === 'object') {\n      return this.transformObject(data);\n    }\n\n    return data;\n  }\n\n  private transformObject(object: Record<string, any>): Record<string, any> {\n    Object.keys(object).forEach((key) => {\n      const value = object[key];\n      if (key === '__typename') {\n        if (value in this.map) {\n          object[key] = this.map[value];\n        }\n      } else {\n        object[key] = this.transformData(value);\n      }\n    });\n\n    return object;\n  }\n}\n","import { GraphQLSchema, GraphQLNamedType } from 'graphql';\n\nimport { mapSchema } from '../../utils/index';\nimport { Transform, MapperKind } from '../../Interfaces';\n\nexport default class FilterTypes implements Transform {\n  private readonly filter: (type: GraphQLNamedType) => boolean;\n\n  constructor(filter: (type: GraphQLNamedType) => boolean) {\n    this.filter = filter;\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    return mapSchema(schema, {\n      [MapperKind.TYPE]: (type: GraphQLNamedType) => {\n        if (this.filter(type)) {\n          return undefined;\n        }\n\n        return null;\n      },\n    });\n  }\n}\n","import {\n  visit,\n  GraphQLSchema,\n  NamedTypeNode,\n  Kind,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport {\n  Request,\n  ExecutionResult,\n  MapperKind,\n  Transform,\n} from '../../Interfaces';\nimport { mapSchema } from '../../utils/index';\nimport { toConfig } from '../../polyfills/index';\n\nexport default class RenameRootTypes implements Transform {\n  private readonly renamer: (name: string) => string | undefined;\n  private map: { [key: string]: string };\n  private reverseMap: { [key: string]: string };\n\n  constructor(renamer: (name: string) => string | undefined) {\n    this.renamer = renamer;\n    this.map = Object.create(null);\n    this.reverseMap = Object.create(null);\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return mapSchema(originalSchema, {\n      [MapperKind.ROOT_OBJECT]: (type) => {\n        const oldName = type.name;\n        const newName = this.renamer(oldName);\n        if (newName !== undefined && newName !== oldName) {\n          this.map[oldName] = newName;\n          this.reverseMap[newName] = oldName;\n          return new GraphQLObjectType({\n            ...toConfig(type),\n            name: newName,\n          });\n        }\n      },\n    });\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const newDocument = visit(originalRequest.document, {\n      [Kind.NAMED_TYPE]: (node: NamedTypeNode) => {\n        const name = node.name.value;\n        if (name in this.reverseMap) {\n          return {\n            ...node,\n            name: {\n              kind: Kind.NAME,\n              value: this.reverseMap[name],\n            },\n          };\n        }\n      },\n    });\n    return {\n      document: newDocument,\n      variables: originalRequest.variables,\n    };\n  }\n\n  public transformResult(result: ExecutionResult): ExecutionResult {\n    return {\n      ...result,\n      data: this.transformData(result.data),\n    };\n  }\n\n  private transformData(data: any): any {\n    if (data == null) {\n      return data;\n    } else if (Array.isArray(data)) {\n      return data.map((value) => this.transformData(value));\n    } else if (typeof data === 'object') {\n      return this.transformObject(data);\n    }\n\n    return data;\n  }\n\n  private transformObject(object: Record<string, any>): Record<string, any> {\n    Object.keys(object).forEach((key) => {\n      const value = object[key];\n      if (key === '__typename') {\n        if (value in this.map) {\n          object[key] = this.map[value];\n        }\n      } else {\n        object[key] = this.transformData(value);\n      }\n    });\n\n    return object;\n  }\n}\n","export default function isEmptyObject(obj: Record<string, any>): boolean {\n  if (obj == null) {\n    return true;\n  }\n\n  return Object.keys(obj).length === 0;\n}\n","import {\n  GraphQLSchema,\n  GraphQLType,\n  DocumentNode,\n  TypeInfo,\n  visit,\n  visitWithTypeInfo,\n  Kind,\n  SelectionSetNode,\n  SelectionNode,\n  FragmentDefinitionNode,\n  GraphQLInterfaceType,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n} from 'graphql';\n\nimport isEmptyObject from '../../esUtils/isEmptyObject';\nimport {\n  Transform,\n  Request,\n  MapperKind,\n  FieldTransformer,\n  FieldNodeTransformer,\n  RenamedFieldConfig,\n} from '../../Interfaces';\nimport { mapSchema } from '../../utils/index';\nimport { toConfig } from '../../polyfills/index';\n\nexport default class TransformCompositeFields implements Transform {\n  private readonly fieldTransformer: FieldTransformer;\n  private readonly fieldNodeTransformer: FieldNodeTransformer;\n  private transformedSchema: GraphQLSchema;\n  private mapping: Record<string, Record<string, string>>;\n\n  constructor(\n    fieldTransformer: FieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    this.fieldTransformer = fieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n    this.mapping = {};\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    this.transformedSchema = mapSchema(originalSchema, {\n      [MapperKind.OBJECT_TYPE]: (type: GraphQLObjectType) =>\n        this.transformFields(type, this.fieldTransformer),\n      [MapperKind.INTERFACE_TYPE]: (type: GraphQLInterfaceType) =>\n        this.transformFields(type, this.fieldTransformer),\n    });\n\n    return this.transformedSchema;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const fragments = Object.create(null);\n    originalRequest.document.definitions\n      .filter((def) => def.kind === Kind.FRAGMENT_DEFINITION)\n      .forEach((def) => {\n        fragments[(def as FragmentDefinitionNode).name.value] = def;\n      });\n    const document = this.transformDocument(\n      originalRequest.document,\n      this.mapping,\n      this.fieldNodeTransformer,\n      fragments,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n\n  private transformFields(\n    type: GraphQLObjectType,\n    fieldTransformer: FieldTransformer,\n  ): GraphQLObjectType;\n\n  private transformFields(\n    type: GraphQLInterfaceType,\n    fieldTransformer: FieldTransformer,\n  ): GraphQLInterfaceType;\n\n  private transformFields(type: any, fieldTransformer: FieldTransformer): any {\n    const typeConfig = toConfig(type);\n    const fields = type.getFields();\n    const newFields = {};\n\n    Object.keys(fields).forEach((fieldName) => {\n      const field = fields[fieldName];\n      const transformedField = fieldTransformer(type.name, fieldName, field);\n\n      if (typeof transformedField === 'undefined') {\n        newFields[fieldName] = typeConfig.fields[fieldName];\n      } else if (transformedField !== null) {\n        const newName = (transformedField as RenamedFieldConfig).name;\n\n        if (newName) {\n          newFields[newName] =\n            (transformedField as RenamedFieldConfig).field != null\n              ? (transformedField as RenamedFieldConfig).field\n              : typeConfig.fields[fieldName];\n\n          if (newName !== fieldName) {\n            const typeName = type.name;\n            if (!(typeName in this.mapping)) {\n              this.mapping[typeName] = {};\n            }\n            this.mapping[typeName][newName] = fieldName;\n          }\n        } else {\n          newFields[fieldName] = transformedField;\n        }\n      }\n    });\n\n    if (isEmptyObject(newFields)) {\n      return null;\n    }\n\n    if (isObjectType(type)) {\n      return new GraphQLObjectType({\n        ...toConfig(type),\n        fields: newFields,\n      });\n    } else if (isInterfaceType(type)) {\n      return new GraphQLInterfaceType({\n        ...toConfig(type),\n        fields: newFields,\n      });\n    }\n  }\n\n  private transformDocument(\n    document: DocumentNode,\n    mapping: Record<string, Record<string, string>>,\n    fieldNodeTransformer?: FieldNodeTransformer,\n    fragments: Record<string, FragmentDefinitionNode> = {},\n  ): DocumentNode {\n    const typeInfo = new TypeInfo(this.transformedSchema);\n    const newDocument: DocumentNode = visit(\n      document,\n      visitWithTypeInfo(typeInfo, {\n        leave: {\n          [Kind.SELECTION_SET]: (node: SelectionSetNode): SelectionSetNode => {\n            const parentType: GraphQLType = typeInfo.getParentType();\n            if (parentType != null) {\n              const parentTypeName = parentType.name;\n              let newSelections: Array<SelectionNode> = [];\n\n              node.selections.forEach((selection) => {\n                if (selection.kind !== Kind.FIELD) {\n                  newSelections.push(selection);\n                  return;\n                }\n\n                const newName = selection.name.value;\n\n                const transformedSelection =\n                  fieldNodeTransformer != null\n                    ? fieldNodeTransformer(\n                        parentTypeName,\n                        newName,\n                        selection,\n                        fragments,\n                      )\n                    : selection;\n\n                if (Array.isArray(transformedSelection)) {\n                  newSelections = newSelections.concat(transformedSelection);\n                  return;\n                }\n\n                if (transformedSelection.kind !== Kind.FIELD) {\n                  newSelections.push(transformedSelection);\n                  return;\n                }\n\n                const typeMapping = mapping[parentTypeName];\n                if (typeMapping == null) {\n                  newSelections.push(transformedSelection);\n                  return;\n                }\n\n                const oldName = mapping[parentTypeName][newName];\n                if (oldName == null) {\n                  newSelections.push(transformedSelection);\n                  return;\n                }\n\n                newSelections.push({\n                  ...transformedSelection,\n                  name: {\n                    kind: Kind.NAME,\n                    value: oldName,\n                  },\n                  alias: {\n                    kind: Kind.NAME,\n                    value: newName,\n                  },\n                });\n              });\n\n              return {\n                ...node,\n                selections: newSelections,\n              };\n            }\n          },\n        },\n      }),\n    );\n    return newDocument;\n  }\n}\n","import { GraphQLSchema, GraphQLField, isObjectType } from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  FieldTransformer,\n  FieldNodeTransformer,\n} from '../../Interfaces';\n\nimport TransformCompositeFields from './TransformCompositeFields';\n\nexport default class TransformObjectFields implements Transform {\n  private readonly objectFieldTransformer: FieldTransformer;\n  private readonly fieldNodeTransformer: FieldNodeTransformer;\n  private transformer: TransformCompositeFields;\n\n  constructor(\n    objectFieldTransformer: FieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    this.objectFieldTransformer = objectFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    const compositeToObjectFieldTransformer = (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => {\n      if (isObjectType(originalSchema.getType(typeName))) {\n        return this.objectFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(\n      compositeToObjectFieldTransformer,\n      this.fieldNodeTransformer,\n    );\n\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema, GraphQLField } from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  FieldNodeTransformer,\n  RootFieldTransformer,\n} from '../../Interfaces';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport default class TransformRootFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(\n    rootFieldTransformer: RootFieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    const rootToObjectFieldTransformer = (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => {\n      if (\n        typeName === 'Query' ||\n        typeName === 'Mutation' ||\n        typeName === 'Subscription'\n      ) {\n        return rootFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n    this.transformer = new TransformObjectFields(\n      rootToObjectFieldTransformer,\n      fieldNodeTransformer,\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport TransformRootFields from './TransformRootFields';\n\nexport default class RenameRootFields implements Transform {\n  private readonly transformer: TransformRootFields;\n\n  constructor(\n    renamer: (\n      operation: 'Query' | 'Mutation' | 'Subscription',\n      name: string,\n      field: GraphQLField<any, any>,\n    ) => string,\n  ) {\n    this.transformer = new TransformRootFields(\n      (\n        operation: 'Query' | 'Mutation' | 'Subscription',\n        fieldName: string,\n        field: GraphQLField<any, any>,\n      ) => ({\n        name: renamer(operation, fieldName, field),\n      }),\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, RootFieldFilter } from '../../Interfaces';\n\nimport TransformRootFields from './TransformRootFields';\n\nexport default class FilterRootFields implements Transform {\n  private readonly transformer: TransformRootFields;\n\n  constructor(filter: RootFieldFilter) {\n    this.transformer = new TransformRootFields(\n      (\n        operation: 'Query' | 'Mutation' | 'Subscription',\n        fieldName: string,\n        field: GraphQLField<any, any>,\n      ) => {\n        if (filter(operation, fieldName, field)) {\n          return undefined;\n        }\n\n        return null;\n      },\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport default class RenameObjectFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(\n    renamer: (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => string,\n  ) {\n    this.transformer = new TransformObjectFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) => ({\n        name: renamer(typeName, fieldName, field),\n      }),\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, FieldFilter } from '../../Interfaces';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport default class FilterObjectFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(filter: FieldFilter) {\n    this.transformer = new TransformObjectFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) =>\n        filter(typeName, fieldName, field) ? undefined : null,\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n}\n","import { GraphQLSchema, GraphQLField, isInterfaceType } from 'graphql';\n\nimport {\n  Transform,\n  Request,\n  FieldTransformer,\n  FieldNodeTransformer,\n} from '../../Interfaces';\n\nimport TransformCompositeFields from './TransformCompositeFields';\n\nexport default class TransformInterfaceFields implements Transform {\n  private readonly interfaceFieldTransformer: FieldTransformer;\n  private readonly fieldNodeTransformer: FieldNodeTransformer;\n  private transformer: TransformCompositeFields;\n\n  constructor(\n    interfaceFieldTransformer: FieldTransformer,\n    fieldNodeTransformer?: FieldNodeTransformer,\n  ) {\n    this.interfaceFieldTransformer = interfaceFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    const compositeToObjectFieldTransformer = (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => {\n      if (isInterfaceType(originalSchema.getType(typeName))) {\n        return this.interfaceFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(\n      compositeToObjectFieldTransformer,\n      this.fieldNodeTransformer,\n    );\n\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport TransformInterfaceFields from './TransformInterfaceFields';\n\nexport default class RenameInterfaceFields implements Transform {\n  private readonly transformer: TransformInterfaceFields;\n\n  constructor(\n    renamer: (\n      typeName: string,\n      fieldName: string,\n      field: GraphQLField<any, any>,\n    ) => string,\n  ) {\n    this.transformer = new TransformInterfaceFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) => ({\n        name: renamer(typeName, fieldName, field),\n      }),\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLField, GraphQLSchema } from 'graphql';\n\nimport { Transform, FieldFilter } from '../../Interfaces';\n\nimport TransformInterfaceFields from './TransformInterfaceFields';\n\nexport default class FilterInterfaceFields implements Transform {\n  private readonly transformer: TransformInterfaceFields;\n\n  constructor(filter: FieldFilter) {\n    this.transformer = new TransformInterfaceFields(\n      (typeName: string, fieldName: string, field: GraphQLField<any, any>) =>\n        filter(typeName, fieldName, field) ? undefined : null,\n    );\n  }\n\n  public transformSchema(originalSchema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(originalSchema);\n  }\n}\n","import {\n  visit,\n  Kind,\n  SelectionSetNode,\n  FragmentDefinitionNode,\n  GraphQLError,\n} from 'graphql';\n\nimport { Transform, Request, ExecutionResult } from '../../Interfaces';\n\nexport type QueryTransformer = (\n  selectionSet: SelectionSetNode,\n  fragments: Record<string, FragmentDefinitionNode>,\n) => SelectionSetNode;\n\nexport type ResultTransformer = (result: any) => any;\n\nexport type ErrorPathTransformer = (\n  path: ReadonlyArray<string | number>,\n) => Array<string | number>;\n\nexport default class TransformQuery implements Transform {\n  private readonly path: Array<string>;\n  private readonly queryTransformer: QueryTransformer;\n  private readonly resultTransformer: ResultTransformer;\n  private readonly errorPathTransformer: ErrorPathTransformer;\n  private readonly fragments: Record<string, FragmentDefinitionNode>;\n\n  constructor({\n    path,\n    queryTransformer,\n    resultTransformer = (result) => result,\n    errorPathTransformer = (errorPath) => [].concat(errorPath),\n    fragments = {},\n  }: {\n    path: Array<string>;\n    queryTransformer: QueryTransformer;\n    resultTransformer?: ResultTransformer;\n    errorPathTransformer?: ErrorPathTransformer;\n    fragments?: Record<string, FragmentDefinitionNode>;\n  }) {\n    this.path = path;\n    this.queryTransformer = queryTransformer;\n    this.resultTransformer = resultTransformer;\n    this.errorPathTransformer = errorPathTransformer;\n    this.fragments = fragments;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = originalRequest.document;\n\n    const pathLength = this.path.length;\n    let index = 0;\n    const newDocument = visit(document, {\n      [Kind.FIELD]: {\n        enter: (node) => {\n          if (index === pathLength || node.name.value !== this.path[index]) {\n            return false;\n          }\n\n          index++;\n\n          if (index === pathLength) {\n            const selectionSet = this.queryTransformer(\n              node.selectionSet,\n              this.fragments,\n            );\n\n            return {\n              ...node,\n              selectionSet,\n            };\n          }\n        },\n        leave: () => {\n          index--;\n        },\n      },\n    });\n    return {\n      ...originalRequest,\n      document: newDocument,\n    };\n  }\n\n  public transformResult(originalResult: ExecutionResult): ExecutionResult {\n    const data = this.transformData(originalResult.data);\n    const errors = originalResult.errors;\n    return {\n      data,\n      errors: errors != null ? this.transformErrors(errors) : undefined,\n    };\n  }\n\n  private transformData(data: any): any {\n    const leafIndex = this.path.length - 1;\n    let index = 0;\n    let newData = data;\n    if (newData) {\n      let next = this.path[index];\n      while (index < leafIndex) {\n        if (data[next]) {\n          newData = newData[next];\n        } else {\n          break;\n        }\n        index++;\n        next = this.path[index];\n      }\n      newData[next] = this.resultTransformer(newData[next]);\n    }\n    return newData;\n  }\n\n  private transformErrors(\n    errors: ReadonlyArray<GraphQLError>,\n  ): ReadonlyArray<GraphQLError> {\n    return errors.map((error) => {\n      const path: ReadonlyArray<string | number> = error.path;\n\n      let match = true;\n      let index = 0;\n      while (index < this.path.length) {\n        if (path[index] !== this.path[index]) {\n          match = false;\n          break;\n        }\n        index++;\n      }\n\n      const newPath = match\n        ? path\n            .slice(0, index)\n            .concat(this.errorPathTransformer(path.slice(index)))\n        : path;\n\n      return new GraphQLError(\n        error.message,\n        error.nodes,\n        error.source,\n        error.positions,\n        newPath,\n        error.originalError,\n        error.extensions,\n      );\n    });\n  }\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Transform, Request, FieldNodeMappers } from '../../Interfaces';\nimport { toConfig } from '../../polyfills/index';\n\nimport TransformObjectFields from './TransformObjectFields';\n\nexport default class MapFields implements Transform {\n  private readonly transformer: TransformObjectFields;\n\n  constructor(fieldNodeTransformerMap: FieldNodeMappers) {\n    this.transformer = new TransformObjectFields(\n      (_typeName, _fieldName, field) => toConfig(field),\n      (typeName, fieldName, fieldNode, fragments) => {\n        const typeTransformers = fieldNodeTransformerMap[typeName];\n        if (typeTransformers == null) {\n          return fieldNode;\n        }\n\n        const fieldNodeTransformer = typeTransformers[fieldName];\n        if (fieldNodeTransformer == null) {\n          return fieldNode;\n        }\n\n        return fieldNodeTransformer(fieldNode, fragments);\n      },\n    );\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(request: Request): Request {\n    return this.transformer.transformRequest(request);\n  }\n}\n","import { GraphQLSchema, extendSchema, parse } from 'graphql';\n\nimport {\n  Transform,\n  IFieldResolver,\n  IResolvers,\n  Request,\n  FieldNodeMappers,\n} from '../../Interfaces';\nimport { addResolversToSchema } from '../../generate/index';\nimport { defaultMergedResolver } from '../../stitch/index';\n\nimport MapFields from './MapFields';\n\nexport default class ExtendSchema implements Transform {\n  private readonly typeDefs: string | undefined;\n  private readonly resolvers: IResolvers | undefined;\n  private readonly defaultFieldResolver: IFieldResolver<any, any> | undefined;\n  private readonly transformer: MapFields;\n\n  constructor({\n    typeDefs,\n    resolvers = {},\n    defaultFieldResolver,\n    fieldNodeTransformerMap,\n  }: {\n    typeDefs?: string;\n    resolvers?: IResolvers;\n    defaultFieldResolver?: IFieldResolver<any, any>;\n    fieldNodeTransformerMap?: FieldNodeMappers;\n  }) {\n    this.typeDefs = typeDefs;\n    this.resolvers = resolvers;\n    this.defaultFieldResolver =\n      defaultFieldResolver != null\n        ? defaultFieldResolver\n        : defaultMergedResolver;\n    this.transformer = new MapFields(\n      fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {},\n    );\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    this.transformer.transformSchema(schema);\n\n    return addResolversToSchema({\n      schema: this.typeDefs\n        ? extendSchema(schema, parse(this.typeDefs))\n        : schema,\n      resolvers: this.resolvers != null ? this.resolvers : {},\n      defaultFieldResolver: this.defaultFieldResolver,\n    });\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import {\n  FieldNode,\n  Kind,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n} from 'graphql';\n\nexport function renameFieldNode(fieldNode: FieldNode, name: string): FieldNode {\n  return {\n    ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value:\n        fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,\n    },\n    name: {\n      kind: Kind.NAME,\n      value: name,\n    },\n  };\n}\n\nexport function preAliasFieldNode(\n  fieldNode: FieldNode,\n  str: string,\n): FieldNode {\n  return {\n    ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value: `${str}${\n        fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value\n      }`,\n    },\n  };\n}\n\nexport function wrapFieldNode(\n  fieldNode: FieldNode,\n  path: Array<string>,\n): FieldNode {\n  let newFieldNode = fieldNode;\n  path.forEach((fieldName) => {\n    newFieldNode = {\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: fieldName,\n      },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [fieldNode],\n      },\n    };\n  });\n\n  return newFieldNode;\n}\n\nexport function collectFields(\n  selectionSet: SelectionSetNode | undefined,\n  fragments: Record<string, FragmentDefinitionNode>,\n  fields: Array<FieldNode> = [],\n  visitedFragmentNames = {},\n): Array<FieldNode> {\n  if (selectionSet != null) {\n    selectionSet.selections.forEach((selection) => {\n      switch (selection.kind) {\n        case Kind.FIELD:\n          fields.push(selection);\n          break;\n        case Kind.INLINE_FRAGMENT:\n          collectFields(\n            selection.selectionSet,\n            fragments,\n            fields,\n            visitedFragmentNames,\n          );\n          break;\n        case Kind.FRAGMENT_SPREAD: {\n          const fragmentName = selection.name.value;\n          if (!visitedFragmentNames[fragmentName]) {\n            visitedFragmentNames[fragmentName] = true;\n            collectFields(\n              fragments[fragmentName].selectionSet,\n              fragments,\n              fields,\n              visitedFragmentNames,\n            );\n          }\n          break;\n        }\n        default:\n          // unreachable\n          break;\n      }\n    });\n  }\n\n  return fields;\n}\n\nexport function hoistFieldNodes({\n  fieldNode,\n  fieldNames,\n  path = [],\n  delimeter = '__gqltf__',\n  fragments,\n}: {\n  fieldNode: FieldNode;\n  fieldNames?: Array<string>;\n  path?: Array<string>;\n  delimeter?: string;\n  fragments: Record<string, FragmentDefinitionNode>;\n}): Array<FieldNode> {\n  const alias =\n    fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n\n  let newFieldNodes: Array<FieldNode> = [];\n\n  if (path.length) {\n    const remainingPathSegments = path.slice();\n    const initialPathSegment = remainingPathSegments.shift();\n\n    collectFields(fieldNode.selectionSet, fragments).forEach(\n      (possibleFieldNode: FieldNode) => {\n        if (possibleFieldNode.name.value === initialPathSegment) {\n          newFieldNodes = newFieldNodes.concat(\n            hoistFieldNodes({\n              fieldNode: preAliasFieldNode(\n                possibleFieldNode,\n                `${alias}${delimeter}`,\n              ),\n              fieldNames,\n              path: remainingPathSegments,\n              delimeter,\n              fragments,\n            }),\n          );\n        }\n      },\n    );\n  } else {\n    collectFields(fieldNode.selectionSet, fragments).forEach(\n      (possibleFieldNode: FieldNode) => {\n        if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n          newFieldNodes.push(\n            preAliasFieldNode(possibleFieldNode, `${alias}${delimeter}`),\n          );\n        }\n      },\n    );\n  }\n\n  return newFieldNodes;\n}\n","import {\n  GraphQLFieldConfigMap,\n  GraphQLObjectType,\n  GraphQLFieldConfig,\n} from 'graphql';\n\nimport { toConfig } from '../polyfills/index';\nimport toObjMap from '../esUtils/toObjMap';\nimport { TypeMap } from '../Interfaces';\n\nexport function appendFields(\n  typeMap: TypeMap,\n  typeName: string,\n  fields: GraphQLFieldConfigMap<any, any>,\n): void {\n  let type = typeMap[typeName];\n  if (type != null) {\n    const typeConfig = toConfig(type);\n\n    const newFields = toObjMap(typeConfig.fields);\n    Object.keys(fields).forEach((fieldName) => {\n      newFields[fieldName] = fields[fieldName];\n    });\n    type = new GraphQLObjectType({\n      ...typeConfig,\n      fields: newFields,\n    });\n  } else {\n    type = new GraphQLObjectType({\n      name: typeName,\n      fields,\n    });\n  }\n  typeMap[typeName] = type;\n}\n\nexport function removeFields(\n  typeMap: TypeMap,\n  typeName: string,\n  testFn: (fieldName: string, field: GraphQLFieldConfig<any, any>) => boolean,\n): GraphQLFieldConfigMap<any, any> {\n  let type = typeMap[typeName];\n  const typeConfig = toConfig(type);\n  const originalFields = typeConfig.fields;\n  const newFields = {};\n  const removedFields = {};\n  Object.keys(originalFields).forEach((fieldName) => {\n    if (testFn(fieldName, originalFields[fieldName])) {\n      removedFields[fieldName] = originalFields[fieldName];\n    } else {\n      newFields[fieldName] = originalFields[fieldName];\n    }\n  });\n  type = new GraphQLObjectType({\n    ...typeConfig,\n    fields: newFields,\n  });\n  typeMap[typeName] = type;\n\n  return removedFields;\n}\n","import { IFieldResolver } from '../Interfaces';\n\nimport { unwrapResult, dehoistResult } from './proxiedResult';\nimport defaultMergedResolver from './defaultMergedResolver';\n\nexport function createMergedResolver({\n  fromPath,\n  dehoist,\n  delimeter = '__gqltf__',\n}: {\n  fromPath?: Array<string>;\n  dehoist?: boolean;\n  delimeter?: string;\n}): IFieldResolver<any, any> {\n  const parentErrorResolver: IFieldResolver<any, any> = (\n    parent,\n    args,\n    context,\n    info,\n  ) =>\n    parent instanceof Error\n      ? parent\n      : defaultMergedResolver(parent, args, context, info);\n\n  const unwrappingResolver: IFieldResolver<any, any> =\n    fromPath != null\n      ? (parent, args, context, info) =>\n          parentErrorResolver(\n            unwrapResult(parent, info, fromPath),\n            args,\n            context,\n            info,\n          )\n      : parentErrorResolver;\n\n  const dehoistingResolver: IFieldResolver<any, any> = dehoist\n    ? (parent, args, context, info) =>\n        unwrappingResolver(\n          dehoistResult(parent, delimeter),\n          args,\n          context,\n          info,\n        )\n    : unwrappingResolver;\n\n  const noParentResolver: IFieldResolver<any, any> = (\n    parent,\n    args,\n    context,\n    info,\n  ) => (parent ? dehoistingResolver(parent, args, context, info) : {});\n\n  return noParentResolver;\n}\n","import { GraphQLSchema, GraphQLObjectType } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\nimport { healSchema } from '../../utils/index';\nimport { hoistFieldNodes } from '../../utils/fieldNodes';\nimport { appendFields, removeFields } from '../../utils/fields';\nimport { defaultMergedResolver } from '../../stitch/index';\nimport { createMergedResolver } from '../../stitch/createMergedResolver';\n\nimport MapFields from './MapFields';\n\nexport default class WrapFields implements Transform {\n  private readonly outerTypeName: string;\n  private readonly wrappingFieldNames: Array<string>;\n  private readonly wrappingTypeNames: Array<string>;\n  private readonly numWraps: number;\n  private readonly fieldNames: Array<string>;\n  private readonly transformer: Transform;\n\n  constructor(\n    outerTypeName: string,\n    wrappingFieldNames: Array<string>,\n    wrappingTypeNames: Array<string>,\n    fieldNames?: Array<string>,\n  ) {\n    this.outerTypeName = outerTypeName;\n    this.wrappingFieldNames = wrappingFieldNames;\n    this.wrappingTypeNames = wrappingTypeNames;\n    this.numWraps = wrappingFieldNames.length;\n    this.fieldNames = fieldNames;\n\n    const remainingWrappingFieldNames = this.wrappingFieldNames.slice();\n    const outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\n    this.transformer = new MapFields({\n      [outerTypeName]: {\n        [outerMostWrappingFieldName]: (fieldNode, fragments) =>\n          hoistFieldNodes({\n            fieldNode,\n            path: remainingWrappingFieldNames,\n            fieldNames: this.fieldNames,\n            fragments,\n          }),\n      },\n    });\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    const typeMap = schema.getTypeMap();\n\n    const targetFields = removeFields(\n      typeMap,\n      this.outerTypeName,\n      !this.fieldNames\n        ? () => true\n        : (fieldName) => this.fieldNames.includes(fieldName),\n    );\n\n    let wrapIndex = this.numWraps - 1;\n\n    const innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];\n    appendFields(typeMap, innerMostWrappingTypeName, targetFields);\n\n    for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\n      appendFields(typeMap, this.wrappingTypeNames[wrapIndex], {\n        [this.wrappingFieldNames[wrapIndex + 1]]: {\n          type: typeMap[\n            this.wrappingTypeNames[wrapIndex + 1]\n          ] as GraphQLObjectType,\n          resolve: defaultMergedResolver,\n        },\n      });\n    }\n\n    appendFields(typeMap, this.outerTypeName, {\n      [this.wrappingFieldNames[0]]: {\n        type: typeMap[this.wrappingTypeNames[0]] as GraphQLObjectType,\n        resolve: createMergedResolver({ dehoist: true }),\n      },\n    });\n\n    healSchema(schema);\n\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nimport WrapFields from './WrapFields';\n\nexport default class WrapType implements Transform {\n  private readonly transformer: Transform;\n\n  constructor(outerTypeName: string, innerTypeName: string, fieldName: string) {\n    this.transformer = new WrapFields(\n      outerTypeName,\n      [fieldName],\n      [innerTypeName],\n      undefined,\n    );\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import { GraphQLSchema, GraphQLObjectType, getNullableType } from 'graphql';\n\nimport { healSchema } from '../../utils/index';\nimport { wrapFieldNode, renameFieldNode } from '../../utils/fieldNodes';\nimport { createMergedResolver } from '../../stitch/createMergedResolver';\nimport { appendFields, removeFields } from '../../utils/fields';\nimport { Transform, Request } from '../../Interfaces';\n\nimport MapFields from './MapFields';\n\nexport default class HoistField implements Transform {\n  private readonly typeName: string;\n  private readonly path: Array<string>;\n  private readonly newFieldName: string;\n  private readonly pathToField: Array<string>;\n  private readonly oldFieldName: string;\n  private readonly transformer: Transform;\n\n  constructor(typeName: string, path: Array<string>, newFieldName: string) {\n    this.typeName = typeName;\n    this.path = path;\n    this.newFieldName = newFieldName;\n\n    this.pathToField = this.path.slice();\n    this.oldFieldName = this.pathToField.pop();\n    this.transformer = new MapFields({\n      [typeName]: {\n        [newFieldName]: (fieldNode) =>\n          wrapFieldNode(\n            renameFieldNode(fieldNode, this.oldFieldName),\n            this.pathToField,\n          ),\n      },\n    });\n  }\n\n  public transformSchema(schema: GraphQLSchema): GraphQLSchema {\n    const typeMap = schema.getTypeMap();\n\n    const innerType: GraphQLObjectType = this.pathToField.reduce(\n      (acc, pathSegment) =>\n        getNullableType(acc.getFields()[pathSegment].type) as GraphQLObjectType,\n      typeMap[this.typeName] as GraphQLObjectType,\n    );\n\n    const targetField = removeFields(\n      typeMap,\n      innerType.name,\n      (fieldName) => fieldName === this.oldFieldName,\n    )[this.oldFieldName];\n\n    const targetType = targetField.type as GraphQLObjectType;\n\n    appendFields(typeMap, this.typeName, {\n      [this.newFieldName]: {\n        type: targetType,\n        resolve: createMergedResolver({ fromPath: this.pathToField }),\n      },\n    });\n\n    healSchema(schema);\n\n    return this.transformer.transformSchema(schema);\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    return this.transformer.transformRequest(originalRequest);\n  }\n}\n","import {\n  DocumentNode,\n  GraphQLSchema,\n  GraphQLType,\n  InlineFragmentNode,\n  Kind,\n  SelectionSetNode,\n  TypeInfo,\n  OperationDefinitionNode,\n  parse,\n  visit,\n  visitWithTypeInfo,\n} from 'graphql';\n\nimport { concatInlineFragments } from '../../utils/fragments';\nimport { Transform, Request } from '../../Interfaces';\n\nexport default class ReplaceFieldWithFragment implements Transform {\n  private readonly targetSchema: GraphQLSchema;\n  private readonly mapping: FieldToFragmentMapping;\n\n  constructor(\n    targetSchema: GraphQLSchema,\n    fragments: Array<{\n      field: string;\n      fragment: string;\n    }>,\n  ) {\n    this.targetSchema = targetSchema;\n    this.mapping = {};\n    for (const { field, fragment } of fragments) {\n      const parsedFragment = parseFragmentToInlineFragment(fragment);\n      const actualTypeName = parsedFragment.typeCondition.name.value;\n      if (!(actualTypeName in this.mapping)) {\n        this.mapping[actualTypeName] = Object.create(null);\n      }\n\n      const typeMapping = this.mapping[actualTypeName];\n\n      if (!(field in typeMapping)) {\n        typeMapping[field] = [parsedFragment];\n      } else {\n        typeMapping[field].push(parsedFragment);\n      }\n    }\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = replaceFieldsWithFragments(\n      this.targetSchema,\n      originalRequest.document,\n      this.mapping,\n    );\n    return {\n      ...originalRequest,\n      document,\n    };\n  }\n}\n\ntype FieldToFragmentMapping = {\n  [typeName: string]: { [fieldName: string]: Array<InlineFragmentNode> };\n};\n\nfunction replaceFieldsWithFragments(\n  targetSchema: GraphQLSchema,\n  document: DocumentNode,\n  mapping: FieldToFragmentMapping,\n): DocumentNode {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(\n    document,\n    visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET](\n        node: SelectionSetNode,\n      ): SelectionSetNode | null | undefined {\n        const parentType: GraphQLType = typeInfo.getParentType();\n        if (parentType != null) {\n          const parentTypeName = parentType.name;\n          let selections = node.selections;\n\n          if (parentTypeName in mapping) {\n            node.selections.forEach((selection) => {\n              if (selection.kind === Kind.FIELD) {\n                const name = selection.name.value;\n                const fragments = mapping[parentTypeName][name];\n                if (fragments != null && fragments.length > 0) {\n                  const fragment = concatInlineFragments(\n                    parentTypeName,\n                    fragments,\n                  );\n                  selections = selections.concat(fragment);\n                }\n              }\n            });\n          }\n\n          if (selections !== node.selections) {\n            return {\n              ...node,\n              selections,\n            };\n          }\n        }\n      },\n    }),\n  );\n}\n\nfunction parseFragmentToInlineFragment(\n  definitions: string,\n): InlineFragmentNode {\n  if (definitions.trim().startsWith('fragment')) {\n    const document = parse(definitions);\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet,\n        };\n      }\n    }\n  }\n\n  const query = parse(`{${definitions}}`)\n    .definitions[0] as OperationDefinitionNode;\n  for (const selection of query.selectionSet.selections) {\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n","import {\n  FieldNode,\n  visit,\n  Kind,\n  SelectionNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport { Transform, Request, ExecutionResult } from '../../Interfaces';\n\nexport type QueryWrapper = (\n  subtree: SelectionSetNode,\n) => SelectionNode | SelectionSetNode;\n\nexport default class WrapQuery implements Transform {\n  private readonly wrapper: QueryWrapper;\n  private readonly extractor: (result: any) => any;\n  private readonly path: Array<string>;\n\n  constructor(\n    path: Array<string>,\n    wrapper: QueryWrapper,\n    extractor: (result: any) => any,\n  ) {\n    this.path = path;\n    this.wrapper = wrapper;\n    this.extractor = extractor;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    const document = originalRequest.document;\n    const fieldPath: Array<string> = [];\n    const ourPath = JSON.stringify(this.path);\n    const newDocument = visit(document, {\n      [Kind.FIELD]: {\n        enter: (node: FieldNode) => {\n          fieldPath.push(node.name.value);\n          if (ourPath === JSON.stringify(fieldPath)) {\n            const wrapResult = this.wrapper(node.selectionSet);\n\n            // Selection can be either a single selection or a selection set. If it's just one selection,\n            // let's wrap it in a selection set. Otherwise, keep it as is.\n            const selectionSet =\n              wrapResult != null && wrapResult.kind === Kind.SELECTION_SET\n                ? wrapResult\n                : {\n                    kind: Kind.SELECTION_SET,\n                    selections: [wrapResult],\n                  };\n\n            return {\n              ...node,\n              selectionSet,\n            };\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        },\n      },\n    });\n    return {\n      ...originalRequest,\n      document: newDocument,\n    };\n  }\n\n  public transformResult(originalResult: ExecutionResult): ExecutionResult {\n    const rootData = originalResult.data;\n    if (rootData != null) {\n      let data = rootData;\n      const path = [...this.path];\n      while (path.length > 1) {\n        const next = path.shift();\n        if (data[next]) {\n          data = data[next];\n        }\n      }\n      data[path[0]] = this.extractor(data[path[0]]);\n    }\n\n    return {\n      data: rootData,\n      errors: originalResult.errors,\n    };\n  }\n}\n","import { visit, Kind, SelectionSetNode, BREAK, FieldNode } from 'graphql';\n\nimport { Transform, Request } from '../../Interfaces';\n\nexport default class ExtractField implements Transform {\n  private readonly from: Array<string>;\n  private readonly to: Array<string>;\n\n  constructor({ from, to }: { from: Array<string>; to: Array<string> }) {\n    this.from = from;\n    this.to = to;\n  }\n\n  public transformRequest(originalRequest: Request): Request {\n    let fromSelection: SelectionSetNode | undefined;\n    const ourPathFrom = JSON.stringify(this.from);\n    const ourPathTo = JSON.stringify(this.to);\n    let fieldPath: Array<string> = [];\n    visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: (node: FieldNode) => {\n          fieldPath.push(node.name.value);\n          if (ourPathFrom === JSON.stringify(fieldPath)) {\n            fromSelection = node.selectionSet;\n            return BREAK;\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        },\n      },\n    });\n\n    fieldPath = [];\n    const newDocument = visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: (node: FieldNode) => {\n          fieldPath.push(node.name.value);\n          if (\n            ourPathTo === JSON.stringify(fieldPath) &&\n            fromSelection != null\n          ) {\n            return {\n              ...node,\n              selectionSet: fromSelection,\n            };\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        },\n      },\n    });\n    return {\n      ...originalRequest,\n      document: newDocument,\n    };\n  }\n}\n","import { ApolloLink } from 'apollo-link';\nimport {\n  GraphQLFieldResolver,\n  GraphQLSchema,\n  BuildSchemaOptions,\n} from 'graphql';\n\nimport { Fetcher } from '../Interfaces';\nimport { buildSchema } from '../polyfills/index';\nimport linkToFetcher from '../stitch/linkToFetcher';\nimport { delegateToSchema } from '../delegate';\n\nimport { wrapSchema } from './wrapSchema';\n\nexport default function makeRemoteExecutableSchema({\n  schema: schemaOrTypeDefs,\n  link,\n  fetcher,\n  createResolver = defaultCreateRemoteResolver,\n  createSubscriptionResolver = defaultCreateRemoteSubscriptionResolver,\n  buildSchemaOptions,\n}: {\n  schema: GraphQLSchema | string;\n  link?: ApolloLink;\n  fetcher?: Fetcher;\n  createResolver?: (fetcher: Fetcher) => GraphQLFieldResolver<any, any>;\n  createSubscriptionResolver?: (\n    link: ApolloLink,\n  ) => GraphQLFieldResolver<any, any>;\n  buildSchemaOptions?: BuildSchemaOptions;\n}): GraphQLSchema {\n  let finalFetcher: Fetcher = fetcher;\n\n  if (finalFetcher == null && link != null) {\n    finalFetcher = linkToFetcher(link);\n  }\n\n  const targetSchema =\n    typeof schemaOrTypeDefs === 'string'\n      ? buildSchema(schemaOrTypeDefs, buildSchemaOptions)\n      : schemaOrTypeDefs;\n\n  return wrapSchema({\n    schema: targetSchema,\n    createProxyingResolver: (_schema, _transforms, operation) => {\n      if (operation === 'query' || operation === 'mutation') {\n        return createResolver(finalFetcher);\n      }\n      return createSubscriptionResolver(link);\n    },\n  });\n}\n\nexport function defaultCreateRemoteResolver(\n  fetcher: Fetcher,\n): GraphQLFieldResolver<any, any> {\n  return (_parent, _args, context, info) =>\n    delegateToSchema({\n      schema: { schema: info.schema, fetcher },\n      context,\n      info,\n    });\n}\n\nexport function defaultCreateRemoteSubscriptionResolver(\n  link: ApolloLink,\n): GraphQLFieldResolver<any, any> {\n  return (_parent, _args, context, info) =>\n    delegateToSchema({\n      schema: { schema: info.schema, link },\n      context,\n      info,\n    });\n}\n"],"names":["typeFromAST","graphqlExtendSchema","pruneTypes","getTypeSpecifiers","AddMergedTypeSelectionSets","execute","executeLink","extendSchema","uuid","isObject","collectFields","parseFragmentToInlineFragment","replaceFieldsWithFragments"],"mappings":"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"}