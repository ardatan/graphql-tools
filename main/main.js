System.register(["apollo-link","deprecated-decorator","graphql","graphql/error","graphql/execution/values","iterall","uuid"], function(__WEBPACK_DYNAMIC_EXPORT__) {
	var __WEBPACK_EXTERNAL_MODULE_apollo_link__, __WEBPACK_EXTERNAL_MODULE_deprecated_decorator__, __WEBPACK_EXTERNAL_MODULE_graphql__, __WEBPACK_EXTERNAL_MODULE_graphql_error__, __WEBPACK_EXTERNAL_MODULE_graphql_execution_values__, __WEBPACK_EXTERNAL_MODULE_iterall__, __WEBPACK_EXTERNAL_MODULE_uuid__;
	return {
		setters: [
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_apollo_link__ = module;
			},
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_deprecated_decorator__ = module;
			},
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_graphql__ = module;
			},
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_graphql_error__ = module;
			},
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_graphql_execution_values__ = module;
			},
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_iterall__ = module;
			},
			function(module) {
				__WEBPACK_EXTERNAL_MODULE_uuid__ = module;
			}
		],
		execute: function() {
			__WEBPACK_DYNAMIC_EXPORT__(
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/generate/SchemaError.ts":
/*!*************************************!*\
  !*** ./src/generate/SchemaError.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// @schemaDefinition: A GraphQL type schema in shorthand\n// @resolvers: Definitions for resolvers to be merged with schema\nvar SchemaError = /** @class */ (function (_super) {\n    __extends(SchemaError, _super);\n    function SchemaError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.message = message;\n        Error.captureStackTrace(_this, _this.constructor);\n        return _this;\n    }\n    return SchemaError;\n}(Error));\nexports.default = SchemaError;\n\n\n//# sourceURL=webpack:///./src/generate/SchemaError.ts?");

/***/ }),

/***/ "./src/generate/addResolveFunctionsToSchema.ts":
/*!*****************************************************!*\
  !*** ./src/generate/addResolveFunctionsToSchema.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar _1 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar transforms_1 = __webpack_require__(/*! ../transforms/transforms */ \"./src/transforms/transforms.ts\");\nvar _2 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\nvar ConvertEnumValues_1 = __webpack_require__(/*! ../transforms/ConvertEnumValues */ \"./src/transforms/ConvertEnumValues.ts\");\nfunction addResolveFunctionsToSchema(options, legacyInputResolvers, legacyInputValidationOptions) {\n    if (options instanceof graphql_1.GraphQLSchema) {\n        console.warn('The addResolveFunctionsToSchema function takes named options now; see IAddResolveFunctionsToSchemaOptions');\n        options = {\n            schema: options,\n            resolvers: legacyInputResolvers,\n            resolverValidationOptions: legacyInputValidationOptions,\n        };\n    }\n    var schema = options.schema, inputResolvers = options.resolvers, _a = options.resolverValidationOptions, resolverValidationOptions = _a === void 0 ? {} : _a, _b = options.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n    var _c = resolverValidationOptions.allowResolversNotInSchema, allowResolversNotInSchema = _c === void 0 ? false : _c, requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n    var resolvers = inheritResolversFromInterfaces\n        ? _2.extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    // Used to map the external value of an enum to its internal value, when\n    // that internal value is provided by a resolver.\n    var enumValueMap = Object.create(null);\n    Object.keys(resolvers).forEach(function (typeName) {\n        var resolverValue = resolvers[typeName];\n        var resolverType = typeof resolverValue;\n        if (resolverType !== 'object' && resolverType !== 'function') {\n            throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value \" +\n                \"must be of type object or function.\");\n        }\n        var type = schema.getType(typeName);\n        if (!type && typeName !== '__schema') {\n            if (allowResolversNotInSchema) {\n                return;\n            }\n            throw new _1.SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n        }\n        Object.keys(resolverValue).forEach(function (fieldName) {\n            if (fieldName.startsWith('__')) {\n                // this is for isTypeOf and resolveType and all the other stuff.\n                type[fieldName.substring(2)] = resolverValue[fieldName];\n                return;\n            }\n            if (type instanceof graphql_1.GraphQLScalarType) {\n                type[fieldName] = resolverValue[fieldName];\n                return;\n            }\n            if (type instanceof graphql_1.GraphQLEnumType) {\n                if (!type.getValue(fieldName)) {\n                    if (allowResolversNotInSchema) {\n                        return;\n                    }\n                    throw new _1.SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n                }\n                // We've encountered an enum resolver that is being used to provide an\n                // internal enum value.\n                // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n                //\n                // We're storing a map of the current enums external facing value to\n                // its resolver provided internal value. This map is used to transform\n                // the current schema to a new schema that includes enums with the new\n                // internal value.\n                enumValueMap[type.name] = enumValueMap[type.name] || {};\n                enumValueMap[type.name][fieldName] = resolverValue[fieldName];\n                return;\n            }\n            // object type\n            var fields = getFieldsForType(type);\n            if (!fields) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new _1.SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n            }\n            if (!fields[fieldName]) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new _1.SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n            }\n            var field = fields[fieldName];\n            var fieldResolve = resolverValue[fieldName];\n            if (typeof fieldResolve === 'function') {\n                // for convenience. Allows shorter syntax in resolver definition file\n                setFieldProperties(field, { resolve: fieldResolve });\n            }\n            else {\n                if (typeof fieldResolve !== 'object') {\n                    throw new _1.SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n                }\n                setFieldProperties(field, fieldResolve);\n            }\n        });\n    });\n    _2.checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    // If there are any enum resolver functions (that are used to return\n    // internal enum values), create a new schema that includes enums with the\n    // new internal facing values.\n    var updatedSchema = transforms_1.applySchemaTransforms(schema, [\n        new ConvertEnumValues_1.default(enumValueMap),\n    ]);\n    return updatedSchema;\n}\nfunction getFieldsForType(type) {\n    if (type instanceof graphql_1.GraphQLObjectType ||\n        type instanceof graphql_1.GraphQLInterfaceType) {\n        return type.getFields();\n    }\n    else {\n        return undefined;\n    }\n}\nfunction setFieldProperties(field, propertiesObj) {\n    Object.keys(propertiesObj).forEach(function (propertyName) {\n        field[propertyName] = propertiesObj[propertyName];\n    });\n}\nexports.default = addResolveFunctionsToSchema;\n\n\n//# sourceURL=webpack:///./src/generate/addResolveFunctionsToSchema.ts?");

/***/ }),

/***/ "./src/generate/addSchemaLevelResolveFunction.ts":
/*!*******************************************************!*\
  !*** ./src/generate/addSchemaLevelResolveFunction.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\n// wraps all resolve functions of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolve funciton\nfunction addSchemaLevelResolveFunction(schema, fn) {\n    // TODO test that schema is a schema, fn is a function\n    var rootTypes = [\n        schema.getQueryType(),\n        schema.getMutationType(),\n        schema.getSubscriptionType(),\n    ].filter(function (x) { return !!x; });\n    rootTypes.forEach(function (type) {\n        // XXX this should run at most once per request to simulate a true root resolver\n        // for graphql-js this is an approximation that works with queries but not mutations\n        var rootResolveFn = runAtMostOncePerRequest(fn);\n        var fields = type.getFields();\n        Object.keys(fields).forEach(function (fieldName) {\n            // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n            // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n            if (type === schema.getSubscriptionType()) {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, fn);\n            }\n            else {\n                fields[fieldName].resolve = wrapResolver(fields[fieldName].resolve, rootResolveFn);\n            }\n        });\n    });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n    return function (obj, args, ctx, info) {\n        return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n            if (innerResolver) {\n                return innerResolver(root, args, ctx, info);\n            }\n            return graphql_1.defaultFieldResolver(root, args, ctx, info);\n        });\n    };\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n    var value;\n    var randomNumber = Math.random();\n    return function (root, args, ctx, info) {\n        if (!info.operation['__runAtMostOnce']) {\n            info.operation['__runAtMostOnce'] = {};\n        }\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\n            info.operation['__runAtMostOnce'][randomNumber] = true;\n            value = fn(root, args, ctx, info);\n        }\n        return value;\n    };\n}\nexports.default = addSchemaLevelResolveFunction;\n\n\n//# sourceURL=webpack:///./src/generate/addSchemaLevelResolveFunction.ts?");

/***/ }),

/***/ "./src/generate/assertResolveFunctionsPresent.ts":
/*!*******************************************************!*\
  !*** ./src/generate/assertResolveFunctionsPresent.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar _1 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\nfunction assertResolveFunctionsPresent(schema, resolverValidationOptions) {\n    if (resolverValidationOptions === void 0) { resolverValidationOptions = {}; }\n    var _a = resolverValidationOptions.requireResolversForArgs, requireResolversForArgs = _a === void 0 ? false : _a, _b = resolverValidationOptions.requireResolversForNonScalar, requireResolversForNonScalar = _b === void 0 ? false : _b, _c = resolverValidationOptions.requireResolversForAllFields, requireResolversForAllFields = _c === void 0 ? false : _c;\n    if (requireResolversForAllFields &&\n        (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    _1.forEachField(schema, function (field, typeName, fieldName) {\n        // requires a resolve function for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolveFunction(field, typeName, fieldName);\n        }\n        // requires a resolve function on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolveFunction(field, typeName, fieldName);\n        }\n        // requires a resolve function on every field that returns a non-scalar type\n        if (requireResolversForNonScalar &&\n            !(graphql_1.getNamedType(field.type) instanceof graphql_1.GraphQLScalarType)) {\n            expectResolveFunction(field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolveFunction(field, typeName, fieldName) {\n    if (!field.resolve) {\n        console.warn(\n        // tslint:disable-next-line: max-line-length\n        \"Resolve function missing for \\\"\" + typeName + \".\" + fieldName + \"\\\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131\");\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new _1.SchemaError(\"Resolver \\\"\" + typeName + \".\" + fieldName + \"\\\" must be a function\");\n    }\n}\nexports.default = assertResolveFunctionsPresent;\n\n\n//# sourceURL=webpack:///./src/generate/assertResolveFunctionsPresent.ts?");

/***/ }),

/***/ "./src/generate/attachConnectorsToContext.ts":
/*!***************************************************!*\
  !*** ./src/generate/attachConnectorsToContext.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar deprecated_decorator_1 = __webpack_require__(/*! deprecated-decorator */ \"deprecated-decorator\");\nvar _1 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\n// takes a GraphQL-JS schema and an object of connectors, then attaches\n// the connectors to the context by wrapping each query or mutation resolve\n// function with a function that attaches connectors if they don't exist.\n// attaches connectors only once to make sure they are singletons\nvar attachConnectorsToContext = deprecated_decorator_1.deprecated({\n    version: '0.7.0',\n    url: 'https://github.com/apollostack/graphql-tools/issues/140',\n}, function (schema, connectors) {\n    if (!schema || !(schema instanceof graphql_1.GraphQLSchema)) {\n        throw new Error('schema must be an instance of GraphQLSchema. ' +\n            'This error could be caused by installing more than one version of GraphQL-JS');\n    }\n    if (typeof connectors !== 'object') {\n        var connectorType = typeof connectors;\n        throw new Error(\"Expected connectors to be of type object, got \" + connectorType);\n    }\n    if (Object.keys(connectors).length === 0) {\n        throw new Error('Expected connectors to not be an empty object');\n    }\n    if (Array.isArray(connectors)) {\n        throw new Error('Expected connectors to be of type object, got Array');\n    }\n    if (schema['_apolloConnectorsAttached']) {\n        throw new Error('Connectors already attached to context, cannot attach more than once');\n    }\n    schema['_apolloConnectorsAttached'] = true;\n    var attachconnectorFn = function (root, args, ctx) {\n        if (typeof ctx !== 'object') {\n            // if in any way possible, we should throw an error when the attachconnectors\n            // function is called, not when a query is executed.\n            var contextType = typeof ctx;\n            throw new Error(\"Cannot attach connector because context is not an object: \" + contextType);\n        }\n        if (typeof ctx.connectors === 'undefined') {\n            ctx.connectors = {};\n        }\n        Object.keys(connectors).forEach(function (connectorName) {\n            var connector = connectors[connectorName];\n            if (!!connector.prototype) {\n                ctx.connectors[connectorName] = new connector(ctx);\n            }\n            else {\n                throw new Error(\"Connector must be a function or an class\");\n            }\n        });\n        return root;\n    };\n    _1.addSchemaLevelResolveFunction(schema, attachconnectorFn);\n});\nexports.default = attachConnectorsToContext;\n\n\n//# sourceURL=webpack:///./src/generate/attachConnectorsToContext.ts?");

/***/ }),

/***/ "./src/generate/attachDirectiveResolvers.ts":
/*!**************************************************!*\
  !*** ./src/generate/attachDirectiveResolvers.ts ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar schemaVisitor_1 = __webpack_require__(/*! ../schemaVisitor */ \"./src/schemaVisitor.ts\");\nfunction attachDirectiveResolvers(schema, directiveResolvers) {\n    if (typeof directiveResolvers !== 'object') {\n        throw new Error(\"Expected directiveResolvers to be of type object, got \" + typeof directiveResolvers);\n    }\n    if (Array.isArray(directiveResolvers)) {\n        throw new Error('Expected directiveResolvers to be of type object, got Array');\n    }\n    var schemaDirectives = Object.create(null);\n    Object.keys(directiveResolvers).forEach(function (directiveName) {\n        schemaDirectives[directiveName] = /** @class */ (function (_super) {\n            __extends(class_1, _super);\n            function class_1() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            class_1.prototype.visitFieldDefinition = function (field) {\n                var _this = this;\n                var resolver = directiveResolvers[directiveName];\n                var originalResolver = field.resolve || graphql_1.defaultFieldResolver;\n                var directiveArgs = this.args;\n                field.resolve = function () {\n                    var args = [];\n                    for (var _i = 0; _i < arguments.length; _i++) {\n                        args[_i] = arguments[_i];\n                    }\n                    var source = args[0] /* original args */, context = args[2], info = args[3];\n                    return resolver(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {\n                        return [2 /*return*/, originalResolver.apply(field, args)];\n                    }); }); }, source, directiveArgs, context, info);\n                };\n            };\n            return class_1;\n        }(schemaVisitor_1.SchemaDirectiveVisitor));\n    });\n    schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n}\nexports.default = attachDirectiveResolvers;\n\n\n//# sourceURL=webpack:///./src/generate/attachDirectiveResolvers.ts?");

/***/ }),

/***/ "./src/generate/buildSchemaFromTypeDefinitions.ts":
/*!********************************************************!*\
  !*** ./src/generate/buildSchemaFromTypeDefinitions.ts ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar _1 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\nfunction buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\n    // TODO: accept only array here, otherwise interfaces get confusing.\n    var myDefinitions = typeDefinitions;\n    var astDocument;\n    if (isDocumentNode(typeDefinitions)) {\n        astDocument = typeDefinitions;\n    }\n    else if (typeof myDefinitions !== 'string') {\n        if (!Array.isArray(myDefinitions)) {\n            var type = typeof myDefinitions;\n            throw new _1.SchemaError(\"typeDefs must be a string, array or schema AST, got \" + type);\n        }\n        myDefinitions = _1.concatenateTypeDefs(myDefinitions);\n    }\n    if (typeof myDefinitions === 'string') {\n        astDocument = graphql_1.parse(myDefinitions, parseOptions);\n    }\n    var backcompatOptions = { commentDescriptions: true };\n    // TODO fix types https://github.com/apollographql/graphql-tools/issues/542\n    var schema = graphql_1.buildASTSchema(astDocument, backcompatOptions);\n    var extensionsAst = _1.extractExtensionDefinitions(astDocument);\n    if (extensionsAst.definitions.length > 0) {\n        // TODO fix types https://github.com/apollographql/graphql-tools/issues/542\n        schema = graphql_1.extendSchema(schema, extensionsAst, backcompatOptions);\n    }\n    return schema;\n}\nfunction isDocumentNode(typeDefinitions) {\n    return typeDefinitions.kind !== undefined;\n}\nexports.default = buildSchemaFromTypeDefinitions;\n\n\n//# sourceURL=webpack:///./src/generate/buildSchemaFromTypeDefinitions.ts?");

/***/ }),

/***/ "./src/generate/chainResolvers.ts":
/*!****************************************!*\
  !*** ./src/generate/chainResolvers.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nfunction chainResolvers(resolvers) {\n    return function (root, args, ctx, info) {\n        return resolvers.reduce(function (prev, curResolver) {\n            if (curResolver) {\n                return curResolver(prev, args, ctx, info);\n            }\n            return graphql_1.defaultFieldResolver(prev, args, ctx, info);\n        }, root);\n    };\n}\nexports.chainResolvers = chainResolvers;\n\n\n//# sourceURL=webpack:///./src/generate/chainResolvers.ts?");

/***/ }),

/***/ "./src/generate/checkForResolveTypeResolver.ts":
/*!*****************************************************!*\
  !*** ./src/generate/checkForResolveTypeResolver.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar _1 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    Object.keys(schema.getTypeMap())\n        .map(function (typeName) { return schema.getType(typeName); })\n        .forEach(function (type) {\n        if (!(type instanceof graphql_1.GraphQLUnionType ||\n            type instanceof graphql_1.GraphQLInterfaceType)) {\n            return;\n        }\n        if (!type.resolveType) {\n            if (requireResolversForResolveType === false) {\n                return;\n            }\n            if (requireResolversForResolveType === true) {\n                throw new _1.SchemaError(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"resolveType\\\" resolver\");\n            }\n            // tslint:disable-next-line:max-line-length\n            console.warn(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"__resolveType\\\" resolver. Pass false into \" +\n                \"\\\"resolverValidationOptions.requireResolversForResolveType\\\" to disable this warning.\");\n        }\n    });\n}\nexports.default = checkForResolveTypeResolver;\n\n\n//# sourceURL=webpack:///./src/generate/checkForResolveTypeResolver.ts?");

/***/ }),

/***/ "./src/generate/concatenateTypeDefs.ts":
/*!*********************************************!*\
  !*** ./src/generate/concatenateTypeDefs.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar _1 = __webpack_require__(/*! . */ \"./src/generate/index.ts\");\nfunction concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {\n    if (calledFunctionRefs === void 0) { calledFunctionRefs = []; }\n    var resolvedTypeDefinitions = [];\n    typeDefinitionsAry.forEach(function (typeDef) {\n        if (typeDef.kind !== undefined) {\n            typeDef = graphql_1.print(typeDef);\n        }\n        if (typeof typeDef === 'function') {\n            if (calledFunctionRefs.indexOf(typeDef) === -1) {\n                calledFunctionRefs.push(typeDef);\n                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\n            }\n        }\n        else if (typeof typeDef === 'string') {\n            resolvedTypeDefinitions.push(typeDef.trim());\n        }\n        else {\n            var type = typeof typeDef;\n            throw new _1.SchemaError(\"typeDef array must contain only strings and functions, got \" + type);\n        }\n    });\n    return uniq(resolvedTypeDefinitions.map(function (x) { return x.trim(); })).join('\\n');\n}\nfunction uniq(array) {\n    return array.reduce(function (accumulator, currentValue) {\n        return accumulator.indexOf(currentValue) === -1\n            ? accumulator.concat([currentValue]) : accumulator;\n    }, []);\n}\nexports.default = concatenateTypeDefs;\n\n\n//# sourceURL=webpack:///./src/generate/concatenateTypeDefs.ts?");

/***/ }),

/***/ "./src/generate/decorateWithLogger.ts":
/*!********************************************!*\
  !*** ./src/generate/decorateWithLogger.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nfunction decorateWithLogger(fn, logger, hint) {\n    if (typeof fn === 'undefined') {\n        fn = graphql_1.defaultFieldResolver;\n    }\n    var logError = function (e) {\n        // TODO: clone the error properly\n        var newE = new Error();\n        newE.stack = e.stack;\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n        if (hint) {\n            newE['originalMessage'] = e.message;\n            newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\n        }\n        logger.log(newE);\n    };\n    return function (root, args, ctx, info) {\n        try {\n            var result = fn(root, args, ctx, info);\n            // If the resolve function returns a Promise log any Promise rejects.\n            if (result &&\n                typeof result.then === 'function' &&\n                typeof result.catch === 'function') {\n                result.catch(function (reason) {\n                    // make sure that it's an error we're logging.\n                    var error = reason instanceof Error ? reason : new Error(reason);\n                    logError(error);\n                    // We don't want to leave an unhandled exception so pass on error.\n                    return reason;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            logError(e);\n            // we want to pass on the error, just in case.\n            throw e;\n        }\n    };\n}\nexports.default = decorateWithLogger;\n\n\n//# sourceURL=webpack:///./src/generate/decorateWithLogger.ts?");

/***/ }),

/***/ "./src/generate/extendResolversFromInterfaces.ts":
/*!*******************************************************!*\
  !*** ./src/generate/extendResolversFromInterfaces.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nfunction extendResolversFromInterfaces(schema, resolvers) {\n    var typeNames = Object.keys(__assign({}, schema.getTypeMap(), resolvers));\n    var extendedResolvers = {};\n    typeNames.forEach(function (typeName) {\n        var typeResolvers = resolvers[typeName];\n        var type = schema.getType(typeName);\n        if (type instanceof graphql_1.GraphQLObjectType) {\n            var interfaceResolvers = type\n                .getInterfaces()\n                .map(function (iFace) { return resolvers[iFace.name]; });\n            extendedResolvers[typeName] = Object.assign.apply(Object, [{}].concat(interfaceResolvers, [typeResolvers]));\n        }\n        else {\n            if (typeResolvers) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    return extendedResolvers;\n}\nexports.default = extendResolversFromInterfaces;\n\n\n//# sourceURL=webpack:///./src/generate/extendResolversFromInterfaces.ts?");

/***/ }),

/***/ "./src/generate/extractExtensionDefinitions.ts":
/*!*****************************************************!*\
  !*** ./src/generate/extractExtensionDefinitions.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar newExtensionDefinitionKind = 'ObjectTypeExtension';\nvar interfaceExtensionDefinitionKind = 'InterfaceTypeExtension';\nvar inputObjectExtensionDefinitionKind = 'InputObjectTypeExtension';\nvar unionExtensionDefinitionKind = 'UnionTypeExtension';\nvar enumExtensionDefinitionKind = 'EnumTypeExtension';\nfunction extractExtensionDefinitions(ast) {\n    var extensionDefs = ast.definitions.filter(function (def) {\n        return def.kind === newExtensionDefinitionKind ||\n            def.kind === interfaceExtensionDefinitionKind ||\n            def.kind === inputObjectExtensionDefinitionKind ||\n            def.kind === unionExtensionDefinitionKind ||\n            def.kind === enumExtensionDefinitionKind;\n    });\n    return Object.assign({}, ast, {\n        definitions: extensionDefs,\n    });\n}\nexports.default = extractExtensionDefinitions;\n\n\n//# sourceURL=webpack:///./src/generate/extractExtensionDefinitions.ts?");

/***/ }),

/***/ "./src/generate/forEachField.ts":
/*!**************************************!*\
  !*** ./src/generate/forEachField.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nfunction forEachField(schema, fn) {\n    var typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!graphql_1.getNamedType(type).name.startsWith('__') &&\n            type instanceof graphql_1.GraphQLObjectType) {\n            var fields_1 = type.getFields();\n            Object.keys(fields_1).forEach(function (fieldName) {\n                var field = fields_1[fieldName];\n                fn(field, typeName, fieldName);\n            });\n        }\n    });\n}\nexports.default = forEachField;\n\n\n//# sourceURL=webpack:///./src/generate/forEachField.ts?");

/***/ }),

/***/ "./src/generate/index.ts":
/*!*******************************!*\
  !*** ./src/generate/index.ts ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar addResolveFunctionsToSchema_1 = __webpack_require__(/*! ./addResolveFunctionsToSchema */ \"./src/generate/addResolveFunctionsToSchema.ts\");\nexports.addResolveFunctionsToSchema = addResolveFunctionsToSchema_1.default;\nvar addSchemaLevelResolveFunction_1 = __webpack_require__(/*! ./addSchemaLevelResolveFunction */ \"./src/generate/addSchemaLevelResolveFunction.ts\");\nexports.addSchemaLevelResolveFunction = addSchemaLevelResolveFunction_1.default;\nvar assertResolveFunctionsPresent_1 = __webpack_require__(/*! ./assertResolveFunctionsPresent */ \"./src/generate/assertResolveFunctionsPresent.ts\");\nexports.assertResolveFunctionsPresent = assertResolveFunctionsPresent_1.default;\nvar attachDirectiveResolvers_1 = __webpack_require__(/*! ./attachDirectiveResolvers */ \"./src/generate/attachDirectiveResolvers.ts\");\nexports.attachDirectiveResolvers = attachDirectiveResolvers_1.default;\nvar attachConnectorsToContext_1 = __webpack_require__(/*! ./attachConnectorsToContext */ \"./src/generate/attachConnectorsToContext.ts\");\nexports.attachConnectorsToContext = attachConnectorsToContext_1.default;\nvar buildSchemaFromTypeDefinitions_1 = __webpack_require__(/*! ./buildSchemaFromTypeDefinitions */ \"./src/generate/buildSchemaFromTypeDefinitions.ts\");\nexports.buildSchemaFromTypeDefinitions = buildSchemaFromTypeDefinitions_1.default;\nvar chainResolvers_1 = __webpack_require__(/*! ./chainResolvers */ \"./src/generate/chainResolvers.ts\");\nexports.chainResolvers = chainResolvers_1.chainResolvers;\nvar checkForResolveTypeResolver_1 = __webpack_require__(/*! ./checkForResolveTypeResolver */ \"./src/generate/checkForResolveTypeResolver.ts\");\nexports.checkForResolveTypeResolver = checkForResolveTypeResolver_1.default;\nvar concatenateTypeDefs_1 = __webpack_require__(/*! ./concatenateTypeDefs */ \"./src/generate/concatenateTypeDefs.ts\");\nexports.concatenateTypeDefs = concatenateTypeDefs_1.default;\nvar decorateWithLogger_1 = __webpack_require__(/*! ./decorateWithLogger */ \"./src/generate/decorateWithLogger.ts\");\nexports.decorateWithLogger = decorateWithLogger_1.default;\nvar extendResolversFromInterfaces_1 = __webpack_require__(/*! ./extendResolversFromInterfaces */ \"./src/generate/extendResolversFromInterfaces.ts\");\nexports.extendResolversFromInterfaces = extendResolversFromInterfaces_1.default;\nvar extractExtensionDefinitions_1 = __webpack_require__(/*! ./extractExtensionDefinitions */ \"./src/generate/extractExtensionDefinitions.ts\");\nexports.extractExtensionDefinitions = extractExtensionDefinitions_1.default;\nvar forEachField_1 = __webpack_require__(/*! ./forEachField */ \"./src/generate/forEachField.ts\");\nexports.forEachField = forEachField_1.default;\nvar SchemaError_1 = __webpack_require__(/*! ./SchemaError */ \"./src/generate/SchemaError.ts\");\nexports.SchemaError = SchemaError_1.default;\n\n\n//# sourceURL=webpack:///./src/generate/index.ts?");

/***/ }),

/***/ "./src/implementsAbstractType.ts":
/*!***************************************!*\
  !*** ./src/implementsAbstractType.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nfunction implementsAbstractType(schema, typeA, typeB) {\n    if (typeA === typeB) {\n        return true;\n    }\n    else if (graphql_1.isCompositeType(typeA) && graphql_1.isCompositeType(typeB)) {\n        return graphql_1.doTypesOverlap(schema, typeA, typeB);\n    }\n    else {\n        return false;\n    }\n}\nexports.default = implementsAbstractType;\n\n\n//# sourceURL=webpack:///./src/implementsAbstractType.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./makeExecutableSchema */ \"./src/makeExecutableSchema.ts\"));\n__export(__webpack_require__(/*! ./mock */ \"./src/mock.ts\"));\n__export(__webpack_require__(/*! ./stitching */ \"./src/stitching/index.ts\"));\n__export(__webpack_require__(/*! ./transforms */ \"./src/transforms/index.ts\"));\nvar schemaVisitor_1 = __webpack_require__(/*! ./schemaVisitor */ \"./src/schemaVisitor.ts\");\nexports.SchemaDirectiveVisitor = schemaVisitor_1.SchemaDirectiveVisitor;\n\n\n//# sourceURL=webpack:///./src/index.ts?");

/***/ }),

/***/ "./src/isEmptyObject.ts":
/*!******************************!*\
  !*** ./src/isEmptyObject.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nfunction isEmptyObject(obj) {\n    if (!obj) {\n        return true;\n    }\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.default = isEmptyObject;\n\n\n//# sourceURL=webpack:///./src/isEmptyObject.ts?");

/***/ }),

/***/ "./src/isSpecifiedScalarType.ts":
/*!**************************************!*\
  !*** ./src/isSpecifiedScalarType.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\n// FIXME: Replace with https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L139\nexports.specifiedScalarTypes = [\n    graphql_1.GraphQLString,\n    graphql_1.GraphQLInt,\n    graphql_1.GraphQLFloat,\n    graphql_1.GraphQLBoolean,\n    graphql_1.GraphQLID,\n];\nfunction isSpecifiedScalarType(type) {\n    return (graphql_1.isNamedType(type) &&\n        // Would prefer to use specifiedScalarTypes.some(), however %checks needs\n        // a simple expression.\n        (type.name === graphql_1.GraphQLString.name ||\n            type.name === graphql_1.GraphQLInt.name ||\n            type.name === graphql_1.GraphQLFloat.name ||\n            type.name === graphql_1.GraphQLBoolean.name ||\n            type.name === graphql_1.GraphQLID.name));\n}\nexports.default = isSpecifiedScalarType;\n\n\n//# sourceURL=webpack:///./src/isSpecifiedScalarType.ts?");

/***/ }),

/***/ "./src/makeExecutableSchema.ts":
/*!*************************************!*\
  !*** ./src/makeExecutableSchema.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar schemaVisitor_1 = __webpack_require__(/*! ./schemaVisitor */ \"./src/schemaVisitor.ts\");\nvar mergeDeep_1 = __webpack_require__(/*! ./mergeDeep */ \"./src/mergeDeep.ts\");\nvar generate_1 = __webpack_require__(/*! ./generate */ \"./src/generate/index.ts\");\nfunction makeExecutableSchema(_a) {\n    var typeDefs = _a.typeDefs, _b = _a.resolvers, resolvers = _b === void 0 ? {} : _b, connectors = _a.connectors, logger = _a.logger, _c = _a.allowUndefinedInResolve, allowUndefinedInResolve = _c === void 0 ? true : _c, _d = _a.resolverValidationOptions, resolverValidationOptions = _d === void 0 ? {} : _d, _e = _a.directiveResolvers, directiveResolvers = _e === void 0 ? null : _e, _f = _a.schemaDirectives, schemaDirectives = _f === void 0 ? null : _f, _g = _a.parseOptions, parseOptions = _g === void 0 ? {} : _g, _h = _a.inheritResolversFromInterfaces, inheritResolversFromInterfaces = _h === void 0 ? false : _h;\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new generate_1.SchemaError('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new generate_1.SchemaError('Must provide typeDefs');\n    }\n    if (!resolvers) {\n        throw new generate_1.SchemaError('Must provide resolvers');\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    var resolverMap = Array.isArray(resolvers)\n        ? resolvers.filter(function (resolverObj) { return typeof resolverObj === 'object'; }).reduce(mergeDeep_1.default, {})\n        : resolvers;\n    // Arguments are now validated and cleaned up\n    var schema = generate_1.buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n    schema = generate_1.addResolveFunctionsToSchema({\n        schema: schema,\n        resolvers: resolverMap,\n        resolverValidationOptions: resolverValidationOptions,\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces\n    });\n    generate_1.assertResolveFunctionsPresent(schema, resolverValidationOptions);\n    if (!allowUndefinedInResolve) {\n        addCatchUndefinedToSchema(schema);\n    }\n    if (logger) {\n        addErrorLoggingToSchema(schema, logger);\n    }\n    if (typeof resolvers['__schema'] === 'function') {\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n        // not doing that now, because I'd have to rewrite a lot of tests.\n        generate_1.addSchemaLevelResolveFunction(schema, resolvers['__schema']);\n    }\n    if (connectors) {\n        // connectors are optional, at least for now. That means you can just import them in the resolve\n        // function if you want.\n        generate_1.attachConnectorsToContext(schema, connectors);\n    }\n    if (directiveResolvers) {\n        generate_1.attachDirectiveResolvers(schema, directiveResolvers);\n    }\n    if (schemaDirectives) {\n        schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n    }\n    return schema;\n}\nexports.makeExecutableSchema = makeExecutableSchema;\nfunction decorateToCatchUndefined(fn, hint) {\n    if (typeof fn === 'undefined') {\n        fn = graphql_1.defaultFieldResolver;\n    }\n    return function (root, args, ctx, info) {\n        var result = fn(root, args, ctx, info);\n        if (typeof result === 'undefined') {\n            throw new Error(\"Resolve function for \\\"\" + hint + \"\\\" returned undefined\");\n        }\n        return result;\n    };\n}\nfunction addCatchUndefinedToSchema(schema) {\n    generate_1.forEachField(schema, function (field, typeName, fieldName) {\n        var errorHint = typeName + \".\" + fieldName;\n        field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n    });\n}\nexports.addCatchUndefinedToSchema = addCatchUndefinedToSchema;\nfunction addErrorLoggingToSchema(schema, logger) {\n    if (!logger) {\n        throw new Error('Must provide a logger');\n    }\n    if (typeof logger.log !== 'function') {\n        throw new Error('Logger.log must be a function');\n    }\n    generate_1.forEachField(schema, function (field, typeName, fieldName) {\n        var errorHint = typeName + \".\" + fieldName;\n        field.resolve = generate_1.decorateWithLogger(field.resolve, logger, errorHint);\n    });\n}\nexports.addErrorLoggingToSchema = addErrorLoggingToSchema;\n__export(__webpack_require__(/*! ./generate */ \"./src/generate/index.ts\"));\n\n\n//# sourceURL=webpack:///./src/makeExecutableSchema.ts?");

/***/ }),

/***/ "./src/mergeDeep.ts":
/*!**************************!*\
  !*** ./src/mergeDeep.ts ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nfunction mergeDeep(target, source) {\n    var output = Object.assign({}, target);\n    if (isObject(target) && isObject(source)) {\n        Object.keys(source).forEach(function (key) {\n            var _a, _b;\n            if (isObject(source[key])) {\n                if (!(key in target)) {\n                    Object.assign(output, (_a = {}, _a[key] = source[key], _a));\n                }\n                else {\n                    output[key] = mergeDeep(target[key], source[key]);\n                }\n            }\n            else {\n                Object.assign(output, (_b = {}, _b[key] = source[key], _b));\n            }\n        });\n    }\n    return output;\n}\nexports.default = mergeDeep;\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n\n\n//# sourceURL=webpack:///./src/mergeDeep.ts?");

/***/ }),

/***/ "./src/mock.ts":
/*!*********************!*\
  !*** ./src/mock.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar uuid = __webpack_require__(/*! uuid */ \"uuid\");\nvar makeExecutableSchema_1 = __webpack_require__(/*! ./makeExecutableSchema */ \"./src/makeExecutableSchema.ts\");\n// This function wraps addMockFunctionsToSchema for more convenience\nfunction mockServer(schema, mocks, preserveResolvers) {\n    if (preserveResolvers === void 0) { preserveResolvers = false; }\n    var mySchema;\n    if (!(schema instanceof graphql_1.GraphQLSchema)) {\n        // TODO: provide useful error messages here if this fails\n        mySchema = makeExecutableSchema_1.buildSchemaFromTypeDefinitions(schema);\n    }\n    else {\n        mySchema = schema;\n    }\n    addMockFunctionsToSchema({ schema: mySchema, mocks: mocks, preserveResolvers: preserveResolvers });\n    return { query: function (query, vars) { return graphql_1.graphql(mySchema, query, {}, {}, vars); } };\n}\nexports.mockServer = mockServer;\nvar defaultMockMap = new Map();\ndefaultMockMap.set('Int', function () { return Math.round(Math.random() * 200) - 100; });\ndefaultMockMap.set('Float', function () { return Math.random() * 200 - 100; });\ndefaultMockMap.set('String', function () { return 'Hello World'; });\ndefaultMockMap.set('Boolean', function () { return Math.random() > 0.5; });\ndefaultMockMap.set('ID', function () { return uuid.v4(); });\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\nfunction addMockFunctionsToSchema(_a) {\n    var schema = _a.schema, _b = _a.mocks, mocks = _b === void 0 ? {} : _b, _c = _a.preserveResolvers, preserveResolvers = _c === void 0 ? false : _c;\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!(schema instanceof graphql_1.GraphQLSchema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (!isObject(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    // use Map internally, because that API is nicer.\n    var mockFunctionMap = new Map();\n    Object.keys(mocks).forEach(function (typeName) {\n        mockFunctionMap.set(typeName, mocks[typeName]);\n    });\n    mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\n        if (typeof mockFunction !== 'function') {\n            throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\n        }\n    });\n    var mockType = function (type, typeName, fieldName) {\n        // order of precendence for mocking:\n        // 1. if the object passed in already has fieldName, just use that\n        // --> if it's a function, that becomes your resolver\n        // --> if it's a value, the mock resolver will return that\n        // 2. if the nullableType is a list, recurse\n        // 2. if there's a mock defined for this typeName, that will be used\n        // 3. if there's no mock defined, use the default mocks for this type\n        return function (root, args, context, info) {\n            // nullability doesn't matter for the purpose of mocking.\n            var fieldType = graphql_1.getNullableType(type);\n            var namedFieldType = graphql_1.getNamedType(fieldType);\n            if (root && typeof root[fieldName] !== 'undefined') {\n                var result = void 0;\n                // if we're here, the field is already defined\n                if (typeof root[fieldName] === 'function') {\n                    result = root[fieldName](root, args, context, info);\n                    if (result instanceof MockList) {\n                        result = result.mock(root, args, context, info, fieldType, mockType);\n                    }\n                }\n                else {\n                    result = root[fieldName];\n                }\n                // Now we merge the result with the default mock for this type.\n                // This allows overriding defaults while writing very little code.\n                if (mockFunctionMap.has(namedFieldType.name)) {\n                    result = mergeMocks(mockFunctionMap.get(namedFieldType.name).bind(null, root, args, context, info), result);\n                }\n                return result;\n            }\n            if (fieldType instanceof graphql_1.GraphQLList || fieldType instanceof graphql_1.GraphQLNonNull) {\n                return [\n                    mockType(fieldType.ofType)(root, args, context, info),\n                    mockType(fieldType.ofType)(root, args, context, info)\n                ];\n            }\n            if (mockFunctionMap.has(fieldType.name) &&\n                !(fieldType instanceof graphql_1.GraphQLUnionType || fieldType instanceof graphql_1.GraphQLInterfaceType)) {\n                // the object passed doesn't have this field, so we apply the default mock\n                return mockFunctionMap.get(fieldType.name)(root, args, context, info);\n            }\n            if (fieldType instanceof graphql_1.GraphQLObjectType) {\n                // objects don't return actual data, we only need to mock scalars!\n                return {};\n            }\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n            // otherwise randomly pick a type from all implementation types\n            if (fieldType instanceof graphql_1.GraphQLUnionType || fieldType instanceof graphql_1.GraphQLInterfaceType) {\n                var implementationType = void 0;\n                if (mockFunctionMap.has(fieldType.name)) {\n                    var interfaceMockObj = mockFunctionMap.get(fieldType.name)(root, args, context, info);\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\n                        return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\n                    }\n                    implementationType = schema.getType(interfaceMockObj.__typename);\n                }\n                else {\n                    var possibleTypes = schema.getPossibleTypes(fieldType);\n                    implementationType = getRandomElement(possibleTypes);\n                }\n                return Object.assign({ __typename: implementationType }, mockType(implementationType)(root, args, context, info));\n            }\n            if (fieldType instanceof graphql_1.GraphQLEnumType) {\n                return getRandomElement(fieldType.getValues()).value;\n            }\n            if (defaultMockMap.has(fieldType.name)) {\n                return defaultMockMap.get(fieldType.name)(root, args, context, info);\n            }\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\n            // we could return undefined, but that would be hard to debug, so we throw instead.\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n            return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\n        };\n    };\n    makeExecutableSchema_1.forEachField(schema, function (field, typeName, fieldName) {\n        assignResolveType(field.type, preserveResolvers);\n        var mockResolver;\n        // we have to handle the root mutation and root query types differently,\n        // because no resolver is called at the root.\n        /* istanbul ignore next: Must provide schema DefinitionNode with query type or a type named Query. */\n        var isOnQueryType = schema.getQueryType() && schema.getQueryType().name === typeName;\n        var isOnMutationType = schema.getMutationType() && schema.getMutationType().name === typeName;\n        if (isOnQueryType || isOnMutationType) {\n            if (mockFunctionMap.has(typeName)) {\n                var rootMock_1 = mockFunctionMap.get(typeName);\n                // XXX: BUG in here, need to provide proper signature for rootMock.\n                if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] === 'function') {\n                    mockResolver = function (root, args, context, info) {\n                        var updatedRoot = root || {}; // TODO: should we clone instead?\n                        updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName];\n                        // XXX this is a bit of a hack to still use mockType, which\n                        // lets you mock lists etc. as well\n                        // otherwise we could just set field.resolve to rootMock()[fieldName]\n                        // it's like pretending there was a resolve function that ran before\n                        // the root resolve function.\n                        return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\n                    };\n                }\n            }\n        }\n        if (!mockResolver) {\n            mockResolver = mockType(field.type, typeName, fieldName);\n        }\n        if (!preserveResolvers || !field.resolve) {\n            field.resolve = mockResolver;\n        }\n        else {\n            var oldResolver_1 = field.resolve;\n            field.resolve = function (rootObject, args, context, info) {\n                return Promise.all([\n                    mockResolver(rootObject, args, context, info),\n                    oldResolver_1(rootObject, args, context, info)\n                ]).then(function (values) {\n                    var mockedValue = values[0], resolvedValue = values[1];\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if (isObject(mockedValue) && isObject(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                });\n            };\n        }\n    });\n}\nexports.addMockFunctionsToSchema = addMockFunctionsToSchema;\nfunction isObject(thing) {\n    return thing === Object(thing) && !Array.isArray(thing);\n}\n// returns a random element from that ary\nfunction getRandomElement(ary) {\n    var sample = Math.floor(Math.random() * ary.length);\n    return ary[sample];\n}\nfunction mergeObjects(a, b) {\n    return Object.assign(a, b);\n}\nfunction copyOwnPropsIfNotPresent(target, source) {\n    Object.getOwnPropertyNames(source).forEach(function (prop) {\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\n            Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n        }\n    });\n}\nfunction copyOwnProps(target) {\n    var sources = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        sources[_i - 1] = arguments[_i];\n    }\n    sources.forEach(function (source) {\n        var chain = source;\n        while (chain) {\n            copyOwnPropsIfNotPresent(target, chain);\n            chain = Object.getPrototypeOf(chain);\n        }\n    });\n    return target;\n}\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction, customMock) {\n    if (Array.isArray(customMock)) {\n        return customMock.map(function (el) { return mergeMocks(genericMockFunction, el); });\n    }\n    if (isObject(customMock)) {\n        return mergeObjects(genericMockFunction(), customMock);\n    }\n    return customMock;\n}\nfunction getResolveType(namedFieldType) {\n    if (namedFieldType instanceof graphql_1.GraphQLInterfaceType || namedFieldType instanceof graphql_1.GraphQLUnionType) {\n        return namedFieldType.resolveType;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction assignResolveType(type, preserveResolvers) {\n    var fieldType = graphql_1.getNullableType(type);\n    var namedFieldType = graphql_1.getNamedType(fieldType);\n    var oldResolveType = getResolveType(namedFieldType);\n    if (preserveResolvers && oldResolveType && oldResolveType.length) {\n        return;\n    }\n    if (namedFieldType instanceof graphql_1.GraphQLUnionType || namedFieldType instanceof graphql_1.GraphQLInterfaceType) {\n        // the default `resolveType` always returns null. We add a fallback\n        // resolution that works with how unions and interface are mocked\n        namedFieldType.resolveType = function (data, context, info) {\n            return info.schema.getType(data.__typename);\n        };\n    }\n}\nvar MockList = /** @class */ (function () {\n    // wrappedFunction can return another MockList or a value\n    function MockList(len, wrappedFunction) {\n        this.len = len;\n        if (typeof wrappedFunction !== 'undefined') {\n            if (typeof wrappedFunction !== 'function') {\n                throw new Error('Second argument to MockList must be a function or undefined');\n            }\n            this.wrappedFunction = wrappedFunction;\n        }\n    }\n    MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\n        var arr;\n        if (Array.isArray(this.len)) {\n            arr = new Array(this.randint(this.len[0], this.len[1]));\n        }\n        else {\n            arr = new Array(this.len);\n        }\n        for (var i = 0; i < arr.length; i++) {\n            if (typeof this.wrappedFunction === 'function') {\n                var res = this.wrappedFunction(root, args, context, info);\n                if (res instanceof MockList) {\n                    var nullableType = graphql_1.getNullableType(fieldType.ofType);\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n                }\n                else {\n                    arr[i] = res;\n                }\n            }\n            else {\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n            }\n        }\n        return arr;\n    };\n    MockList.prototype.randint = function (low, high) {\n        return Math.floor(Math.random() * (high - low + 1) + low);\n    };\n    return MockList;\n}());\nexports.MockList = MockList;\n\n\n//# sourceURL=webpack:///./src/mock.ts?");

/***/ }),

/***/ "./src/schemaVisitor.ts":
/*!******************************!*\
  !*** ./src/schemaVisitor.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar values_1 = __webpack_require__(/*! graphql/execution/values */ \"graphql/execution/values\");\nvar hasOwn = Object.prototype.hasOwnProperty;\n// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nvar SchemaVisitor = /** @class */ (function () {\n    function SchemaVisitor() {\n    }\n    // Determine if this SchemaVisitor (sub)class implements a particular\n    // visitor method.\n    SchemaVisitor.implementsVisitorMethod = function (methodName) {\n        if (!methodName.startsWith('visit')) {\n            return false;\n        }\n        var method = this.prototype[methodName];\n        if (typeof method !== 'function') {\n            return false;\n        }\n        if (this === SchemaVisitor) {\n            // The SchemaVisitor class implements every visitor method.\n            return true;\n        }\n        var stub = SchemaVisitor.prototype[methodName];\n        if (method === stub) {\n            // If this.prototype[methodName] was just inherited from SchemaVisitor,\n            // then this class does not really implement the method.\n            return false;\n        }\n        return true;\n    };\n    // Concrete subclasses of SchemaVisitor should override one or more of these\n    // visitor methods, in order to express their interest in handling certain\n    // schema types/locations. Each method may return null to remove the given\n    // type from the schema, a non-null value of the same type to update the\n    // type in the schema, or nothing to leave the type as it was.\n    /* tslint:disable:no-empty */\n    SchemaVisitor.prototype.visitSchema = function (schema) { };\n    SchemaVisitor.prototype.visitScalar = function (scalar) { };\n    SchemaVisitor.prototype.visitObject = function (object) { };\n    SchemaVisitor.prototype.visitFieldDefinition = function (field, details) { };\n    SchemaVisitor.prototype.visitArgumentDefinition = function (argument, details) { };\n    SchemaVisitor.prototype.visitInterface = function (iface) { };\n    SchemaVisitor.prototype.visitUnion = function (union) { };\n    SchemaVisitor.prototype.visitEnum = function (type) { };\n    SchemaVisitor.prototype.visitEnumValue = function (value, details) { };\n    SchemaVisitor.prototype.visitInputObject = function (object) { };\n    SchemaVisitor.prototype.visitInputFieldDefinition = function (field, details) { };\n    return SchemaVisitor;\n}());\nexports.SchemaVisitor = SchemaVisitor;\n// Generic function for visiting GraphQLSchema objects.\nfunction visitSchema(schema, \n// To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorSelector) {\n    // Helper function that calls visitorSelector and applies the resulting\n    // visitors to the given type, with arguments [type, ...args].\n    function callMethod(methodName, type) {\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        visitorSelector(type, methodName).every(function (visitor) {\n            var newType = visitor[methodName].apply(visitor, [type].concat(args));\n            if (typeof newType === 'undefined') {\n                // Keep going without modifying type.\n                return true;\n            }\n            if (methodName === 'visitSchema' || type instanceof graphql_1.GraphQLSchema) {\n                throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\n            }\n            if (newType === null) {\n                // Stop the loop and return null form callMethod, which will cause\n                // the type to be removed from the schema.\n                type = null;\n                return false;\n            }\n            // Update type to the new type returned by the visitor method, so that\n            // later directives will see the new type, and callMethod will return\n            // the final type.\n            type = newType;\n            return true;\n        });\n        // If there were no directives for this type object, or if all visitor\n        // methods returned nothing, type will be returned unmodified.\n        return type;\n    }\n    // Recursive helper function that calls any appropriate visitor methods for\n    // each object in the schema, then traverses the object's children (if any).\n    function visit(type) {\n        if (type instanceof graphql_1.GraphQLSchema) {\n            // Unlike the other types, the root GraphQLSchema object cannot be\n            // replaced by visitor methods, because that would make life very hard\n            // for SchemaVisitor subclasses that rely on the original schema object.\n            callMethod('visitSchema', type);\n            updateEachKey(type.getTypeMap(), function (namedType, typeName) {\n                if (!typeName.startsWith('__')) {\n                    // Call visit recursively to let it determine which concrete\n                    // subclass of GraphQLNamedType we found in the type map. Because\n                    // we're using updateEachKey, the result of visit(namedType) may\n                    // cause the type to be removed or replaced.\n                    return visit(namedType);\n                }\n            });\n            return type;\n        }\n        if (type instanceof graphql_1.GraphQLObjectType) {\n            // Note that callMethod('visitObject', type) may not actually call any\n            // methods, if there are no @directive annotations associated with this\n            // type, or if this SchemaDirectiveVisitor subclass does not override\n            // the visitObject method.\n            var newObject = callMethod('visitObject', type);\n            if (newObject) {\n                visitFields(newObject);\n            }\n            return newObject;\n        }\n        if (type instanceof graphql_1.GraphQLInterfaceType) {\n            var newInterface = callMethod('visitInterface', type);\n            if (newInterface) {\n                visitFields(newInterface);\n            }\n            return newInterface;\n        }\n        if (type instanceof graphql_1.GraphQLInputObjectType) {\n            var newInputObject_1 = callMethod('visitInputObject', type);\n            if (newInputObject_1) {\n                updateEachKey(newInputObject_1.getFields(), function (field) {\n                    // Since we call a different method for input object fields, we\n                    // can't reuse the visitFields function here.\n                    return callMethod('visitInputFieldDefinition', field, {\n                        objectType: newInputObject_1\n                    });\n                });\n            }\n            return newInputObject_1;\n        }\n        if (type instanceof graphql_1.GraphQLScalarType) {\n            return callMethod('visitScalar', type);\n        }\n        if (type instanceof graphql_1.GraphQLUnionType) {\n            return callMethod('visitUnion', type);\n        }\n        if (type instanceof graphql_1.GraphQLEnumType) {\n            var newEnum_1 = callMethod('visitEnum', type);\n            if (newEnum_1) {\n                updateEachKey(newEnum_1.getValues(), function (value) {\n                    return callMethod('visitEnumValue', value, {\n                        enumType: newEnum_1\n                    });\n                });\n            }\n            return newEnum_1;\n        }\n        throw new Error(\"Unexpected schema type: \" + type);\n    }\n    function visitFields(type) {\n        updateEachKey(type.getFields(), function (field) {\n            // It would be nice if we could call visit(field) recursively here, but\n            // GraphQLField is merely a type, not a value that can be detected using\n            // an instanceof check, so we have to visit the fields in this lexical\n            // context, so that TypeScript can validate the call to\n            // visitFieldDefinition.\n            var newField = callMethod('visitFieldDefinition', field, {\n                // While any field visitor needs a reference to the field object, some\n                // field visitors may also need to know the enclosing (parent) type,\n                // perhaps to determine if the parent is a GraphQLObjectType or a\n                // GraphQLInterfaceType. To obtain a reference to the parent, a\n                // visitor method can have a second parameter, which will be an object\n                // with an .objectType property referring to the parent.\n                objectType: type\n            });\n            if (newField && newField.args) {\n                updateEachKey(newField.args, function (arg) {\n                    return callMethod('visitArgumentDefinition', arg, {\n                        // Like visitFieldDefinition, visitArgumentDefinition takes a\n                        // second parameter that provides additional context, namely the\n                        // parent .field and grandparent .objectType. Remember that the\n                        // current GraphQLSchema is always available via this.schema.\n                        field: newField,\n                        objectType: type\n                    });\n                });\n            }\n            return newField;\n        });\n    }\n    visit(schema);\n    // Return the original schema for convenience, even though it cannot have\n    // been replaced or removed by the code above.\n    return schema;\n}\nexports.visitSchema = visitSchema;\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\nfunction healSchema(schema) {\n    heal(schema);\n    return schema;\n    function heal(type) {\n        if (type instanceof graphql_1.GraphQLSchema) {\n            var originalTypeMap_1 = type.getTypeMap();\n            var actualNamedTypeMap_1 = Object.create(null);\n            // If any of the .name properties of the GraphQLNamedType objects in\n            // schema.getTypeMap() have changed, the keys of the type map need to\n            // be updated accordingly.\n            each(originalTypeMap_1, function (namedType, typeName) {\n                if (typeName.startsWith('__')) {\n                    return;\n                }\n                var actualName = namedType.name;\n                if (actualName.startsWith('__')) {\n                    return;\n                }\n                if (hasOwn.call(actualNamedTypeMap_1, actualName)) {\n                    throw new Error(\"Duplicate schema type name \" + actualName);\n                }\n                actualNamedTypeMap_1[actualName] = namedType;\n                // Note: we are deliberately leaving namedType in the schema by its\n                // original name (which might be different from actualName), so that\n                // references by that name can be healed.\n            });\n            // Now add back every named type by its actual name.\n            each(actualNamedTypeMap_1, function (namedType, typeName) {\n                originalTypeMap_1[typeName] = namedType;\n            });\n            // Directive declaration argument types can refer to named types.\n            each(type.getDirectives(), function (decl) {\n                if (decl.args) {\n                    each(decl.args, function (arg) {\n                        arg.type = healType(arg.type);\n                    });\n                }\n            });\n            each(originalTypeMap_1, function (namedType, typeName) {\n                if (!typeName.startsWith('__')) {\n                    heal(namedType);\n                }\n            });\n            updateEachKey(originalTypeMap_1, function (namedType, typeName) {\n                // Dangling references to renamed types should remain in the schema\n                // during healing, but must be removed now, so that the following\n                // invariant holds for all names: schema.getType(name).name === name\n                if (!typeName.startsWith('__') && !hasOwn.call(actualNamedTypeMap_1, typeName)) {\n                    return null;\n                }\n            });\n        }\n        else if (type instanceof graphql_1.GraphQLObjectType) {\n            healFields(type);\n            each(type.getInterfaces(), function (iface) { return heal(iface); });\n        }\n        else if (type instanceof graphql_1.GraphQLInterfaceType) {\n            healFields(type);\n        }\n        else if (type instanceof graphql_1.GraphQLInputObjectType) {\n            each(type.getFields(), function (field) {\n                field.type = healType(field.type);\n            });\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            // Nothing to do.\n        }\n        else if (type instanceof graphql_1.GraphQLUnionType) {\n            updateEachKey(type.getTypes(), function (t) { return healType(t); });\n        }\n        else if (type instanceof graphql_1.GraphQLEnumType) {\n            // Nothing to do.\n        }\n        else {\n            throw new Error(\"Unexpected schema type: \" + type);\n        }\n    }\n    function healFields(type) {\n        each(type.getFields(), function (field) {\n            field.type = healType(field.type);\n            if (field.args) {\n                each(field.args, function (arg) {\n                    arg.type = healType(arg.type);\n                });\n            }\n        });\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (type instanceof graphql_1.GraphQLList) {\n            type = new graphql_1.GraphQLList(healType(type.ofType));\n        }\n        else if (type instanceof graphql_1.GraphQLNonNull) {\n            type = new graphql_1.GraphQLNonNull(healType(type.ofType));\n        }\n        else if (graphql_1.isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            var namedType = type;\n            var officialType = schema.getType(namedType.name);\n            if (officialType && namedType !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\nexports.healSchema = healSchema;\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\nvar SchemaDirectiveVisitor = /** @class */ (function (_super) {\n    __extends(SchemaDirectiveVisitor, _super);\n    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n    // subclasses (not instances) to visitSchemaDirectives.\n    function SchemaDirectiveVisitor(config) {\n        var _this = _super.call(this) || this;\n        _this.name = config.name;\n        _this.args = config.args;\n        _this.visitedType = config.visitedType;\n        _this.schema = config.schema;\n        _this.context = config.context;\n        return _this;\n    }\n    // Override this method to return a custom GraphQLDirective (or modify one\n    // already present in the schema) to enforce argument types, provide default\n    // argument values, or specify schema locations where this @directive may\n    // appear. By default, any declaration found in the schema will be returned.\n    SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\n        return schema.getDirective(directiveName);\n    };\n    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n    // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n    // instance to visit the object decorated by the @directive.\n    SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, \n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context) {\n        if (context === void 0) { \n        // Optional context object that will be available to all visitor instances\n        // via this.context. Defaults to an empty null-prototype object.\n        context = Object.create(null); }\n        // If the schema declares any directives for public consumption, record\n        // them here so that we can properly coerce arguments when/if we encounter\n        // an occurrence of the directive while walking the schema below.\n        var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\n        // Map from directive names to lists of SchemaDirectiveVisitor instances\n        // created while visiting the schema.\n        var createdVisitors = Object.create(null);\n        Object.keys(directiveVisitors).forEach(function (directiveName) {\n            createdVisitors[directiveName] = [];\n        });\n        function visitorSelector(type, methodName) {\n            var visitors = [];\n            var directiveNodes = type.astNode && type.astNode.directives;\n            if (!directiveNodes) {\n                return visitors;\n            }\n            directiveNodes.forEach(function (directiveNode) {\n                var directiveName = directiveNode.name.value;\n                if (!hasOwn.call(directiveVisitors, directiveName)) {\n                    return;\n                }\n                var visitorClass = directiveVisitors[directiveName];\n                // Avoid creating visitor objects if visitorClass does not override\n                // the visitor method named by methodName.\n                if (!visitorClass.implementsVisitorMethod(methodName)) {\n                    return;\n                }\n                var decl = declaredDirectives[directiveName];\n                var args;\n                if (decl) {\n                    // If this directive was explicitly declared, use the declared\n                    // argument types (and any default values) to check, coerce, and/or\n                    // supply default values for the given arguments.\n                    args = values_1.getArgumentValues(decl, directiveNode);\n                }\n                else {\n                    // If this directive was not explicitly declared, just convert the\n                    // argument nodes to their corresponding JavaScript values.\n                    args = Object.create(null);\n                    directiveNode.arguments.forEach(function (arg) {\n                        args[arg.name.value] = valueFromASTUntyped(arg.value);\n                    });\n                }\n                // As foretold in comments near the top of the visitSchemaDirectives\n                // method, this is where instances of the SchemaDirectiveVisitor class\n                // get created and assigned names. While subclasses could override the\n                // constructor method, the constructor is marked as protected, so\n                // these are the only arguments that will ever be passed.\n                visitors.push(new visitorClass({\n                    name: directiveName,\n                    args: args,\n                    visitedType: type,\n                    schema: schema,\n                    context: context\n                }));\n            });\n            if (visitors.length > 0) {\n                visitors.forEach(function (visitor) {\n                    createdVisitors[visitor.name].push(visitor);\n                });\n            }\n            return visitors;\n        }\n        visitSchema(schema, visitorSelector);\n        // Automatically update any references to named schema types replaced\n        // during the traversal, so implementors don't have to worry about that.\n        healSchema(schema);\n        return createdVisitors;\n    };\n    SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\n        var declaredDirectives = Object.create(null);\n        each(schema.getDirectives(), function (decl) {\n            declaredDirectives[decl.name] = decl;\n        });\n        // If the visitor subclass overrides getDirectiveDeclaration, and it\n        // returns a non-null GraphQLDirective, use that instead of any directive\n        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n        // goes to the trouble of implementing getDirectiveDeclaration, it should\n        // be able to rely on that implementation.\n        each(directiveVisitors, function (visitorClass, directiveName) {\n            var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n            if (decl) {\n                declaredDirectives[directiveName] = decl;\n            }\n        });\n        each(declaredDirectives, function (decl, name) {\n            if (!hasOwn.call(directiveVisitors, name)) {\n                // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n                // multiple times with partial directiveVisitors maps, so it's not\n                // necessarily an error for directiveVisitors to be missing an\n                // implementation of a directive that was declared in the schema.\n                return;\n            }\n            var visitorClass = directiveVisitors[name];\n            each(decl.locations, function (loc) {\n                var visitorMethodName = directiveLocationToVisitorMethodName(loc);\n                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n                    // While visitor subclasses may implement extra visitor methods,\n                    // it's definitely a mistake if the GraphQLDirective declares itself\n                    // applicable to certain schema locations, and the visitor subclass\n                    // does not implement all the corresponding methods.\n                    throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\n                }\n            });\n        });\n        return declaredDirectives;\n    };\n    return SchemaDirectiveVisitor;\n}(SchemaVisitor));\nexports.SchemaDirectiveVisitor = SchemaDirectiveVisitor;\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc) {\n    return ('visit' +\n        loc.replace(/([^_]*)_?/g, function (wholeMatch, part) {\n            return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n        }));\n}\nfunction each(arrayOrObject, callback) {\n    Object.keys(arrayOrObject).forEach(function (key) {\n        callback(arrayOrObject[key], key);\n    });\n}\n// A more powerful version of each that has the ability to replace or remove\n// array or object keys.\nfunction updateEachKey(arrayOrObject, \n// The callback can return nothing to leave the key untouched, null to remove\n// the key from the array or object, or a non-null V to replace the value.\ncallback) {\n    var deletedCount = 0;\n    Object.keys(arrayOrObject).forEach(function (key) {\n        var result = callback(arrayOrObject[key], key);\n        if (typeof result === 'undefined') {\n            return;\n        }\n        if (result === null) {\n            delete arrayOrObject[key];\n            deletedCount++;\n            return;\n        }\n        arrayOrObject[key] = result;\n    });\n    if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n        // Remove any holes from the array due to deleted elements.\n        arrayOrObject.splice(0).forEach(function (elem) {\n            arrayOrObject.push(elem);\n        });\n    }\n}\n// Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\nfunction valueFromASTUntyped(valueNode) {\n    switch (valueNode.kind) {\n        case graphql_1.Kind.NULL:\n            return null;\n        case graphql_1.Kind.INT:\n            return parseInt(valueNode.value, 10);\n        case graphql_1.Kind.FLOAT:\n            return parseFloat(valueNode.value);\n        case graphql_1.Kind.STRING:\n        case graphql_1.Kind.ENUM:\n        case graphql_1.Kind.BOOLEAN:\n            return valueNode.value;\n        case graphql_1.Kind.LIST:\n            return valueNode.values.map(valueFromASTUntyped);\n        case graphql_1.Kind.OBJECT:\n            var obj_1 = Object.create(null);\n            valueNode.fields.forEach(function (field) {\n                obj_1[field.name.value] = valueFromASTUntyped(field.value);\n            });\n            return obj_1;\n        /* istanbul ignore next */\n        default:\n            throw new Error('Unexpected value kind: ' + valueNode.kind);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/schemaVisitor.ts?");

/***/ }),

/***/ "./src/stitching/defaultMergedResolver.ts":
/*!************************************************!*\
  !*** ./src/stitching/defaultMergedResolver.ts ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar error_1 = __webpack_require__(/*! graphql/error */ \"graphql/error\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./src/stitching/errors.ts\");\nvar getResponseKeyFromInfo_1 = __webpack_require__(/*! ./getResponseKeyFromInfo */ \"./src/stitching/getResponseKeyFromInfo.ts\");\n// Resolver that knows how to:\n// a) handle aliases for proxied schemas\n// b) handle errors from proxied schemas\nvar defaultMergedResolver = function (parent, args, context, info) {\n    if (!parent) {\n        return null;\n    }\n    var responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);\n    var errorResult = errors_1.getErrorsFromParent(parent, responseKey);\n    if (errorResult.kind === 'OWN') {\n        throw error_1.locatedError(new Error(errorResult.error.message), info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n    }\n    var result = parent[responseKey];\n    if (result == null) {\n        result = parent[info.fieldName];\n    }\n    // subscription result mapping\n    if (!result && parent.data && parent.data[responseKey]) {\n        result = parent.data[responseKey];\n    }\n    if (errorResult.errors) {\n        result = errors_1.annotateWithChildrenErrors(result, errorResult.errors);\n    }\n    return result;\n};\nexports.default = defaultMergedResolver;\n\n\n//# sourceURL=webpack:///./src/stitching/defaultMergedResolver.ts?");

/***/ }),

/***/ "./src/stitching/delegateToSchema.ts":
/*!*******************************************!*\
  !*** ./src/stitching/delegateToSchema.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar transforms_1 = __webpack_require__(/*! ../transforms/transforms */ \"./src/transforms/transforms.ts\");\nvar AddArgumentsAsVariables_1 = __webpack_require__(/*! ../transforms/AddArgumentsAsVariables */ \"./src/transforms/AddArgumentsAsVariables.ts\");\nvar FilterToSchema_1 = __webpack_require__(/*! ../transforms/FilterToSchema */ \"./src/transforms/FilterToSchema.ts\");\nvar AddTypenameToAbstract_1 = __webpack_require__(/*! ../transforms/AddTypenameToAbstract */ \"./src/transforms/AddTypenameToAbstract.ts\");\nvar CheckResultAndHandleErrors_1 = __webpack_require__(/*! ../transforms/CheckResultAndHandleErrors */ \"./src/transforms/CheckResultAndHandleErrors.ts\");\nvar mapAsyncIterator_1 = __webpack_require__(/*! ./mapAsyncIterator */ \"./src/stitching/mapAsyncIterator.ts\");\nvar ExpandAbstractTypes_1 = __webpack_require__(/*! ../transforms/ExpandAbstractTypes */ \"./src/transforms/ExpandAbstractTypes.ts\");\nvar ReplaceFieldWithFragment_1 = __webpack_require__(/*! ../transforms/ReplaceFieldWithFragment */ \"./src/transforms/ReplaceFieldWithFragment.ts\");\nvar ConvertEnumResponse_1 = __webpack_require__(/*! ../transforms/ConvertEnumResponse */ \"./src/transforms/ConvertEnumResponse.ts\");\nfunction delegateToSchema(options) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (options instanceof graphql_1.GraphQLSchema) {\n        throw new Error('Passing positional arguments to delegateToSchema is a deprecated. ' +\n            'Please pass named parameters instead.');\n    }\n    return delegateToSchemaImplementation(options);\n}\nexports.default = delegateToSchema;\nfunction delegateToSchemaImplementation(options) {\n    return __awaiter(this, void 0, void 0, function () {\n        var info, _a, args, operation, rawDocument, rawRequest, transforms, processedRequest, errors, _b, executionResult;\n        return __generator(this, function (_c) {\n            switch (_c.label) {\n                case 0:\n                    info = options.info, _a = options.args, args = _a === void 0 ? {} : _a;\n                    operation = options.operation || info.operation.operation;\n                    rawDocument = createDocument(options.fieldName, operation, info.fieldNodes, Object.keys(info.fragments).map(function (fragmentName) { return info.fragments[fragmentName]; }), info.operation.variableDefinitions, info.operation.name);\n                    rawRequest = {\n                        document: rawDocument,\n                        variables: info.variableValues,\n                    };\n                    transforms = (options.transforms || []).concat([\n                        new ExpandAbstractTypes_1.default(info.schema, options.schema),\n                    ]);\n                    if (info.mergeInfo && info.mergeInfo.fragments) {\n                        transforms.push(new ReplaceFieldWithFragment_1.default(options.schema, info.mergeInfo.fragments));\n                    }\n                    transforms = transforms.concat([\n                        new AddArgumentsAsVariables_1.default(options.schema, args),\n                        new FilterToSchema_1.default(options.schema),\n                        new AddTypenameToAbstract_1.default(options.schema),\n                        new CheckResultAndHandleErrors_1.default(info, options.fieldName),\n                    ]);\n                    if (graphql_1.isEnumType(options.info.returnType)) {\n                        transforms = transforms.concat(new ConvertEnumResponse_1.default(options.info.returnType));\n                    }\n                    processedRequest = transforms_1.applyRequestTransforms(rawRequest, transforms);\n                    if (!options.skipValidation) {\n                        errors = graphql_1.validate(options.schema, processedRequest.document);\n                        if (errors.length > 0) {\n                            throw errors;\n                        }\n                    }\n                    if (!(operation === 'query' || operation === 'mutation')) return [3 /*break*/, 2];\n                    _b = transforms_1.applyResultTransforms;\n                    return [4 /*yield*/, graphql_1.execute(options.schema, processedRequest.document, info.rootValue, options.context, processedRequest.variables)];\n                case 1: return [2 /*return*/, _b.apply(void 0, [_c.sent(),\n                        transforms])];\n                case 2:\n                    if (!(operation === 'subscription')) return [3 /*break*/, 4];\n                    return [4 /*yield*/, graphql_1.subscribe(options.schema, processedRequest.document, info.rootValue, options.context, processedRequest.variables)];\n                case 3:\n                    executionResult = (_c.sent());\n                    // \"subscribe\" to the subscription result and map the result through the transforms\n                    return [2 /*return*/, mapAsyncIterator_1.default(executionResult, function (result) {\n                            var _a;\n                            var transformedResult = transforms_1.applyResultTransforms(result, transforms);\n                            var subscriptionKey = Object.keys(result.data)[0];\n                            // for some reason the returned transformedResult needs to be nested inside the root subscription field\n                            // does not work otherwise...\n                            return _a = {},\n                                _a[subscriptionKey] = transformedResult,\n                                _a;\n                        })];\n                case 4: return [2 /*return*/];\n            }\n        });\n    });\n}\nfunction createDocument(targetField, targetOperation, originalSelections, fragments, variables, operationName) {\n    var selections = [];\n    var args = [];\n    originalSelections.forEach(function (field) {\n        var fieldSelections = field.selectionSet\n            ? field.selectionSet.selections\n            : [];\n        selections = selections.concat(fieldSelections);\n        args = args.concat(field.arguments || []);\n    });\n    var selectionSet = null;\n    if (selections.length > 0) {\n        selectionSet = {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: selections,\n        };\n    }\n    var rootField = {\n        kind: graphql_1.Kind.FIELD,\n        alias: null,\n        arguments: args,\n        selectionSet: selectionSet,\n        name: {\n            kind: graphql_1.Kind.NAME,\n            value: targetField,\n        },\n    };\n    var rootSelectionSet = {\n        kind: graphql_1.Kind.SELECTION_SET,\n        selections: [rootField],\n    };\n    var operationDefinition = {\n        kind: graphql_1.Kind.OPERATION_DEFINITION,\n        operation: targetOperation,\n        variableDefinitions: variables,\n        selectionSet: rootSelectionSet,\n        name: operationName,\n    };\n    return {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [operationDefinition].concat(fragments),\n    };\n}\n\n\n//# sourceURL=webpack:///./src/stitching/delegateToSchema.ts?");

/***/ }),

/***/ "./src/stitching/errors.ts":
/*!*********************************!*\
  !*** ./src/stitching/errors.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    }\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar error_1 = __webpack_require__(/*! graphql/error */ \"graphql/error\");\nvar getResponseKeyFromInfo_1 = __webpack_require__(/*! ./getResponseKeyFromInfo */ \"./src/stitching/getResponseKeyFromInfo.ts\");\nif ((typeof global !== 'undefined' && 'Symbol' in global) ||\n    (typeof window !== 'undefined' && 'Symbol' in window)) {\n    exports.ERROR_SYMBOL = Symbol('subSchemaErrors');\n}\nelse {\n    exports.ERROR_SYMBOL = '@@__subSchemaErrors';\n}\nfunction annotateWithChildrenErrors(object, childrenErrors) {\n    var _a;\n    if (!childrenErrors || childrenErrors.length === 0) {\n        // Nothing to see here, move along\n        return object;\n    }\n    if (Array.isArray(object)) {\n        var byIndex_1 = {};\n        childrenErrors.forEach(function (error) {\n            if (!error.path) {\n                return;\n            }\n            var index = error.path[1];\n            var current = byIndex_1[index] || [];\n            current.push(__assign({}, error, { path: error.path.slice(1) }));\n            byIndex_1[index] = current;\n        });\n        return object.map(function (item, index) { return annotateWithChildrenErrors(item, byIndex_1[index]); });\n    }\n    return __assign({}, object, (_a = {}, _a[exports.ERROR_SYMBOL] = childrenErrors.map(function (error) { return (__assign({}, error, (error.path ? { path: error.path.slice(1) } : {}))); }), _a));\n}\nexports.annotateWithChildrenErrors = annotateWithChildrenErrors;\nfunction getErrorsFromParent(object, fieldName) {\n    var errors = (object && object[exports.ERROR_SYMBOL]) || [];\n    var childrenErrors = [];\n    for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n        var error = errors_1[_i];\n        if (!error.path || (error.path.length === 1 && error.path[0] === fieldName)) {\n            return {\n                kind: 'OWN',\n                error: error\n            };\n        }\n        else if (error.path[0] === fieldName) {\n            childrenErrors.push(error);\n        }\n    }\n    return {\n        kind: 'CHILDREN',\n        errors: childrenErrors\n    };\n}\nexports.getErrorsFromParent = getErrorsFromParent;\nvar CombinedError = /** @class */ (function (_super) {\n    __extends(CombinedError, _super);\n    function CombinedError(message, errors) {\n        var _this = _super.call(this, message) || this;\n        _this.errors = errors;\n        return _this;\n    }\n    return CombinedError;\n}(Error));\nfunction checkResultAndHandleErrors(result, info, responseKey) {\n    if (!responseKey) {\n        responseKey = getResponseKeyFromInfo_1.getResponseKeyFromInfo(info);\n    }\n    if (result.errors && (!result.data || result.data[responseKey] == null)) {\n        // apollo-link-http & http-link-dataloader need the\n        // result property to be passed through for better error handling.\n        // If there is only one error, which contains a result property, pass the error through\n        var newError = result.errors.length === 1 && hasResult(result.errors[0])\n            ? result.errors[0]\n            : new CombinedError(concatErrors(result.errors), result.errors);\n        throw error_1.locatedError(newError, info.fieldNodes, graphql_1.responsePathAsArray(info.path));\n    }\n    var resultObject = result.data[responseKey];\n    if (result.errors) {\n        resultObject = annotateWithChildrenErrors(resultObject, result.errors);\n    }\n    return resultObject;\n}\nexports.checkResultAndHandleErrors = checkResultAndHandleErrors;\nfunction concatErrors(errors) {\n    return errors.map(function (error) { return error.message; }).join('\\n');\n}\nfunction hasResult(error) {\n    return error.result || error.extensions || (error.originalError && error.originalError.result);\n}\n\n\n//# sourceURL=webpack:///./src/stitching/errors.ts?");

/***/ }),

/***/ "./src/stitching/getResponseKeyFromInfo.ts":
/*!*************************************************!*\
  !*** ./src/stitching/getResponseKeyFromInfo.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nfunction getResponseKeyFromInfo(info) {\n    return info.fieldNodes[0].alias ? info.fieldNodes[0].alias.value : info.fieldName;\n}\nexports.getResponseKeyFromInfo = getResponseKeyFromInfo;\n\n\n//# sourceURL=webpack:///./src/stitching/getResponseKeyFromInfo.ts?");

/***/ }),

/***/ "./src/stitching/index.ts":
/*!********************************!*\
  !*** ./src/stitching/index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar makeRemoteExecutableSchema_1 = __webpack_require__(/*! ./makeRemoteExecutableSchema */ \"./src/stitching/makeRemoteExecutableSchema.ts\");\nexports.makeRemoteExecutableSchema = makeRemoteExecutableSchema_1.default;\nexports.defaultCreateRemoteResolver = makeRemoteExecutableSchema_1.createResolver;\nexports.schemaOptions = makeRemoteExecutableSchema_1.schemaOptions;\nvar introspectSchema_1 = __webpack_require__(/*! ./introspectSchema */ \"./src/stitching/introspectSchema.ts\");\nexports.introspectSchema = introspectSchema_1.default;\nvar mergeSchemas_1 = __webpack_require__(/*! ./mergeSchemas */ \"./src/stitching/mergeSchemas.ts\");\nexports.mergeSchemas = mergeSchemas_1.default;\nvar delegateToSchema_1 = __webpack_require__(/*! ./delegateToSchema */ \"./src/stitching/delegateToSchema.ts\");\nexports.delegateToSchema = delegateToSchema_1.default;\nvar defaultMergedResolver_1 = __webpack_require__(/*! ./defaultMergedResolver */ \"./src/stitching/defaultMergedResolver.ts\");\nexports.defaultMergedResolver = defaultMergedResolver_1.default;\n\n\n//# sourceURL=webpack:///./src/stitching/index.ts?");

/***/ }),

/***/ "./src/stitching/introspectSchema.ts":
/*!*******************************************!*\
  !*** ./src/stitching/introspectSchema.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar linkToFetcher_1 = __webpack_require__(/*! ./linkToFetcher */ \"./src/stitching/linkToFetcher.ts\");\nvar parsedIntrospectionQuery = graphql_1.parse(graphql_1.introspectionQuery);\nfunction introspectSchema(fetcher, linkContext) {\n    return __awaiter(this, void 0, void 0, function () {\n        var introspectionResult, schema;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // Convert link to fetcher\n                    if (fetcher.request) {\n                        fetcher = linkToFetcher_1.default(fetcher);\n                    }\n                    return [4 /*yield*/, fetcher({\n                            query: parsedIntrospectionQuery,\n                            context: linkContext,\n                        })];\n                case 1:\n                    introspectionResult = _a.sent();\n                    if ((introspectionResult.errors && introspectionResult.errors.length) ||\n                        !introspectionResult.data.__schema) {\n                        throw introspectionResult.errors;\n                    }\n                    else {\n                        schema = graphql_1.buildClientSchema(introspectionResult.data);\n                        return [2 /*return*/, schema];\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\nexports.default = introspectSchema;\n\n\n//# sourceURL=webpack:///./src/stitching/introspectSchema.ts?");

/***/ }),

/***/ "./src/stitching/linkToFetcher.ts":
/*!****************************************!*\
  !*** ./src/stitching/linkToFetcher.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar apollo_link_1 = __webpack_require__(/*! apollo-link */ \"apollo-link\");\nvar apollo_link_2 = __webpack_require__(/*! apollo-link */ \"apollo-link\");\nexports.execute = apollo_link_2.execute;\nfunction linkToFetcher(link) {\n    return function (fetcherOperation) {\n        return apollo_link_1.makePromise(apollo_link_1.execute(link, fetcherOperation));\n    };\n}\nexports.default = linkToFetcher;\n\n\n//# sourceURL=webpack:///./src/stitching/linkToFetcher.ts?");

/***/ }),

/***/ "./src/stitching/makeRemoteExecutableSchema.ts":
/*!*****************************************************!*\
  !*** ./src/stitching/makeRemoteExecutableSchema.ts ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Import buildFederatedSchema to add the cability at\n * the moment create the remote schema\n */\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar linkToFetcher_1 = __webpack_require__(/*! ./linkToFetcher */ \"./src/stitching/linkToFetcher.ts\");\nvar isEmptyObject_1 = __webpack_require__(/*! ../isEmptyObject */ \"./src/isEmptyObject.ts\");\nvar makeExecutableSchema_1 = __webpack_require__(/*! ../makeExecutableSchema */ \"./src/makeExecutableSchema.ts\");\nvar schemaRecreation_1 = __webpack_require__(/*! ./schemaRecreation */ \"./src/stitching/schemaRecreation.ts\");\nvar resolveFromParentTypename_1 = __webpack_require__(/*! ./resolveFromParentTypename */ \"./src/stitching/resolveFromParentTypename.ts\");\nvar defaultMergedResolver_1 = __webpack_require__(/*! ./defaultMergedResolver */ \"./src/stitching/defaultMergedResolver.ts\");\nvar errors_1 = __webpack_require__(/*! ./errors */ \"./src/stitching/errors.ts\");\nvar observableToAsyncIterable_1 = __webpack_require__(/*! ./observableToAsyncIterable */ \"./src/stitching/observableToAsyncIterable.ts\");\nfunction schemaOptions(_a) {\n    var buildSchemaOptions = _a.buildSchemaOptions, _b = _a.createResolver, customCreateResolver = _b === void 0 ? createResolver : _b, fetcher = _a.fetcher, link = _a.link, _c = _a.printSchemaOptions, printSchemaOptions = _c === void 0 ? { commentDescriptions: true } : _c, schema = _a.schema;\n    var _d;\n    if (!fetcher && link) {\n        fetcher = linkToFetcher_1.default(link);\n    }\n    var typeDefs;\n    if (typeof schema === 'string') {\n        typeDefs = schema;\n        schema = graphql_1.buildSchema(typeDefs, buildSchemaOptions);\n    }\n    else {\n        typeDefs = graphql_1.printSchema(schema, printSchemaOptions);\n    }\n    // prepare query resolvers\n    var queryResolvers = {};\n    var queryType = schema.getQueryType();\n    var queries = queryType.getFields();\n    Object.keys(queries).forEach(function (key) {\n        queryResolvers[key] = customCreateResolver(fetcher);\n    });\n    // prepare mutation resolvers\n    var mutationResolvers = {};\n    var mutationType = schema.getMutationType();\n    if (mutationType) {\n        var mutations = mutationType.getFields();\n        Object.keys(mutations).forEach(function (key) {\n            mutationResolvers[key] = customCreateResolver(fetcher);\n        });\n    }\n    // prepare subscription resolvers\n    var subscriptionResolvers = {};\n    var subscriptionType = schema.getSubscriptionType();\n    if (subscriptionType) {\n        var subscriptions = subscriptionType.getFields();\n        Object.keys(subscriptions).forEach(function (key) {\n            subscriptionResolvers[key] = {\n                subscribe: createSubscriptionResolver(key, link)\n            };\n        });\n    }\n    // merge resolvers into resolver map\n    var resolvers = (_d = {}, _d[queryType.name] = queryResolvers, _d);\n    if (!isEmptyObject_1.default(mutationResolvers)) {\n        resolvers[mutationType.name] = mutationResolvers;\n    }\n    if (!isEmptyObject_1.default(subscriptionResolvers)) {\n        resolvers[subscriptionType.name] = subscriptionResolvers;\n    }\n    // add missing abstract resolvers (scalar, unions, interfaces)\n    var typeMap = schema.getTypeMap();\n    var types = Object.keys(typeMap).map(function (name) { return typeMap[name]; });\n    var _loop_1 = function (type) {\n        if (type instanceof graphql_1.GraphQLInterfaceType || type instanceof graphql_1.GraphQLUnionType) {\n            resolvers[type.name] = {\n                __resolveType: function (parent, context, info) {\n                    return resolveFromParentTypename_1.default(parent, info.schema);\n                }\n            };\n        }\n        else if (type instanceof graphql_1.GraphQLScalarType) {\n            if (!(type === graphql_1.GraphQLID ||\n                type === graphql_1.GraphQLString ||\n                type === graphql_1.GraphQLFloat ||\n                type === graphql_1.GraphQLBoolean ||\n                type === graphql_1.GraphQLInt)) {\n                resolvers[type.name] = schemaRecreation_1.recreateType(type, function (name) { return null; }, false);\n            }\n        }\n        else if (type instanceof graphql_1.GraphQLObjectType &&\n            type.name.slice(0, 2) !== '__' &&\n            type !== queryType &&\n            type !== mutationType &&\n            type !== subscriptionType) {\n            var resolver_1 = {};\n            Object.keys(type.getFields()).forEach(function (field) {\n                resolver_1[field] = defaultMergedResolver_1.default;\n            });\n            resolvers[type.name] = resolver_1;\n        }\n    };\n    for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n        var type = types_1[_i];\n        _loop_1(type);\n    }\n    return {\n        typeDefs: typeDefs,\n        resolvers: resolvers\n    };\n}\nexports.schemaOptions = schemaOptions;\nfunction makeRemoteExecutableSchema(_a) {\n    var buildSchemaOptions = _a.buildSchemaOptions, _b = _a.createResolver, customCreateResolver = _b === void 0 ? createResolver : _b, fetcher = _a.fetcher, link = _a.link, _c = _a.printSchemaOptions, printSchemaOptions = _c === void 0 ? { commentDescriptions: true } : _c, schema = _a.schema;\n    var _d = schemaOptions({\n        buildSchemaOptions: buildSchemaOptions,\n        createResolver: createResolver,\n        fetcher: fetcher,\n        link: link,\n        printSchemaOptions: printSchemaOptions,\n        schema: schema\n    }), typeDefs = _d.typeDefs, resolvers = _d.resolvers;\n    return makeExecutableSchema_1.makeExecutableSchema({\n        typeDefs: typeDefs,\n        resolvers: resolvers\n    });\n}\nexports.default = makeRemoteExecutableSchema;\nfunction createResolver(fetcher) {\n    var _this = this;\n    return function (root, args, context, info) { return __awaiter(_this, void 0, void 0, function () {\n        var fragments, document, result;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });\n                    document = {\n                        kind: graphql_1.Kind.DOCUMENT,\n                        definitions: [info.operation].concat(fragments)\n                    };\n                    return [4 /*yield*/, fetcher({\n                            query: document,\n                            variables: info.variableValues,\n                            context: { graphqlContext: context }\n                        })];\n                case 1:\n                    result = _a.sent();\n                    return [2 /*return*/, errors_1.checkResultAndHandleErrors(result, info)];\n            }\n        });\n    }); };\n}\nexports.createResolver = createResolver;\nfunction createSubscriptionResolver(name, link) {\n    return function (root, args, context, info) {\n        var fragments = Object.keys(info.fragments).map(function (fragment) { return info.fragments[fragment]; });\n        var document = {\n            kind: graphql_1.Kind.DOCUMENT,\n            definitions: [info.operation].concat(fragments)\n        };\n        var operation = {\n            query: document,\n            variables: info.variableValues,\n            context: { graphqlContext: context }\n        };\n        var observable = linkToFetcher_1.execute(link, operation);\n        return observableToAsyncIterable_1.observableToAsyncIterable(observable);\n    };\n}\n\n\n//# sourceURL=webpack:///./src/stitching/makeRemoteExecutableSchema.ts?");

/***/ }),

/***/ "./src/stitching/mapAsyncIterator.ts":
/*!*******************************************!*\
  !*** ./src/stitching/mapAsyncIterator.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"iterall\");\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n    var _a;\n    var $return;\n    var abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = function (error) {\n            var rethrow = function () { return Promise.reject(error); };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done\n            ? result\n            : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    var mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        var reject_1 = rejectCallback;\n        mapReject = function (error) {\n            return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\n        };\n    }\n    return _a = {\n            next: function () {\n                return iterator.next().then(mapResult, mapReject);\n            },\n            return: function () {\n                return $return\n                    ? $return.call(iterator).then(mapResult, mapReject)\n                    : Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (error) {\n                if (typeof iterator.throw === 'function') {\n                    return iterator.throw(error).then(mapResult, mapReject);\n                }\n                return Promise.reject(error).catch(abruptClose);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n}\nexports.default = mapAsyncIterator;\nfunction asyncMapValue(value, callback) {\n    return new Promise(function (resolve) { return resolve(callback(value)); });\n}\nfunction iteratorResult(value) {\n    return { value: value, done: false };\n}\n\n\n//# sourceURL=webpack:///./src/stitching/mapAsyncIterator.ts?");

/***/ }),

/***/ "./src/stitching/mergeSchemas.ts":
/*!***************************************!*\
  !*** ./src/stitching/mergeSchemas.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar makeExecutableSchema_1 = __webpack_require__(/*! ../makeExecutableSchema */ \"./src/makeExecutableSchema.ts\");\nvar schemaRecreation_1 = __webpack_require__(/*! ./schemaRecreation */ \"./src/stitching/schemaRecreation.ts\");\nvar delegateToSchema_1 = __webpack_require__(/*! ./delegateToSchema */ \"./src/stitching/delegateToSchema.ts\");\nvar typeFromAST_1 = __webpack_require__(/*! ./typeFromAST */ \"./src/stitching/typeFromAST.ts\");\nvar transforms_1 = __webpack_require__(/*! ../transforms */ \"./src/transforms/index.ts\");\nvar mergeDeep_1 = __webpack_require__(/*! ../mergeDeep */ \"./src/mergeDeep.ts\");\nvar schemaVisitor_1 = __webpack_require__(/*! ../schemaVisitor */ \"./src/schemaVisitor.ts\");\nfunction mergeSchemas(_a) {\n    var schemas = _a.schemas, onTypeConflict = _a.onTypeConflict, resolvers = _a.resolvers, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, mergeDirectives = _a.mergeDirectives;\n    return mergeSchemasImplementation({\n        schemas: schemas,\n        resolvers: resolvers,\n        schemaDirectives: schemaDirectives,\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces,\n        mergeDirectives: mergeDirectives,\n    });\n}\nexports.default = mergeSchemas;\nfunction mergeSchemasImplementation(_a) {\n    var schemas = _a.schemas, resolvers = _a.resolvers, schemaDirectives = _a.schemaDirectives, inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces, mergeDirectives = _a.mergeDirectives;\n    var allSchemas = [];\n    var typeCandidates = {};\n    var types = {};\n    var extensions = [];\n    var directives = [];\n    var fragments = [];\n    var resolveType = schemaRecreation_1.createResolveType(function (name) {\n        if (types[name] === undefined) {\n            throw new Error(\"Can't find type \" + name + \".\");\n        }\n        return types[name];\n    });\n    schemas.forEach(function (schema) {\n        if (schema instanceof graphql_1.GraphQLSchema) {\n            allSchemas.push(schema);\n            var queryType_1 = schema.getQueryType();\n            var mutationType_1 = schema.getMutationType();\n            var subscriptionType_1 = schema.getSubscriptionType();\n            if (queryType_1) {\n                addTypeCandidate(typeCandidates, 'Query', {\n                    schema: schema,\n                    type: queryType_1,\n                });\n            }\n            if (mutationType_1) {\n                addTypeCandidate(typeCandidates, 'Mutation', {\n                    schema: schema,\n                    type: mutationType_1,\n                });\n            }\n            if (subscriptionType_1) {\n                addTypeCandidate(typeCandidates, 'Subscription', {\n                    schema: schema,\n                    type: subscriptionType_1,\n                });\n            }\n            if (mergeDirectives) {\n                var directiveInstances = schema.getDirectives();\n                directiveInstances.forEach(function (directive) {\n                    directives.push(directive);\n                });\n            }\n            var typeMap_1 = schema.getTypeMap();\n            Object.keys(typeMap_1).forEach(function (typeName) {\n                var type = typeMap_1[typeName];\n                if (graphql_1.isNamedType(type) &&\n                    graphql_1.getNamedType(type).name.slice(0, 2) !== '__' &&\n                    type !== queryType_1 &&\n                    type !== mutationType_1 &&\n                    type !== subscriptionType_1) {\n                    addTypeCandidate(typeCandidates, type.name, {\n                        schema: schema,\n                        type: type,\n                    });\n                }\n            });\n        }\n        else if (typeof schema === 'string' ||\n            (schema && schema.kind === graphql_1.Kind.DOCUMENT)) {\n            var parsedSchemaDocument = typeof schema === 'string' ? graphql_1.parse(schema) : schema;\n            parsedSchemaDocument.definitions.forEach(function (def) {\n                var type = typeFromAST_1.default(def);\n                if (type instanceof graphql_1.GraphQLDirective && mergeDirectives) {\n                    directives.push(type);\n                }\n                else if (type && !(type instanceof graphql_1.GraphQLDirective)) {\n                    addTypeCandidate(typeCandidates, type.name, {\n                        type: type,\n                    });\n                }\n            });\n            var extensionsDocument = makeExecutableSchema_1.extractExtensionDefinitions(parsedSchemaDocument);\n            if (extensionsDocument.definitions.length > 0) {\n                extensions.push(extensionsDocument);\n            }\n        }\n        else if (Array.isArray(schema)) {\n            schema.forEach(function (type) {\n                addTypeCandidate(typeCandidates, type.name, {\n                    type: type,\n                });\n            });\n        }\n        else {\n            throw new Error(\"Invalid schema passed\");\n        }\n    });\n    var mergeInfo = createMergeInfo(allSchemas, fragments);\n    if (!resolvers) {\n        resolvers = {};\n    }\n    else if (typeof resolvers === 'function') {\n        console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');\n        resolvers = resolvers(mergeInfo);\n    }\n    else if (Array.isArray(resolvers)) {\n        resolvers = resolvers.reduce(function (left, right) {\n            if (typeof right === 'function') {\n                console.warn('Passing functions as resolver parameter is deprecated. Use `info.mergeInfo` instead.');\n                right = right(mergeInfo);\n            }\n            return mergeDeep_1.default(left, right);\n        }, {});\n    }\n    var generatedResolvers = {};\n    Object.keys(typeCandidates).forEach(function (typeName) {\n        var resultType = defaultVisitType(typeName, typeCandidates[typeName]);\n        if (resultType === null) {\n            types[typeName] = null;\n        }\n        else {\n            var type = void 0;\n            var typeResolvers = void 0;\n            if (graphql_1.isNamedType(resultType)) {\n                type = resultType;\n            }\n            else if (resultType.type) {\n                type = resultType.type;\n                typeResolvers = resultType.resolvers;\n            }\n            else {\n                throw new Error(\"Invalid visitType result for type \" + typeName);\n            }\n            types[typeName] = schemaRecreation_1.recreateType(type, resolveType, false);\n            if (typeResolvers) {\n                generatedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    var mergedSchema = new graphql_1.GraphQLSchema({\n        query: types.Query,\n        mutation: types.Mutation,\n        subscription: types.Subscription,\n        types: Object.keys(types).map(function (key) { return types[key]; }),\n        directives: directives.map(function (directive) { return schemaRecreation_1.recreateDirective(directive, resolveType); })\n    });\n    extensions.forEach(function (extension) {\n        mergedSchema = graphql_1.extendSchema(mergedSchema, extension, {\n            commentDescriptions: true,\n        });\n    });\n    if (!resolvers) {\n        resolvers = {};\n    }\n    else if (Array.isArray(resolvers)) {\n        resolvers = resolvers.reduce(mergeDeep_1.default, {});\n    }\n    Object.keys(resolvers).forEach(function (typeName) {\n        var type = resolvers[typeName];\n        if (type instanceof graphql_1.GraphQLScalarType) {\n            return;\n        }\n        Object.keys(type).forEach(function (fieldName) {\n            var field = type[fieldName];\n            if (field.fragment) {\n                fragments.push({\n                    field: fieldName,\n                    fragment: field.fragment,\n                });\n            }\n        });\n    });\n    mergedSchema = makeExecutableSchema_1.addResolveFunctionsToSchema({\n        schema: mergedSchema,\n        resolvers: mergeDeep_1.default(generatedResolvers, resolvers),\n        inheritResolversFromInterfaces: inheritResolversFromInterfaces\n    });\n    forEachField(mergedSchema, function (field) {\n        if (field.resolve) {\n            var fieldResolver_1 = field.resolve;\n            field.resolve = function (parent, args, context, info) {\n                var newInfo = __assign({}, info, { mergeInfo: mergeInfo });\n                return fieldResolver_1(parent, args, context, newInfo);\n            };\n        }\n        if (field.subscribe) {\n            var fieldResolver_2 = field.subscribe;\n            field.subscribe = function (parent, args, context, info) {\n                var newInfo = __assign({}, info, { mergeInfo: mergeInfo });\n                return fieldResolver_2(parent, args, context, newInfo);\n            };\n        }\n    });\n    if (schemaDirectives) {\n        schemaVisitor_1.SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);\n    }\n    return mergedSchema;\n}\nfunction createMergeInfo(allSchemas, fragments) {\n    return {\n        delegate: function (operation, fieldName, args, context, info, transforms) {\n            console.warn('`mergeInfo.delegate` is deprecated. ' +\n                'Use `mergeInfo.delegateToSchema and pass explicit schema instances.');\n            var schema = guessSchemaByRootField(allSchemas, operation, fieldName);\n            var expandTransforms = new transforms_1.ExpandAbstractTypes(info.schema, schema);\n            var fragmentTransform = new transforms_1.ReplaceFieldWithFragment(schema, fragments);\n            return delegateToSchema_1.default({\n                schema: schema,\n                operation: operation,\n                fieldName: fieldName,\n                args: args,\n                context: context,\n                info: info,\n                transforms: (transforms || []).concat([\n                    expandTransforms,\n                    fragmentTransform,\n                ]),\n            });\n        },\n        delegateToSchema: function (options) {\n            return delegateToSchema_1.default(__assign({}, options, { transforms: options.transforms }));\n        },\n        fragments: fragments\n    };\n}\nfunction guessSchemaByRootField(schemas, operation, fieldName) {\n    for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {\n        var schema = schemas_1[_i];\n        var rootObject = void 0;\n        if (operation === 'subscription') {\n            rootObject = schema.getSubscriptionType();\n        }\n        else if (operation === 'mutation') {\n            rootObject = schema.getMutationType();\n        }\n        else {\n            rootObject = schema.getQueryType();\n        }\n        if (rootObject) {\n            var fields = rootObject.getFields();\n            if (fields[fieldName]) {\n                return schema;\n            }\n        }\n    }\n    throw new Error(\"Could not find subschema with field `\" + operation + \".\" + fieldName + \"`\");\n}\nfunction createDelegatingResolver(schema, operation, fieldName) {\n    return function (root, args, context, info) {\n        return info.mergeInfo.delegateToSchema({\n            schema: schema,\n            operation: operation,\n            fieldName: fieldName,\n            args: args,\n            context: context,\n            info: info,\n        });\n    };\n}\nfunction forEachField(schema, fn) {\n    var typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        if (!graphql_1.getNamedType(type).name.startsWith('__') &&\n            type instanceof graphql_1.GraphQLObjectType) {\n            var fields_1 = type.getFields();\n            Object.keys(fields_1).forEach(function (fieldName) {\n                var field = fields_1[fieldName];\n                fn(field, typeName, fieldName);\n            });\n        }\n    });\n}\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\n    if (!typeCandidates[name]) {\n        typeCandidates[name] = [];\n    }\n    typeCandidates[name].push(typeCandidate);\n}\nfunction defaultVisitType(name, candidates, candidateSelector) {\n    if (!candidateSelector) {\n        candidateSelector = function (cands) { return cands[cands.length - 1]; };\n    }\n    var resolveType = schemaRecreation_1.createResolveType(function (_, type) { return type; });\n    if (name === 'Query' || name === 'Mutation' || name === 'Subscription') {\n        var fields_2 = {};\n        var operationName_1;\n        switch (name) {\n            case 'Query':\n                operationName_1 = 'query';\n                break;\n            case 'Mutation':\n                operationName_1 = 'mutation';\n                break;\n            case 'Subscription':\n                operationName_1 = 'subscription';\n                break;\n            default:\n                break;\n        }\n        var resolvers_1 = {};\n        var resolverKey_1 = operationName_1 === 'subscription' ? 'subscribe' : 'resolve';\n        candidates.forEach(function (_a) {\n            var candidateType = _a.type, schema = _a.schema;\n            var candidateFields = candidateType.getFields();\n            fields_2 = __assign({}, fields_2, candidateFields);\n            Object.keys(candidateFields).forEach(function (fieldName) {\n                var _a;\n                resolvers_1[fieldName] = (_a = {},\n                    _a[resolverKey_1] = createDelegatingResolver(schema, operationName_1, fieldName),\n                    _a);\n            });\n        });\n        var type = new graphql_1.GraphQLObjectType({\n            name: name,\n            fields: schemaRecreation_1.fieldMapToFieldConfigMap(fields_2, resolveType, false),\n        });\n        return {\n            type: type,\n            resolvers: resolvers_1,\n        };\n    }\n    else {\n        var candidate = candidateSelector(candidates);\n        return candidate.type;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/stitching/mergeSchemas.ts?");

/***/ }),

/***/ "./src/stitching/observableToAsyncIterable.ts":
/*!****************************************************!*\
  !*** ./src/stitching/observableToAsyncIterable.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar iterall_1 = __webpack_require__(/*! iterall */ \"iterall\");\nfunction observableToAsyncIterable(observable) {\n    var _a;\n    var pullQueue = [];\n    var pushQueue = [];\n    var listening = true;\n    var pushValue = function (_a) {\n        var data = _a.data;\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value: data, done: false });\n        }\n        else {\n            pushQueue.push({ value: data });\n        }\n    };\n    var pushError = function (error) {\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] } });\n        }\n    };\n    var pullValue = function () {\n        return new Promise(function (resolve) {\n            if (pushQueue.length !== 0) {\n                var element = pushQueue.shift();\n                // either {value: {errors: [...]}} or {value: ...}\n                resolve(__assign({}, element, { done: false }));\n            }\n            else {\n                pullQueue.push(resolve);\n            }\n        });\n    };\n    var subscription = observable.subscribe({\n        next: function (value) {\n            pushValue(value);\n        },\n        error: function (err) {\n            pushError(err);\n        },\n    });\n    var emptyQueue = function () {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            pullQueue.forEach(function (resolve) { return resolve({ value: undefined, done: true }); });\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return _a = {\n            next: function () {\n                return __awaiter(this, void 0, void 0, function () {\n                    return __generator(this, function (_a) {\n                        return [2 /*return*/, listening ? pullValue() : this.return()];\n                    });\n                });\n            },\n            return: function () {\n                emptyQueue();\n                return Promise.resolve({ value: undefined, done: true });\n            },\n            throw: function (error) {\n                emptyQueue();\n                return Promise.reject(error);\n            }\n        },\n        _a[iterall_1.$$asyncIterator] = function () {\n            return this;\n        },\n        _a;\n}\nexports.observableToAsyncIterable = observableToAsyncIterable;\n\n\n//# sourceURL=webpack:///./src/stitching/observableToAsyncIterable.ts?");

/***/ }),

/***/ "./src/stitching/resolveFromParentTypename.ts":
/*!****************************************************!*\
  !*** ./src/stitching/resolveFromParentTypename.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nfunction resolveFromParentTypename(parent, schema) {\n    var parentTypename = parent['__typename'];\n    if (!parentTypename) {\n        throw new Error('Did not fetch typename for object, unable to resolve interface.');\n    }\n    var resolvedType = schema.getType(parentTypename);\n    if (!(resolvedType instanceof graphql_1.GraphQLObjectType)) {\n        throw new Error('__typename did not match an object type: ' + parentTypename);\n    }\n    return resolvedType;\n}\nexports.default = resolveFromParentTypename;\n\n\n//# sourceURL=webpack:///./src/stitching/resolveFromParentTypename.ts?");

/***/ }),

/***/ "./src/stitching/resolvers.ts":
/*!************************************!*\
  !*** ./src/stitching/resolvers.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar delegateToSchema_1 = __webpack_require__(/*! ./delegateToSchema */ \"./src/stitching/delegateToSchema.ts\");\nfunction generateProxyingResolvers(targetSchema, transforms, mapping) {\n    var result = {};\n    Object.keys(mapping).forEach(function (name) {\n        result[name] = {};\n        var innerMapping = mapping[name];\n        Object.keys(innerMapping).forEach(function (from) {\n            var _a;\n            var to = innerMapping[from];\n            var resolverType = to.operation === 'subscription' ? 'subscribe' : 'resolve';\n            result[name][from] = (_a = {},\n                _a[resolverType] = createProxyingResolver(targetSchema, to.operation, to.name, transforms),\n                _a);\n        });\n    });\n    return result;\n}\nexports.generateProxyingResolvers = generateProxyingResolvers;\nfunction generateSimpleMapping(targetSchema) {\n    var query = targetSchema.getQueryType();\n    var mutation = targetSchema.getMutationType();\n    var subscription = targetSchema.getSubscriptionType();\n    var result = {};\n    if (query) {\n        result[query.name] = generateMappingFromObjectType(query, 'query');\n    }\n    if (mutation) {\n        result[mutation.name] = generateMappingFromObjectType(mutation, 'mutation');\n    }\n    if (subscription) {\n        result[subscription.name] = generateMappingFromObjectType(subscription, 'subscription');\n    }\n    return result;\n}\nexports.generateSimpleMapping = generateSimpleMapping;\nfunction generateMappingFromObjectType(type, operation) {\n    var result = {};\n    var fields = type.getFields();\n    Object.keys(fields).forEach(function (fieldName) {\n        result[fieldName] = {\n            name: fieldName,\n            operation: operation,\n        };\n    });\n    return result;\n}\nexports.generateMappingFromObjectType = generateMappingFromObjectType;\nfunction createProxyingResolver(schema, operation, fieldName, transforms) {\n    return function (parent, args, context, info) { return delegateToSchema_1.default({\n        schema: schema,\n        operation: operation,\n        fieldName: fieldName,\n        args: {},\n        context: context,\n        info: info,\n        transforms: transforms,\n    }); };\n}\n\n\n//# sourceURL=webpack:///./src/stitching/resolvers.ts?");

/***/ }),

/***/ "./src/stitching/schemaRecreation.ts":
/*!*******************************************!*\
  !*** ./src/stitching/schemaRecreation.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar isSpecifiedScalarType_1 = __webpack_require__(/*! ../isSpecifiedScalarType */ \"./src/isSpecifiedScalarType.ts\");\nvar resolveFromParentTypename_1 = __webpack_require__(/*! ./resolveFromParentTypename */ \"./src/stitching/resolveFromParentTypename.ts\");\nvar defaultMergedResolver_1 = __webpack_require__(/*! ./defaultMergedResolver */ \"./src/stitching/defaultMergedResolver.ts\");\nfunction recreateType(type, resolveType, keepResolvers) {\n    if (type instanceof graphql_1.GraphQLObjectType) {\n        var fields_1 = type.getFields();\n        var interfaces_1 = type.getInterfaces();\n        return new graphql_1.GraphQLObjectType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            isTypeOf: keepResolvers ? type.isTypeOf : undefined,\n            fields: function () {\n                return fieldMapToFieldConfigMap(fields_1, resolveType, keepResolvers);\n            },\n            interfaces: function () { return interfaces_1.map(function (iface) { return resolveType(iface); }); },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLInterfaceType) {\n        var fields_2 = type.getFields();\n        return new graphql_1.GraphQLInterfaceType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            fields: function () {\n                return fieldMapToFieldConfigMap(fields_2, resolveType, keepResolvers);\n            },\n            resolveType: keepResolvers\n                ? type.resolveType\n                : function (parent, context, info) {\n                    return resolveFromParentTypename_1.default(parent, info.schema);\n                },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLUnionType) {\n        return new graphql_1.GraphQLUnionType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            types: function () { return type.getTypes().map(function (unionMember) { return resolveType(unionMember); }); },\n            resolveType: keepResolvers\n                ? type.resolveType\n                : function (parent, context, info) {\n                    return resolveFromParentTypename_1.default(parent, info.schema);\n                },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLInputObjectType) {\n        return new graphql_1.GraphQLInputObjectType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            fields: function () {\n                return inputFieldMapToFieldConfigMap(type.getFields(), resolveType);\n            },\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLEnumType) {\n        var values = type.getValues();\n        var newValues_1 = {};\n        values.forEach(function (value) {\n            newValues_1[value.name] = {\n                value: value.value,\n                deprecationReason: value.deprecationReason,\n                description: value.description,\n                astNode: value.astNode,\n            };\n        });\n        return new graphql_1.GraphQLEnumType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            values: newValues_1,\n        });\n    }\n    else if (type instanceof graphql_1.GraphQLScalarType) {\n        if (keepResolvers || isSpecifiedScalarType_1.default(type)) {\n            return type;\n        }\n        else {\n            return new graphql_1.GraphQLScalarType({\n                name: type.name,\n                description: type.description,\n                astNode: type.astNode,\n                serialize: function (value) {\n                    return value;\n                },\n                parseValue: function (value) {\n                    return value;\n                },\n                parseLiteral: function (ast) {\n                    return parseLiteral(ast);\n                },\n            });\n        }\n    }\n    else {\n        throw new Error(\"Invalid type \" + type);\n    }\n}\nexports.recreateType = recreateType;\nfunction recreateDirective(directive, resolveType) {\n    return new graphql_1.GraphQLDirective({\n        name: directive.name,\n        description: directive.description,\n        locations: directive.locations,\n        args: argsToFieldConfigArgumentMap(directive.args, resolveType),\n        astNode: directive.astNode,\n    });\n}\nexports.recreateDirective = recreateDirective;\nfunction parseLiteral(ast) {\n    switch (ast.kind) {\n        case graphql_1.Kind.STRING:\n        case graphql_1.Kind.BOOLEAN: {\n            return ast.value;\n        }\n        case graphql_1.Kind.INT:\n        case graphql_1.Kind.FLOAT: {\n            return parseFloat(ast.value);\n        }\n        case graphql_1.Kind.OBJECT: {\n            var value_1 = Object.create(null);\n            ast.fields.forEach(function (field) {\n                value_1[field.name.value] = parseLiteral(field.value);\n            });\n            return value_1;\n        }\n        case graphql_1.Kind.LIST: {\n            return ast.values.map(parseLiteral);\n        }\n        default:\n            return null;\n    }\n}\nfunction fieldMapToFieldConfigMap(fields, resolveType, keepResolvers) {\n    var result = {};\n    Object.keys(fields).forEach(function (name) {\n        var field = fields[name];\n        var type = resolveType(field.type);\n        if (type !== null) {\n            result[name] = fieldToFieldConfig(fields[name], resolveType, keepResolvers);\n        }\n    });\n    return result;\n}\nexports.fieldMapToFieldConfigMap = fieldMapToFieldConfigMap;\nfunction createResolveType(getType) {\n    var resolveType = function (type) {\n        if (type instanceof graphql_1.GraphQLList) {\n            var innerType = resolveType(type.ofType);\n            if (innerType === null) {\n                return null;\n            }\n            else {\n                return new graphql_1.GraphQLList(innerType);\n            }\n        }\n        else if (type instanceof graphql_1.GraphQLNonNull) {\n            var innerType = resolveType(type.ofType);\n            if (innerType === null) {\n                return null;\n            }\n            else {\n                return new graphql_1.GraphQLNonNull(innerType);\n            }\n        }\n        else if (graphql_1.isNamedType(type)) {\n            var typeName = graphql_1.getNamedType(type).name;\n            switch (typeName) {\n                case graphql_1.GraphQLInt.name:\n                    return graphql_1.GraphQLInt;\n                case graphql_1.GraphQLFloat.name:\n                    return graphql_1.GraphQLFloat;\n                case graphql_1.GraphQLString.name:\n                    return graphql_1.GraphQLString;\n                case graphql_1.GraphQLBoolean.name:\n                    return graphql_1.GraphQLBoolean;\n                case graphql_1.GraphQLID.name:\n                    return graphql_1.GraphQLID;\n                default:\n                    return getType(typeName, type);\n            }\n        }\n        else {\n            return type;\n        }\n    };\n    return resolveType;\n}\nexports.createResolveType = createResolveType;\nfunction fieldToFieldConfig(field, resolveType, keepResolvers) {\n    return {\n        type: resolveType(field.type),\n        args: argsToFieldConfigArgumentMap(field.args, resolveType),\n        resolve: keepResolvers ? field.resolve : defaultMergedResolver_1.default,\n        subscribe: keepResolvers ? field.subscribe : null,\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        astNode: field.astNode,\n    };\n}\nexports.fieldToFieldConfig = fieldToFieldConfig;\nfunction argsToFieldConfigArgumentMap(args, resolveType) {\n    var result = {};\n    args.forEach(function (arg) {\n        var newArg = argumentToArgumentConfig(arg, resolveType);\n        if (newArg) {\n            result[newArg[0]] = newArg[1];\n        }\n    });\n    return result;\n}\nexports.argsToFieldConfigArgumentMap = argsToFieldConfigArgumentMap;\nfunction argumentToArgumentConfig(argument, resolveType) {\n    var type = resolveType(argument.type);\n    if (type === null) {\n        return null;\n    }\n    else {\n        return [\n            argument.name,\n            {\n                type: type,\n                defaultValue: argument.defaultValue,\n                description: argument.description,\n            },\n        ];\n    }\n}\nexports.argumentToArgumentConfig = argumentToArgumentConfig;\nfunction inputFieldMapToFieldConfigMap(fields, resolveType) {\n    var result = {};\n    Object.keys(fields).forEach(function (name) {\n        var field = fields[name];\n        var type = resolveType(field.type);\n        if (type !== null) {\n            result[name] = inputFieldToFieldConfig(fields[name], resolveType);\n        }\n    });\n    return result;\n}\nexports.inputFieldMapToFieldConfigMap = inputFieldMapToFieldConfigMap;\nfunction inputFieldToFieldConfig(field, resolveType) {\n    return {\n        type: resolveType(field.type),\n        defaultValue: field.defaultValue,\n        description: field.description,\n        astNode: field.astNode,\n    };\n}\nexports.inputFieldToFieldConfig = inputFieldToFieldConfig;\n\n\n//# sourceURL=webpack:///./src/stitching/schemaRecreation.ts?");

/***/ }),

/***/ "./src/stitching/typeFromAST.ts":
/*!**************************************!*\
  !*** ./src/stitching/typeFromAST.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar resolveFromParentTypename_1 = __webpack_require__(/*! ./resolveFromParentTypename */ \"./src/stitching/resolveFromParentTypename.ts\");\nvar backcompatOptions = { commentDescriptions: true };\nfunction typeFromAST(node) {\n    switch (node.kind) {\n        case graphql_1.Kind.OBJECT_TYPE_DEFINITION:\n            return makeObjectType(node);\n        case graphql_1.Kind.INTERFACE_TYPE_DEFINITION:\n            return makeInterfaceType(node);\n        case graphql_1.Kind.ENUM_TYPE_DEFINITION:\n            return makeEnumType(node);\n        case graphql_1.Kind.UNION_TYPE_DEFINITION:\n            return makeUnionType(node);\n        case graphql_1.Kind.SCALAR_TYPE_DEFINITION:\n            return makeScalarType(node);\n        case graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION:\n            return makeInputObjectType(node);\n        case graphql_1.Kind.DIRECTIVE_DEFINITION:\n            return makeDirective(node);\n        default:\n            return null;\n    }\n}\nexports.default = typeFromAST;\nfunction makeObjectType(node) {\n    return new graphql_1.GraphQLObjectType({\n        name: node.name.value,\n        fields: function () { return makeFields(node.fields); },\n        interfaces: function () {\n            return node.interfaces.map(function (iface) { return createNamedStub(iface.name.value, 'interface'); });\n        },\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeInterfaceType(node) {\n    return new graphql_1.GraphQLInterfaceType({\n        name: node.name.value,\n        fields: function () { return makeFields(node.fields); },\n        description: graphql_1.getDescription(node, backcompatOptions),\n        resolveType: function (parent, context, info) {\n            return resolveFromParentTypename_1.default(parent, info.schema);\n        },\n    });\n}\nfunction makeEnumType(node) {\n    var values = {};\n    node.values.forEach(function (value) {\n        values[value.name.value] = {\n            description: graphql_1.getDescription(value, backcompatOptions),\n        };\n    });\n    return new graphql_1.GraphQLEnumType({\n        name: node.name.value,\n        values: values,\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeUnionType(node) {\n    return new graphql_1.GraphQLUnionType({\n        name: node.name.value,\n        types: function () {\n            return node.types.map(function (type) { return resolveType(type, 'object'); });\n        },\n        description: graphql_1.getDescription(node, backcompatOptions),\n        resolveType: function (parent, context, info) {\n            return resolveFromParentTypename_1.default(parent, info.schema);\n        },\n    });\n}\nfunction makeScalarType(node) {\n    return new graphql_1.GraphQLScalarType({\n        name: node.name.value,\n        description: graphql_1.getDescription(node, backcompatOptions),\n        serialize: function () { return null; },\n        // Note: validation calls the parse functions to determine if a\n        // literal value is correct. Returning null would cause use of custom\n        // scalars to always fail validation. Returning false causes them to\n        // always pass validation.\n        parseValue: function () { return false; },\n        parseLiteral: function () { return false; },\n    });\n}\nfunction makeInputObjectType(node) {\n    return new graphql_1.GraphQLInputObjectType({\n        name: node.name.value,\n        fields: function () { return makeValues(node.fields); },\n        description: graphql_1.getDescription(node, backcompatOptions),\n    });\n}\nfunction makeFields(nodes) {\n    var result = {};\n    nodes.forEach(function (node) {\n        var deprecatedDirective = node.directives.find(function (directive) {\n            return directive && directive.name && directive.name.value === 'deprecated';\n        });\n        var deprecatedArgument = deprecatedDirective &&\n            deprecatedDirective.arguments &&\n            deprecatedDirective.arguments.find(function (arg) { return arg && arg.name && arg.name.value === 'reason'; });\n        var deprecationReason = deprecatedArgument &&\n            deprecatedArgument.value &&\n            deprecatedArgument.value.value;\n        result[node.name.value] = {\n            type: resolveType(node.type, 'object'),\n            args: makeValues(node.arguments),\n            description: graphql_1.getDescription(node, backcompatOptions),\n            deprecationReason: deprecationReason,\n        };\n    });\n    return result;\n}\nfunction makeValues(nodes) {\n    var result = {};\n    nodes.forEach(function (node) {\n        var type = resolveType(node.type, 'input');\n        result[node.name.value] = {\n            type: type,\n            defaultValue: graphql_1.valueFromAST(node.defaultValue, type),\n            description: graphql_1.getDescription(node, backcompatOptions),\n        };\n    });\n    return result;\n}\nfunction resolveType(node, type) {\n    switch (node.kind) {\n        case graphql_1.Kind.LIST_TYPE:\n            return new graphql_1.GraphQLList(resolveType(node.type, type));\n        case graphql_1.Kind.NON_NULL_TYPE:\n            return new graphql_1.GraphQLNonNull(resolveType(node.type, type));\n        default:\n            return createNamedStub(node.name.value, type);\n    }\n}\nfunction createNamedStub(name, type) {\n    var constructor;\n    if (type === 'object') {\n        constructor = graphql_1.GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = graphql_1.GraphQLInterfaceType;\n    }\n    else {\n        constructor = graphql_1.GraphQLInputObjectType;\n    }\n    return new constructor({\n        name: name,\n        fields: {\n            __fake: {\n                type: graphql_1.GraphQLString,\n            },\n        },\n    });\n}\nfunction makeDirective(node) {\n    var locations = [];\n    node.locations.forEach(function (location) {\n        if (location.value in graphql_1.DirectiveLocation) {\n            locations.push(location.value);\n        }\n    });\n    return new graphql_1.GraphQLDirective({\n        name: node.name.value,\n        description: node.description ? node.description.value : null,\n        args: makeValues(node.arguments),\n        locations: locations,\n    });\n}\n\n\n//# sourceURL=webpack:///./src/stitching/typeFromAST.ts?");

/***/ }),

/***/ "./src/transforms/AddArgumentsAsVariables.ts":
/*!***************************************************!*\
  !*** ./src/transforms/AddArgumentsAsVariables.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar AddArgumentsAsVariablesTransform = /** @class */ (function () {\n    function AddArgumentsAsVariablesTransform(schema, args) {\n        this.schema = schema;\n        this.args = args;\n    }\n    AddArgumentsAsVariablesTransform.prototype.transformRequest = function (originalRequest) {\n        var _a = addVariablesToRootField(this.schema, originalRequest.document, this.args), document = _a.document, newVariables = _a.newVariables;\n        var variables = __assign({}, originalRequest.variables, newVariables);\n        return {\n            document: document,\n            variables: variables\n        };\n    };\n    return AddArgumentsAsVariablesTransform;\n}());\nexports.default = AddArgumentsAsVariablesTransform;\nfunction addVariablesToRootField(targetSchema, document, args) {\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var variableNames = {};\n    var newOperations = operations.map(function (operation) {\n        var existingVariables = operation.variableDefinitions.map(function (variableDefinition) { return variableDefinition.variable.name.value; });\n        var variableCounter = 0;\n        var variables = {};\n        var generateVariableName = function (argName) {\n            var varName;\n            do {\n                varName = \"_v\" + variableCounter + \"_\" + argName;\n                variableCounter++;\n            } while (existingVariables.indexOf(varName) !== -1);\n            return varName;\n        };\n        var type;\n        if (operation.operation === 'subscription') {\n            type = targetSchema.getSubscriptionType();\n        }\n        else if (operation.operation === 'mutation') {\n            type = targetSchema.getMutationType();\n        }\n        else {\n            type = targetSchema.getQueryType();\n        }\n        var newSelectionSet = [];\n        operation.selectionSet.selections.forEach(function (selection) {\n            if (selection.kind === graphql_1.Kind.FIELD) {\n                var newArgs_1 = {};\n                selection.arguments.forEach(function (argument) {\n                    newArgs_1[argument.name.value] = argument;\n                });\n                var name_1 = selection.name.value;\n                var field = type.getFields()[name_1];\n                field.args.forEach(function (argument) {\n                    if (argument.name in args) {\n                        var variableName = generateVariableName(argument.name);\n                        variableNames[argument.name] = variableName;\n                        newArgs_1[argument.name] = {\n                            kind: graphql_1.Kind.ARGUMENT,\n                            name: {\n                                kind: graphql_1.Kind.NAME,\n                                value: argument.name\n                            },\n                            value: {\n                                kind: graphql_1.Kind.VARIABLE,\n                                name: {\n                                    kind: graphql_1.Kind.NAME,\n                                    value: variableName\n                                }\n                            }\n                        };\n                        existingVariables.push(variableName);\n                        variables[variableName] = {\n                            kind: graphql_1.Kind.VARIABLE_DEFINITION,\n                            variable: {\n                                kind: graphql_1.Kind.VARIABLE,\n                                name: {\n                                    kind: graphql_1.Kind.NAME,\n                                    value: variableName\n                                }\n                            },\n                            type: typeToAst(argument.type)\n                        };\n                    }\n                });\n                newSelectionSet.push(__assign({}, selection, { arguments: Object.keys(newArgs_1).map(function (argName) { return newArgs_1[argName]; }) }));\n            }\n            else {\n                newSelectionSet.push(selection);\n            }\n        });\n        return __assign({}, operation, { variableDefinitions: operation.variableDefinitions.concat(Object.keys(variables).map(function (varName) { return variables[varName]; })), selectionSet: {\n                kind: graphql_1.Kind.SELECTION_SET,\n                selections: newSelectionSet\n            } });\n    });\n    var newVariables = {};\n    Object.keys(variableNames).forEach(function (name) {\n        newVariables[variableNames[name]] = args[name];\n    });\n    return {\n        document: __assign({}, document, { definitions: newOperations.concat(fragments) }),\n        newVariables: newVariables\n    };\n}\nfunction typeToAst(type) {\n    if (type instanceof graphql_1.GraphQLNonNull) {\n        var innerType = typeToAst(type.ofType);\n        if (innerType.kind === graphql_1.Kind.LIST_TYPE || innerType.kind === graphql_1.Kind.NAMED_TYPE) {\n            return {\n                kind: graphql_1.Kind.NON_NULL_TYPE,\n                type: innerType\n            };\n        }\n        else {\n            throw new Error('Incorrent inner non-null type');\n        }\n    }\n    else if (type instanceof graphql_1.GraphQLList) {\n        return {\n            kind: graphql_1.Kind.LIST_TYPE,\n            type: typeToAst(type.ofType)\n        };\n    }\n    else {\n        return {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type.toString()\n            }\n        };\n    }\n}\n\n\n//# sourceURL=webpack:///./src/transforms/AddArgumentsAsVariables.ts?");

/***/ }),

/***/ "./src/transforms/AddTypenameToAbstract.ts":
/*!*************************************************!*\
  !*** ./src/transforms/AddTypenameToAbstract.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar AddTypenameToAbstract = /** @class */ (function () {\n    function AddTypenameToAbstract(targetSchema) {\n        this.targetSchema = targetSchema;\n    }\n    AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {\n        var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return AddTypenameToAbstract;\n}());\nexports.default = AddTypenameToAbstract;\nfunction addTypenameToAbstract(targetSchema, document) {\n    var _a;\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var parentType = typeInfo.getParentType();\n            var selections = node.selections;\n            if (parentType &&\n                (parentType instanceof graphql_1.GraphQLInterfaceType ||\n                    parentType instanceof graphql_1.GraphQLUnionType) &&\n                !selections.find(function (_) {\n                    return _.kind === graphql_1.Kind.FIELD &&\n                        _.name.value === '__typename';\n                })) {\n                selections = selections.concat({\n                    kind: graphql_1.Kind.FIELD,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            if (selections !== node.selections) {\n                return __assign({}, node, { selections: selections });\n            }\n        },\n        _a)));\n}\n\n\n//# sourceURL=webpack:///./src/transforms/AddTypenameToAbstract.ts?");

/***/ }),

/***/ "./src/transforms/CheckResultAndHandleErrors.ts":
/*!******************************************************!*\
  !*** ./src/transforms/CheckResultAndHandleErrors.ts ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar errors_1 = __webpack_require__(/*! ../stitching/errors */ \"./src/stitching/errors.ts\");\nvar CheckResultAndHandleErrors = /** @class */ (function () {\n    function CheckResultAndHandleErrors(info, fieldName) {\n        this.info = info;\n        this.fieldName = fieldName;\n    }\n    CheckResultAndHandleErrors.prototype.transformResult = function (result) {\n        return errors_1.checkResultAndHandleErrors(result, this.info, this.fieldName);\n    };\n    return CheckResultAndHandleErrors;\n}());\nexports.default = CheckResultAndHandleErrors;\n\n\n//# sourceURL=webpack:///./src/transforms/CheckResultAndHandleErrors.ts?");

/***/ }),

/***/ "./src/transforms/ConvertEnumResponse.ts":
/*!***********************************************!*\
  !*** ./src/transforms/ConvertEnumResponse.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar ConvertEnumResponse = /** @class */ (function () {\n    function ConvertEnumResponse(enumNode) {\n        this.enumNode = enumNode;\n    }\n    ConvertEnumResponse.prototype.transformResult = function (result) {\n        var value = this.enumNode.getValue(result);\n        if (value) {\n            return value.value;\n        }\n        return result;\n    };\n    return ConvertEnumResponse;\n}());\nexports.default = ConvertEnumResponse;\n\n\n//# sourceURL=webpack:///./src/transforms/ConvertEnumResponse.ts?");

/***/ }),

/***/ "./src/transforms/ConvertEnumValues.ts":
/*!*********************************************!*\
  !*** ./src/transforms/ConvertEnumValues.ts ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./src/transforms/visitSchema.ts\");\n// Transformation used to modifiy `GraphQLEnumType` values in a schema.\nvar ConvertEnumValues = /** @class */ (function () {\n    function ConvertEnumValues(enumValueMap) {\n        this.enumValueMap = enumValueMap;\n    }\n    // Walk a schema looking for `GraphQLEnumType` types. If found, and\n    // matching types have been identified in `this.enumValueMap`, create new\n    // `GraphQLEnumType` types using the `this.enumValueMap` specified new\n    // values, and return them in the new schema.\n    ConvertEnumValues.prototype.transformSchema = function (schema) {\n        var _a;\n        var enumValueMap = this.enumValueMap;\n        if (!enumValueMap || Object.keys(enumValueMap).length === 0) {\n            return schema;\n        }\n        var transformedSchema = visitSchema_1.visitSchema(schema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.ENUM_TYPE] = function (enumType) {\n                var externalToInternalValueMap = enumValueMap[enumType.name];\n                if (externalToInternalValueMap) {\n                    var values = enumType.getValues();\n                    var newValues_1 = {};\n                    values.forEach(function (value) {\n                        var newValue = Object.keys(externalToInternalValueMap).includes(value.name)\n                            ? externalToInternalValueMap[value.name]\n                            : value.name;\n                        newValues_1[value.name] = {\n                            value: newValue,\n                            deprecationReason: value.deprecationReason,\n                            description: value.description,\n                            astNode: value.astNode,\n                        };\n                    });\n                    return new graphql_1.GraphQLEnumType({\n                        name: enumType.name,\n                        description: enumType.description,\n                        astNode: enumType.astNode,\n                        values: newValues_1,\n                    });\n                }\n                return enumType;\n            },\n            _a));\n        return transformedSchema;\n    };\n    return ConvertEnumValues;\n}());\nexports.default = ConvertEnumValues;\n\n\n//# sourceURL=webpack:///./src/transforms/ConvertEnumValues.ts?");

/***/ }),

/***/ "./src/transforms/ExpandAbstractTypes.ts":
/*!***********************************************!*\
  !*** ./src/transforms/ExpandAbstractTypes.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar implementsAbstractType_1 = __webpack_require__(/*! ../implementsAbstractType */ \"./src/implementsAbstractType.ts\");\nvar ExpandAbstractTypes = /** @class */ (function () {\n    function ExpandAbstractTypes(transformedSchema, targetSchema) {\n        this.targetSchema = targetSchema;\n        this.mapping = extractPossibleTypes(transformedSchema, targetSchema);\n        this.reverseMapping = flipMapping(this.mapping);\n    }\n    ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\n        var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return ExpandAbstractTypes;\n}());\nexports.default = ExpandAbstractTypes;\nfunction extractPossibleTypes(transformedSchema, targetSchema) {\n    var typeMap = transformedSchema.getTypeMap();\n    var mapping = {};\n    Object.keys(typeMap).forEach(function (typeName) {\n        var type = typeMap[typeName];\n        if (graphql_1.isAbstractType(type)) {\n            var targetType = targetSchema.getType(typeName);\n            if (!graphql_1.isAbstractType(targetType)) {\n                var implementations = transformedSchema.getPossibleTypes(type) || [];\n                mapping[typeName] = implementations\n                    .filter(function (impl) { return targetSchema.getType(impl.name); })\n                    .map(function (impl) { return impl.name; });\n            }\n        }\n    });\n    return mapping;\n}\nfunction flipMapping(mapping) {\n    var result = {};\n    Object.keys(mapping).forEach(function (typeName) {\n        var toTypeNames = mapping[typeName];\n        toTypeNames.forEach(function (toTypeName) {\n            if (!result[toTypeName]) {\n                result[toTypeName] = [];\n            }\n            result[toTypeName].push(typeName);\n        });\n    });\n    return result;\n}\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\n    var _a;\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var existingFragmentNames = fragments.map(function (fragment) { return fragment.name.value; });\n    var fragmentCounter = 0;\n    var generateFragmentName = function (typeName) {\n        var fragmentName;\n        do {\n            fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter;\n            fragmentCounter++;\n        } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n        return fragmentName;\n    };\n    var newFragments = [];\n    var fragmentReplacements = {};\n    fragments.forEach(function (fragment) {\n        newFragments.push(fragment);\n        var possibleTypes = mapping[fragment.typeCondition.name.value];\n        if (possibleTypes) {\n            fragmentReplacements[fragment.name.value] = [];\n            possibleTypes.forEach(function (possibleTypeName) {\n                var name = generateFragmentName(possibleTypeName);\n                existingFragmentNames.push(name);\n                var newFragment = {\n                    kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: name,\n                    },\n                    typeCondition: {\n                        kind: graphql_1.Kind.NAMED_TYPE,\n                        name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: possibleTypeName,\n                        },\n                    },\n                    selectionSet: fragment.selectionSet,\n                };\n                newFragments.push(newFragment);\n                fragmentReplacements[fragment.name.value].push({\n                    fragmentName: name,\n                    typeName: possibleTypeName,\n                });\n            });\n        }\n    });\n    var newDocument = __assign({}, document, { definitions: operations.concat(newFragments) });\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(newDocument, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var newSelections = node.selections.slice();\n            var parentType = graphql_1.getNamedType(typeInfo.getParentType());\n            node.selections.forEach(function (selection) {\n                if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n                    var possibleTypes = mapping[selection.typeCondition.name.value];\n                    if (possibleTypes) {\n                        possibleTypes.forEach(function (possibleType) {\n                            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(possibleType))) {\n                                newSelections.push({\n                                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                                    typeCondition: {\n                                        kind: graphql_1.Kind.NAMED_TYPE,\n                                        name: {\n                                            kind: graphql_1.Kind.NAME,\n                                            value: possibleType,\n                                        },\n                                    },\n                                    selectionSet: selection.selectionSet,\n                                });\n                            }\n                        });\n                    }\n                }\n                else if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {\n                    var fragmentName = selection.name.value;\n                    var replacements = fragmentReplacements[fragmentName];\n                    if (replacements) {\n                        replacements.forEach(function (replacement) {\n                            var typeName = replacement.typeName;\n                            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(typeName))) {\n                                newSelections.push({\n                                    kind: graphql_1.Kind.FRAGMENT_SPREAD,\n                                    name: {\n                                        kind: graphql_1.Kind.NAME,\n                                        value: replacement.fragmentName,\n                                    },\n                                });\n                            }\n                        });\n                    }\n                }\n            });\n            if (parentType && reverseMapping[parentType.name]) {\n                newSelections.push({\n                    kind: graphql_1.Kind.FIELD,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            if (newSelections.length !== node.selections.length) {\n                return __assign({}, node, { selections: newSelections });\n            }\n        },\n        _a)));\n}\n\n\n//# sourceURL=webpack:///./src/transforms/ExpandAbstractTypes.ts?");

/***/ }),

/***/ "./src/transforms/ExtractField.ts":
/*!****************************************!*\
  !*** ./src/transforms/ExtractField.ts ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar ExtractField = /** @class */ (function () {\n    function ExtractField(_a) {\n        var from = _a.from, to = _a.to;\n        this.from = from;\n        this.to = to;\n    }\n    ExtractField.prototype.transformRequest = function (originalRequest) {\n        var _a, _b;\n        var fromSelection;\n        var ourPathFrom = JSON.stringify(this.from);\n        var ourPathTo = JSON.stringify(this.to);\n        var fieldPath = [];\n        graphql_1.visit(originalRequest.document, (_a = {},\n            _a[graphql_1.Kind.FIELD] = {\n                enter: function (node) {\n                    fieldPath.push(node.name.value);\n                    if (ourPathFrom === JSON.stringify(fieldPath)) {\n                        fromSelection = node.selectionSet;\n                        return graphql_1.BREAK;\n                    }\n                },\n                leave: function (node) {\n                    fieldPath.pop();\n                },\n            },\n            _a));\n        fieldPath = [];\n        var newDocument = graphql_1.visit(originalRequest.document, (_b = {},\n            _b[graphql_1.Kind.FIELD] = {\n                enter: function (node) {\n                    fieldPath.push(node.name.value);\n                    if (ourPathTo === JSON.stringify(fieldPath) && fromSelection) {\n                        return __assign({}, node, { selectionSet: fromSelection });\n                    }\n                },\n                leave: function (node) {\n                    fieldPath.pop();\n                },\n            },\n            _b));\n        return __assign({}, originalRequest, { document: newDocument });\n    };\n    return ExtractField;\n}());\nexports.default = ExtractField;\n\n\n//# sourceURL=webpack:///./src/transforms/ExtractField.ts?");

/***/ }),

/***/ "./src/transforms/FilterRootFields.ts":
/*!********************************************!*\
  !*** ./src/transforms/FilterRootFields.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar TransformRootFields_1 = __webpack_require__(/*! ./TransformRootFields */ \"./src/transforms/TransformRootFields.ts\");\nvar FilterRootFields = /** @class */ (function () {\n    function FilterRootFields(filter) {\n        this.transformer = new TransformRootFields_1.default(function (operation, fieldName, field) {\n            if (filter(operation, fieldName, field)) {\n                return undefined;\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    FilterRootFields.prototype.transformSchema = function (originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    };\n    return FilterRootFields;\n}());\nexports.default = FilterRootFields;\n\n\n//# sourceURL=webpack:///./src/transforms/FilterRootFields.ts?");

/***/ }),

/***/ "./src/transforms/FilterToSchema.ts":
/*!******************************************!*\
  !*** ./src/transforms/FilterToSchema.ts ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar implementsAbstractType_1 = __webpack_require__(/*! ../implementsAbstractType */ \"./src/implementsAbstractType.ts\");\nvar FilterToSchema = /** @class */ (function () {\n    function FilterToSchema(targetSchema) {\n        this.targetSchema = targetSchema;\n    }\n    FilterToSchema.prototype.transformRequest = function (originalRequest) {\n        var document = filterDocumentToSchema(this.targetSchema, originalRequest.document);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return FilterToSchema;\n}());\nexports.default = FilterToSchema;\nfunction filterDocumentToSchema(targetSchema, document) {\n    var operations = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.OPERATION_DEFINITION; });\n    var fragments = document.definitions.filter(function (def) { return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION; });\n    var usedFragments = [];\n    var newOperations = [];\n    var newFragments = [];\n    var validFragments = fragments.filter(function (fragment) {\n        var typeName = fragment.typeCondition.name.value;\n        return Boolean(targetSchema.getType(typeName));\n    });\n    var validFragmentsWithType = {};\n    validFragments.forEach(function (fragment) {\n        var typeName = fragment.typeCondition.name.value;\n        var type = targetSchema.getType(typeName);\n        validFragmentsWithType[fragment.name.value] = type;\n    });\n    var fragmentSet = Object.create(null);\n    operations.forEach(function (operation) {\n        var type;\n        if (operation.operation === 'subscription') {\n            type = targetSchema.getSubscriptionType();\n        }\n        else if (operation.operation === 'mutation') {\n            type = targetSchema.getMutationType();\n        }\n        else {\n            type = targetSchema.getQueryType();\n        }\n        var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet), selectionSet = _a.selectionSet, operationUsedFragments = _a.usedFragments, operationUsedVariables = _a.usedVariables;\n        usedFragments = union(usedFragments, operationUsedFragments);\n        var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments), collectedUsedVariables = _b.usedVariables, collectedNewFragments = _b.newFragments, collectedFragmentSet = _b.fragmentSet;\n        var fullUsedVariables = union(operationUsedVariables, collectedUsedVariables);\n        newFragments = collectedNewFragments;\n        fragmentSet = collectedFragmentSet;\n        var variableDefinitions = operation.variableDefinitions.filter(function (variable) { return fullUsedVariables.indexOf(variable.variable.name.value) !== -1; });\n        newOperations.push({\n            kind: graphql_1.Kind.OPERATION_DEFINITION,\n            operation: operation.operation,\n            name: operation.name,\n            directives: operation.directives,\n            variableDefinitions: variableDefinitions,\n            selectionSet: selectionSet\n        });\n    });\n    return {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: newOperations.concat(newFragments)\n    };\n}\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\n    var usedVariables = [];\n    var newFragments = [];\n    var _loop_1 = function () {\n        var nextFragmentName = usedFragments.pop();\n        var fragment = validFragments.find(function (fr) { return fr.name.value === nextFragmentName; });\n        if (fragment) {\n            var name_1 = nextFragmentName;\n            var typeName = fragment.typeCondition.name.value;\n            var type = targetSchema.getType(typeName);\n            var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet), selectionSet = _a.selectionSet, fragmentUsedFragments = _a.usedFragments, fragmentUsedVariables = _a.usedVariables;\n            usedFragments = union(usedFragments, fragmentUsedFragments);\n            usedVariables = union(usedVariables, fragmentUsedVariables);\n            if (!fragmentSet[name_1]) {\n                fragmentSet[name_1] = true;\n                newFragments.push({\n                    kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: graphql_1.Kind.NAME,\n                        value: name_1\n                    },\n                    typeCondition: fragment.typeCondition,\n                    selectionSet: selectionSet\n                });\n            }\n        }\n    };\n    while (usedFragments.length !== 0) {\n        _loop_1();\n    }\n    return {\n        usedVariables: usedVariables,\n        newFragments: newFragments,\n        fragmentSet: fragmentSet\n    };\n}\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\n    var _a;\n    var usedFragments = [];\n    var usedVariables = [];\n    var typeStack = [type];\n    // Should be rewritten using visitWithSchema\n    var filteredSelectionSet = graphql_1.visit(selectionSet, (_a = {},\n        _a[graphql_1.Kind.FIELD] = {\n            enter: function (node) {\n                var parentType = resolveType(typeStack[typeStack.length - 1]);\n                if (parentType instanceof graphql_1.GraphQLObjectType || parentType instanceof graphql_1.GraphQLInterfaceType) {\n                    var fields = parentType.getFields();\n                    var field = node.name.value === '__typename' ? graphql_1.TypeNameMetaFieldDef : fields[node.name.value];\n                    if (!field) {\n                        return null;\n                    }\n                    else {\n                        typeStack.push(field.type);\n                    }\n                    var argNames_1 = (field.args || []).map(function (arg) { return arg.name; });\n                    if (node.arguments) {\n                        var args = node.arguments.filter(function (arg) {\n                            return argNames_1.indexOf(arg.name.value) !== -1;\n                        });\n                        if (args.length !== node.arguments.length) {\n                            return __assign({}, node, { arguments: args });\n                        }\n                    }\n                }\n                else if (parentType instanceof graphql_1.GraphQLUnionType && node.name.value === '__typename') {\n                    typeStack.push(graphql_1.TypeNameMetaFieldDef.type);\n                }\n            },\n            leave: function (node) {\n                var _a;\n                var currentType = typeStack.pop();\n                var resolvedType = resolveType(currentType);\n                if (resolvedType instanceof graphql_1.GraphQLObjectType || resolvedType instanceof graphql_1.GraphQLInterfaceType) {\n                    var selections = (node.selectionSet && node.selectionSet.selections) || null;\n                    if (!selections || selections.length === 0) {\n                        // need to remove any added variables. Is there a better way to do this?\n                        graphql_1.visit(node, (_a = {},\n                            _a[graphql_1.Kind.VARIABLE] = function (variableNode) {\n                                var index = usedVariables.indexOf(variableNode.name.value);\n                                if (index !== -1) {\n                                    usedVariables.splice(index, 1);\n                                }\n                            },\n                            _a));\n                        return null;\n                    }\n                }\n            }\n        },\n        _a[graphql_1.Kind.FRAGMENT_SPREAD] = function (node) {\n            if (node.name.value in validFragments) {\n                var parentType = resolveType(typeStack[typeStack.length - 1]);\n                var innerType = validFragments[node.name.value];\n                if (!implementsAbstractType_1.default(schema, parentType, innerType)) {\n                    return null;\n                }\n                else {\n                    usedFragments.push(node.name.value);\n                    return;\n                }\n            }\n            else {\n                return null;\n            }\n        },\n        _a[graphql_1.Kind.INLINE_FRAGMENT] = {\n            enter: function (node) {\n                if (node.typeCondition) {\n                    var innerType = schema.getType(node.typeCondition.name.value);\n                    var parentType = resolveType(typeStack[typeStack.length - 1]);\n                    if (implementsAbstractType_1.default(schema, parentType, innerType)) {\n                        typeStack.push(innerType);\n                    }\n                    else {\n                        return null;\n                    }\n                }\n            },\n            leave: function (node) {\n                typeStack.pop();\n            }\n        },\n        _a[graphql_1.Kind.VARIABLE] = function (node) {\n            usedVariables.push(node.name.value);\n        },\n        _a));\n    return {\n        selectionSet: filteredSelectionSet,\n        usedFragments: usedFragments,\n        usedVariables: usedVariables\n    };\n}\nfunction resolveType(type) {\n    var lastType = type;\n    while (lastType instanceof graphql_1.GraphQLNonNull || lastType instanceof graphql_1.GraphQLList) {\n        lastType = lastType.ofType;\n    }\n    return lastType;\n}\nfunction union() {\n    var arrays = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        arrays[_i] = arguments[_i];\n    }\n    var cache = {};\n    var result = [];\n    arrays.forEach(function (array) {\n        array.forEach(function (item) {\n            if (!cache[item]) {\n                cache[item] = true;\n                result.push(item);\n            }\n        });\n    });\n    return result;\n}\n\n\n//# sourceURL=webpack:///./src/transforms/FilterToSchema.ts?");

/***/ }),

/***/ "./src/transforms/FilterTypes.ts":
/*!***************************************!*\
  !*** ./src/transforms/FilterTypes.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* tslint:disable:no-unused-expression */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./src/transforms/visitSchema.ts\");\nvar FilterTypes = /** @class */ (function () {\n    function FilterTypes(filter) {\n        this.filter = filter;\n    }\n    FilterTypes.prototype.transformSchema = function (schema) {\n        var _this = this;\n        var _a;\n        return visitSchema_1.visitSchema(schema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.TYPE] = function (type) {\n                if (_this.filter(type)) {\n                    return undefined;\n                }\n                else {\n                    return null;\n                }\n            },\n            _a));\n    };\n    return FilterTypes;\n}());\nexports.default = FilterTypes;\n\n\n//# sourceURL=webpack:///./src/transforms/FilterTypes.ts?");

/***/ }),

/***/ "./src/transforms/RenameRootFields.ts":
/*!********************************************!*\
  !*** ./src/transforms/RenameRootFields.ts ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar schemaRecreation_1 = __webpack_require__(/*! ../stitching/schemaRecreation */ \"./src/stitching/schemaRecreation.ts\");\nvar TransformRootFields_1 = __webpack_require__(/*! ./TransformRootFields */ \"./src/transforms/TransformRootFields.ts\");\nvar RenameRootFields = /** @class */ (function () {\n    function RenameRootFields(renamer) {\n        var resolveType = schemaRecreation_1.createResolveType(function (name, type) { return type; });\n        this.transformer = new TransformRootFields_1.default(function (operation, fieldName, field) {\n            return {\n                name: renamer(operation, fieldName, field),\n                field: schemaRecreation_1.fieldToFieldConfig(field, resolveType, true),\n            };\n        });\n    }\n    RenameRootFields.prototype.transformSchema = function (originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    };\n    return RenameRootFields;\n}());\nexports.default = RenameRootFields;\n\n\n//# sourceURL=webpack:///./src/transforms/RenameRootFields.ts?");

/***/ }),

/***/ "./src/transforms/RenameTypes.ts":
/*!***************************************!*\
  !*** ./src/transforms/RenameTypes.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar isSpecifiedScalarType_1 = __webpack_require__(/*! ../isSpecifiedScalarType */ \"./src/isSpecifiedScalarType.ts\");\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./src/transforms/visitSchema.ts\");\nvar RenameTypes = /** @class */ (function () {\n    function RenameTypes(renamer, options) {\n        this.renamer = renamer;\n        this.reverseMap = {};\n        var _a = options || {}, _b = _a.renameBuiltins, renameBuiltins = _b === void 0 ? false : _b, _c = _a.renameScalars, renameScalars = _c === void 0 ? true : _c;\n        this.renameBuiltins = renameBuiltins;\n        this.renameScalars = renameScalars;\n    }\n    RenameTypes.prototype.transformSchema = function (originalSchema) {\n        var _this = this;\n        var _a;\n        return visitSchema_1.visitSchema(originalSchema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.TYPE] = function (type) {\n                if (isSpecifiedScalarType_1.default(type) && !_this.renameBuiltins) {\n                    return undefined;\n                }\n                if (type instanceof graphql_1.GraphQLScalarType && !_this.renameScalars) {\n                    return undefined;\n                }\n                var newName = _this.renamer(type.name);\n                if (newName && newName !== type.name) {\n                    _this.reverseMap[newName] = type.name;\n                    var newType = Object.assign(Object.create(type), type);\n                    newType.name = newName;\n                    return newType;\n                }\n            },\n            _a[visitSchema_1.VisitSchemaKind.ROOT_OBJECT] = function (type) {\n                return undefined;\n            },\n            _a));\n    };\n    RenameTypes.prototype.transformRequest = function (originalRequest) {\n        var _this = this;\n        var _a;\n        var newDocument = graphql_1.visit(originalRequest.document, (_a = {},\n            _a[graphql_1.Kind.NAMED_TYPE] = function (node) {\n                var name = node.name.value;\n                if (name in _this.reverseMap) {\n                    return __assign({}, node, { name: {\n                            kind: graphql_1.Kind.NAME,\n                            value: _this.reverseMap[name],\n                        } });\n                }\n            },\n            _a));\n        return {\n            document: newDocument,\n            variables: originalRequest.variables,\n        };\n    };\n    RenameTypes.prototype.transformResult = function (result) {\n        if (result.data) {\n            var data = this.renameTypes(result.data, 'data');\n            if (data !== result.data) {\n                return __assign({}, result, { data: data });\n            }\n        }\n        return result;\n    };\n    RenameTypes.prototype.renameTypes = function (value, name) {\n        var _this = this;\n        if (name === '__typename') {\n            return this.renamer(value);\n        }\n        if (value && typeof value === 'object') {\n            var newValue_1 = Array.isArray(value) ? []\n                // Create a new object with the same prototype.\n                : Object.create(Object.getPrototypeOf(value));\n            var returnNewValue_1 = false;\n            Object.keys(value).forEach(function (key) {\n                var oldChild = value[key];\n                var newChild = _this.renameTypes(oldChild, key);\n                newValue_1[key] = newChild;\n                if (newChild !== oldChild) {\n                    returnNewValue_1 = true;\n                }\n            });\n            if (returnNewValue_1) {\n                return newValue_1;\n            }\n        }\n        return value;\n    };\n    return RenameTypes;\n}());\nexports.default = RenameTypes;\n\n\n//# sourceURL=webpack:///./src/transforms/RenameTypes.ts?");

/***/ }),

/***/ "./src/transforms/ReplaceFieldWithFragment.ts":
/*!****************************************************!*\
  !*** ./src/transforms/ReplaceFieldWithFragment.ts ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar ReplaceFieldWithFragment = /** @class */ (function () {\n    function ReplaceFieldWithFragment(targetSchema, fragments) {\n        this.targetSchema = targetSchema;\n        this.mapping = {};\n        for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\n            var _a = fragments_1[_i], field = _a.field, fragment = _a.fragment;\n            var parsedFragment = parseFragmentToInlineFragment(fragment);\n            var actualTypeName = parsedFragment.typeCondition.name.value;\n            this.mapping[actualTypeName] = this.mapping[actualTypeName] || {};\n            if (this.mapping[actualTypeName][field]) {\n                this.mapping[actualTypeName][field].push(parsedFragment);\n            }\n            else {\n                this.mapping[actualTypeName][field] = [parsedFragment];\n            }\n        }\n    }\n    ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\n        var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n        return __assign({}, originalRequest, { document: document });\n    };\n    return ReplaceFieldWithFragment;\n}());\nexports.default = ReplaceFieldWithFragment;\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n    var _a;\n    var typeInfo = new graphql_1.TypeInfo(targetSchema);\n    return graphql_1.visit(document, graphql_1.visitWithTypeInfo(typeInfo, (_a = {},\n        _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n            var parentType = typeInfo.getParentType();\n            if (parentType) {\n                var parentTypeName_1 = parentType.name;\n                var selections_1 = node.selections;\n                if (mapping[parentTypeName_1]) {\n                    node.selections.forEach(function (selection) {\n                        if (selection.kind === graphql_1.Kind.FIELD) {\n                            var name_1 = selection.name.value;\n                            var fragments = mapping[parentTypeName_1][name_1];\n                            if (fragments && fragments.length > 0) {\n                                var fragment = concatInlineFragments(parentTypeName_1, fragments);\n                                selections_1 = selections_1.concat(fragment);\n                            }\n                        }\n                    });\n                }\n                if (selections_1 !== node.selections) {\n                    return __assign({}, node, { selections: selections_1 });\n                }\n            }\n        },\n        _a)));\n}\nfunction parseFragmentToInlineFragment(definitions) {\n    if (definitions.trim().startsWith('fragment')) {\n        var document_1 = graphql_1.parse(definitions);\n        for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n            var definition = _a[_i];\n            if (definition.kind === graphql_1.Kind.FRAGMENT_DEFINITION) {\n                return {\n                    kind: graphql_1.Kind.INLINE_FRAGMENT,\n                    typeCondition: definition.typeCondition,\n                    selectionSet: definition.selectionSet,\n                };\n            }\n        }\n    }\n    var query = graphql_1.parse(\"{\" + definitions + \"}\")\n        .definitions[0];\n    for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n        var selection = _c[_b];\n        if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n            return selection;\n        }\n    }\n    throw new Error('Could not parse fragment');\n}\nfunction concatInlineFragments(type, fragments) {\n    var fragmentSelections = fragments.reduce(function (selections, fragment) {\n        return selections.concat(fragment.selectionSet.selections);\n    }, []);\n    var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n    return {\n        kind: graphql_1.Kind.INLINE_FRAGMENT,\n        typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n                kind: graphql_1.Kind.NAME,\n                value: type,\n            },\n        },\n        selectionSet: {\n            kind: graphql_1.Kind.SELECTION_SET,\n            selections: deduplicatedFragmentSelection,\n        },\n    };\n}\nfunction deduplicateSelection(nodes) {\n    var selectionMap = nodes.reduce(function (map, node) {\n        var _a, _b, _c;\n        switch (node.kind) {\n            case 'Field': {\n                if (node.alias) {\n                    if (map.hasOwnProperty(node.alias.value)) {\n                        return map;\n                    }\n                    else {\n                        return __assign({}, map, (_a = {}, _a[node.alias.value] = node, _a));\n                    }\n                }\n                else {\n                    if (map.hasOwnProperty(node.name.value)) {\n                        return map;\n                    }\n                    else {\n                        return __assign({}, map, (_b = {}, _b[node.name.value] = node, _b));\n                    }\n                }\n            }\n            case 'FragmentSpread': {\n                if (map.hasOwnProperty(node.name.value)) {\n                    return map;\n                }\n                else {\n                    return __assign({}, map, (_c = {}, _c[node.name.value] = node, _c));\n                }\n            }\n            case 'InlineFragment': {\n                if (map.__fragment) {\n                    var fragment = map.__fragment;\n                    return __assign({}, map, { __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]) });\n                }\n                else {\n                    return __assign({}, map, { __fragment: node });\n                }\n            }\n            default: {\n                return map;\n            }\n        }\n    }, {});\n    var selection = Object.keys(selectionMap).reduce(function (selectionList, node) { return selectionList.concat(selectionMap[node]); }, []);\n    return selection;\n}\n\n\n//# sourceURL=webpack:///./src/transforms/ReplaceFieldWithFragment.ts?");

/***/ }),

/***/ "./src/transforms/TransformRootFields.ts":
/*!***********************************************!*\
  !*** ./src/transforms/TransformRootFields.ts ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar isEmptyObject_1 = __webpack_require__(/*! ../isEmptyObject */ \"./src/isEmptyObject.ts\");\nvar visitSchema_1 = __webpack_require__(/*! ./visitSchema */ \"./src/transforms/visitSchema.ts\");\nvar schemaRecreation_1 = __webpack_require__(/*! ../stitching/schemaRecreation */ \"./src/stitching/schemaRecreation.ts\");\nvar TransformRootFields = /** @class */ (function () {\n    function TransformRootFields(transform) {\n        this.transform = transform;\n    }\n    TransformRootFields.prototype.transformSchema = function (originalSchema) {\n        var _this = this;\n        var _a;\n        return visitSchema_1.visitSchema(originalSchema, (_a = {},\n            _a[visitSchema_1.VisitSchemaKind.QUERY] = function (type) {\n                return transformFields(type, function (fieldName, field) {\n                    return _this.transform('Query', fieldName, field);\n                });\n            },\n            _a[visitSchema_1.VisitSchemaKind.MUTATION] = function (type) {\n                return transformFields(type, function (fieldName, field) {\n                    return _this.transform('Mutation', fieldName, field);\n                });\n            },\n            _a[visitSchema_1.VisitSchemaKind.SUBSCRIPTION] = function (type) {\n                return transformFields(type, function (fieldName, field) {\n                    return _this.transform('Subscription', fieldName, field);\n                });\n            },\n            _a));\n    };\n    return TransformRootFields;\n}());\nexports.default = TransformRootFields;\nfunction transformFields(type, transformer) {\n    var resolveType = schemaRecreation_1.createResolveType(function (name, originalType) {\n        return originalType;\n    });\n    var fields = type.getFields();\n    var newFields = {};\n    Object.keys(fields).forEach(function (fieldName) {\n        var field = fields[fieldName];\n        var newField = transformer(fieldName, field);\n        if (typeof newField === 'undefined') {\n            newFields[fieldName] = schemaRecreation_1.fieldToFieldConfig(field, resolveType, true);\n        }\n        else if (newField !== null) {\n            if (newField.name) {\n                newFields[newField.name] = newField.field;\n            }\n            else {\n                newFields[fieldName] = newField;\n            }\n        }\n    });\n    if (isEmptyObject_1.default(newFields)) {\n        return null;\n    }\n    else {\n        return new graphql_1.GraphQLObjectType({\n            name: type.name,\n            description: type.description,\n            astNode: type.astNode,\n            fields: newFields,\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./src/transforms/TransformRootFields.ts?");

/***/ }),

/***/ "./src/transforms/WrapQuery.ts":
/*!*************************************!*\
  !*** ./src/transforms/WrapQuery.ts ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar WrapQuery = /** @class */ (function () {\n    function WrapQuery(path, wrapper, extractor) {\n        this.path = path;\n        this.wrapper = wrapper;\n        this.extractor = extractor;\n    }\n    WrapQuery.prototype.transformRequest = function (originalRequest) {\n        var _this = this;\n        var _a;\n        var document = originalRequest.document;\n        var fieldPath = [];\n        var ourPath = JSON.stringify(this.path);\n        var newDocument = graphql_1.visit(document, (_a = {},\n            _a[graphql_1.Kind.FIELD] = {\n                enter: function (node) {\n                    fieldPath.push(node.name.value);\n                    if (ourPath === JSON.stringify(fieldPath)) {\n                        var wrapResult = _this.wrapper(node.selectionSet);\n                        // Selection can be either a single selection or a selection set. If it's just one selection,\n                        // let's wrap it in a selection set. Otherwise, keep it as is.\n                        var selectionSet = wrapResult.kind === graphql_1.Kind.SELECTION_SET\n                            ? wrapResult\n                            : {\n                                kind: graphql_1.Kind.SELECTION_SET,\n                                selections: [wrapResult]\n                            };\n                        return __assign({}, node, { selectionSet: selectionSet });\n                    }\n                },\n                leave: function (node) {\n                    fieldPath.pop();\n                }\n            },\n            _a));\n        return __assign({}, originalRequest, { document: newDocument });\n    };\n    WrapQuery.prototype.transformResult = function (originalResult) {\n        var rootData = originalResult.data;\n        if (rootData) {\n            var data = rootData;\n            var path = this.path.slice();\n            while (path.length > 1) {\n                var next = path.shift();\n                if (data[next]) {\n                    data = data[next];\n                }\n            }\n            data[path[0]] = this.extractor(data[path[0]]);\n        }\n        return {\n            data: rootData,\n            errors: originalResult.errors\n        };\n    };\n    return WrapQuery;\n}());\nexports.default = WrapQuery;\n\n\n//# sourceURL=webpack:///./src/transforms/WrapQuery.ts?");

/***/ }),

/***/ "./src/transforms/index.ts":
/*!*********************************!*\
  !*** ./src/transforms/index.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar transformSchema_1 = __webpack_require__(/*! ./transformSchema */ \"./src/transforms/transformSchema.ts\");\nexports.transformSchema = transformSchema_1.default;\nvar AddArgumentsAsVariables_1 = __webpack_require__(/*! ./AddArgumentsAsVariables */ \"./src/transforms/AddArgumentsAsVariables.ts\");\nexports.AddArgumentsAsVariables = AddArgumentsAsVariables_1.default;\nvar CheckResultAndHandleErrors_1 = __webpack_require__(/*! ./CheckResultAndHandleErrors */ \"./src/transforms/CheckResultAndHandleErrors.ts\");\nexports.CheckResultAndHandleErrors = CheckResultAndHandleErrors_1.default;\nvar ReplaceFieldWithFragment_1 = __webpack_require__(/*! ./ReplaceFieldWithFragment */ \"./src/transforms/ReplaceFieldWithFragment.ts\");\nexports.ReplaceFieldWithFragment = ReplaceFieldWithFragment_1.default;\nvar AddTypenameToAbstract_1 = __webpack_require__(/*! ./AddTypenameToAbstract */ \"./src/transforms/AddTypenameToAbstract.ts\");\nexports.AddTypenameToAbstract = AddTypenameToAbstract_1.default;\nvar FilterToSchema_1 = __webpack_require__(/*! ./FilterToSchema */ \"./src/transforms/FilterToSchema.ts\");\nexports.FilterToSchema = FilterToSchema_1.default;\nvar RenameTypes_1 = __webpack_require__(/*! ./RenameTypes */ \"./src/transforms/RenameTypes.ts\");\nexports.RenameTypes = RenameTypes_1.default;\nvar FilterTypes_1 = __webpack_require__(/*! ./FilterTypes */ \"./src/transforms/FilterTypes.ts\");\nexports.FilterTypes = FilterTypes_1.default;\nvar TransformRootFields_1 = __webpack_require__(/*! ./TransformRootFields */ \"./src/transforms/TransformRootFields.ts\");\nexports.TransformRootFields = TransformRootFields_1.default;\nvar RenameRootFields_1 = __webpack_require__(/*! ./RenameRootFields */ \"./src/transforms/RenameRootFields.ts\");\nexports.RenameRootFields = RenameRootFields_1.default;\nvar FilterRootFields_1 = __webpack_require__(/*! ./FilterRootFields */ \"./src/transforms/FilterRootFields.ts\");\nexports.FilterRootFields = FilterRootFields_1.default;\nvar ExpandAbstractTypes_1 = __webpack_require__(/*! ./ExpandAbstractTypes */ \"./src/transforms/ExpandAbstractTypes.ts\");\nexports.ExpandAbstractTypes = ExpandAbstractTypes_1.default;\nvar ExtractField_1 = __webpack_require__(/*! ./ExtractField */ \"./src/transforms/ExtractField.ts\");\nexports.ExtractField = ExtractField_1.default;\nvar WrapQuery_1 = __webpack_require__(/*! ./WrapQuery */ \"./src/transforms/WrapQuery.ts\");\nexports.WrapQuery = WrapQuery_1.default;\n\n\n//# sourceURL=webpack:///./src/transforms/index.ts?");

/***/ }),

/***/ "./src/transforms/transformSchema.ts":
/*!*******************************************!*\
  !*** ./src/transforms/transformSchema.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar makeExecutableSchema_1 = __webpack_require__(/*! ../makeExecutableSchema */ \"./src/makeExecutableSchema.ts\");\nvar visitSchema_1 = __webpack_require__(/*! ../transforms/visitSchema */ \"./src/transforms/visitSchema.ts\");\nvar transforms_1 = __webpack_require__(/*! ../transforms/transforms */ \"./src/transforms/transforms.ts\");\nvar resolvers_1 = __webpack_require__(/*! ../stitching/resolvers */ \"./src/stitching/resolvers.ts\");\nfunction transformSchema(targetSchema, transforms) {\n    var schema = visitSchema_1.visitSchema(targetSchema, {}, true);\n    var mapping = resolvers_1.generateSimpleMapping(targetSchema);\n    var resolvers = resolvers_1.generateProxyingResolvers(targetSchema, transforms, mapping);\n    schema = makeExecutableSchema_1.addResolveFunctionsToSchema({\n        schema: schema,\n        resolvers: resolvers,\n        resolverValidationOptions: {\n            allowResolversNotInSchema: true,\n        },\n    });\n    schema = transforms_1.applySchemaTransforms(schema, transforms);\n    schema.transforms = transforms;\n    return schema;\n}\nexports.default = transformSchema;\n\n\n//# sourceURL=webpack:///./src/transforms/transformSchema.ts?");

/***/ }),

/***/ "./src/transforms/transforms.ts":
/*!**************************************!*\
  !*** ./src/transforms/transforms.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nfunction applySchemaTransforms(originalSchema, transforms) {\n    return transforms.reduce(function (schema, transform) {\n        return transform.transformSchema ? transform.transformSchema(schema) : schema;\n    }, originalSchema);\n}\nexports.applySchemaTransforms = applySchemaTransforms;\nfunction applyRequestTransforms(originalRequest, transforms) {\n    return transforms.reduce(function (request, transform) {\n        return transform.transformRequest\n            ? transform.transformRequest(request)\n            : request;\n    }, originalRequest);\n}\nexports.applyRequestTransforms = applyRequestTransforms;\nfunction applyResultTransforms(originalResult, transforms) {\n    return transforms.reduce(function (result, transform) {\n        return transform.transformResult ? transform.transformResult(result) : result;\n    }, originalResult);\n}\nexports.applyResultTransforms = applyResultTransforms;\nfunction composeTransforms() {\n    var transforms = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        transforms[_i] = arguments[_i];\n    }\n    var reverseTransforms = transforms.slice().reverse();\n    return {\n        transformSchema: function (originalSchema) {\n            return applySchemaTransforms(originalSchema, transforms);\n        },\n        transformRequest: function (originalRequest) {\n            return applyRequestTransforms(originalRequest, reverseTransforms);\n        },\n        transformResult: function (result) {\n            return applyResultTransforms(result, reverseTransforms);\n        },\n    };\n}\nexports.composeTransforms = composeTransforms;\n\n\n//# sourceURL=webpack:///./src/transforms/transforms.ts?");

/***/ }),

/***/ "./src/transforms/visitSchema.ts":
/*!***************************************!*\
  !*** ./src/transforms/visitSchema.ts ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", { value: true });\nvar graphql_1 = __webpack_require__(/*! graphql */ \"graphql\");\nvar schemaRecreation_1 = __webpack_require__(/*! ../stitching/schemaRecreation */ \"./src/stitching/schemaRecreation.ts\");\nvar VisitSchemaKind;\n(function (VisitSchemaKind) {\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind = exports.VisitSchemaKind || (exports.VisitSchemaKind = {}));\nfunction visitSchema(schema, visitor, stripResolvers) {\n    var types = {};\n    var resolveType = schemaRecreation_1.createResolveType(function (name) {\n        if (typeof types[name] === 'undefined') {\n            throw new Error(\"Can't find type \" + name + \".\");\n        }\n        return types[name];\n    });\n    var queryType = schema.getQueryType();\n    var mutationType = schema.getMutationType();\n    var subscriptionType = schema.getSubscriptionType();\n    var typeMap = schema.getTypeMap();\n    Object.keys(typeMap).map(function (typeName) {\n        var type = typeMap[typeName];\n        if (graphql_1.isNamedType(type) && graphql_1.getNamedType(type).name.slice(0, 2) !== '__') {\n            var specifiers = getTypeSpecifiers(type, schema);\n            var typeVisitor = getVisitor(visitor, specifiers);\n            if (typeVisitor) {\n                var result = typeVisitor(type, schema);\n                if (typeof result === 'undefined') {\n                    types[typeName] = schemaRecreation_1.recreateType(type, resolveType, !stripResolvers);\n                }\n                else if (result === null) {\n                    types[typeName] = null;\n                }\n                else {\n                    types[typeName] = schemaRecreation_1.recreateType(result, resolveType, !stripResolvers);\n                }\n            }\n            else {\n                types[typeName] = schemaRecreation_1.recreateType(type, resolveType, !stripResolvers);\n            }\n        }\n    });\n    return new graphql_1.GraphQLSchema({\n        query: queryType ? types[queryType.name] : null,\n        mutation: mutationType\n            ? types[mutationType.name]\n            : null,\n        subscription: subscriptionType\n            ? types[subscriptionType.name]\n            : null,\n        types: Object.keys(types).map(function (name) { return types[name]; }),\n    });\n}\nexports.visitSchema = visitSchema;\nfunction getTypeSpecifiers(type, schema) {\n    var specifiers = [VisitSchemaKind.TYPE];\n    if (type instanceof graphql_1.GraphQLObjectType) {\n        specifiers.unshift(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\n        var query = schema.getQueryType();\n        var mutation = schema.getMutationType();\n        var subscription = schema.getSubscriptionType();\n        if (type === query) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n        }\n        else if (type === mutation) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n        }\n        else if (type === subscription) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\n        }\n    }\n    else if (type instanceof graphql_1.GraphQLInputObjectType) {\n        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLInterfaceType) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLUnionType) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLEnumType) {\n        specifiers.push(VisitSchemaKind.ENUM_TYPE);\n    }\n    else if (type instanceof graphql_1.GraphQLScalarType) {\n        specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getVisitor(visitor, specifiers) {\n    var typeVisitor = null;\n    var stack = specifiers.slice();\n    while (!typeVisitor && stack.length > 0) {\n        var next = stack.pop();\n        typeVisitor = visitor[next];\n    }\n    return typeVisitor;\n}\n\n\n//# sourceURL=webpack:///./src/transforms/visitSchema.ts?");

/***/ }),

/***/ "apollo-link":
/*!******************************!*\
  !*** external "apollo-link" ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"apollo-link\");\n\n//# sourceURL=webpack:///external_%22apollo-link%22?");

/***/ }),

/***/ "deprecated-decorator":
/*!***************************************!*\
  !*** external "deprecated-decorator" ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"deprecated-decorator\");\n\n//# sourceURL=webpack:///external_%22deprecated-decorator%22?");

/***/ }),

/***/ "graphql":
/*!**************************!*\
  !*** external "graphql" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"graphql\");\n\n//# sourceURL=webpack:///external_%22graphql%22?");

/***/ }),

/***/ "graphql/error":
/*!********************************!*\
  !*** external "graphql/error" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"graphql/error\");\n\n//# sourceURL=webpack:///external_%22graphql/error%22?");

/***/ }),

/***/ "graphql/execution/values":
/*!*******************************************!*\
  !*** external "graphql/execution/values" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"graphql/execution/values\");\n\n//# sourceURL=webpack:///external_%22graphql/execution/values%22?");

/***/ }),

/***/ "iterall":
/*!**************************!*\
  !*** external "iterall" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"iterall\");\n\n//# sourceURL=webpack:///external_%22iterall%22?");

/***/ }),

/***/ "uuid":
/*!***********************!*\
  !*** external "uuid" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"uuid\");\n\n//# sourceURL=webpack:///external_%22uuid%22?");

/***/ })

/******/ })
			);
		}
	};
});